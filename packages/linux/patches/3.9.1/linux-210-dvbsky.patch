diff -urN a/drivers/media/dvb-frontends/Kconfig b/drivers/media/dvb-frontends/Kconfig
--- a/drivers/media/dvb-frontends/Kconfig	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/dvb-frontends/Kconfig	2013-05-06 21:23:52.000000000 +0800
@@ -200,6 +200,27 @@
 	help
 	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
 
+config DVB_M88DS3103
+	tristate "Montage M88DS3103 based"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
+config DVB_M88DC2800
+	tristate "Montage M88DC2800 based"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  A DVB-C tuner module. Say Y when you want to support this frontend.
+
+config DVB_SIT2
+	tristate "SIT2 based"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  A DVB-T2/T/C tuner module. Say Y when you want to support this frontend.
+	  	  
 config DVB_SI21XX
 	tristate "Silicon Labs SI21XX based"
 	depends on DVB_CORE && I2C
diff -urN a/drivers/media/dvb-frontends/m88dc2800.c b/drivers/media/dvb-frontends/m88dc2800.c
--- a/drivers/media/dvb-frontends/m88dc2800.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/m88dc2800.c	2013-01-26 16:03:21.000000000 +0800
@@ -0,0 +1,2124 @@
+/*
+    M88DC2800/M88TC2800  - DVB-C demodulator and tuner from Montage
+
+    Copyright (C) 2012 Max nibble<nibble.max@gmail.com>
+    Copyright (C) 2011 Montage Technology / www.montage-tech.com
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <asm/div64.h>
+#include "dvb_frontend.h"
+#include "m88dc2800.h"
+
+struct m88dc2800_state {
+	struct i2c_adapter *i2c;
+	const struct m88dc2800_config *config;
+	struct dvb_frontend frontend;
+	u32 freq;
+	u32 ber;
+	u32 sym;
+	u16 qam;
+	u8 inverted;
+	u32 xtal;
+	/* tuner state */
+	u8 tuner_init_OK;	/* Tuner initialize status */
+	u8 tuner_dev_addr;	/* Tuner device address */
+	u32 tuner_freq;		/* RF frequency to be set, unit: KHz */
+	u16 tuner_qam;		/* Reserved */
+	u16 tuner_mode;
+	u8 tuner_bandwidth;	/* Bandwidth of the channel, unit: MHz, 6/7/8 */
+	u8 tuner_loopthrough;	/* Tuner loop through switch, 0/1 */
+	u32 tuner_crystal;	/* Tuner crystal frequency, unit: KHz */
+	u32 tuner_dac;		/* Tuner DAC frequency, unit: KHz */
+	u16 tuner_mtt;		/* Tuner chip version, D1: 0x0d, E0: 0x0e, E1: 0x8e */
+	u16 tuner_custom_cfg;
+	u32 tuner_version;	/* Tuner driver version number */
+	u32 tuner_time;
+};
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Activates frontend debugging (default:0)");
+
+#define dprintk(args...) \
+	do { \
+		if (debug) \
+			printk(KERN_INFO "m88dc2800: " args); \
+	} while (0)
+
+
+static int m88dc2800_i2c_write(struct m88dc2800_state *state, u8 addr,
+			       u8 * p_data, u8 len)
+{
+	struct i2c_msg msg = { .flags = 0 };
+
+	msg.addr = addr;
+	msg.buf = p_data;
+	msg.len = len;
+
+	return i2c_transfer(state->i2c, &msg, 1);
+}
+
+static int m88dc2800_i2c_read(struct m88dc2800_state *state, u8 addr,
+			      u8 * p_data, u8 len)
+{
+	struct i2c_msg msg = { .flags = I2C_M_RD };
+
+	msg.addr = addr;
+	msg.buf = p_data;
+	msg.len = len;
+
+	return i2c_transfer(state->i2c, &msg, 1);
+}
+
+/*demod register operations.*/
+static int WriteReg(struct m88dc2800_state *state, u8 reg, u8 data)
+{
+	u8 buf[] = { reg, data };
+	u8 addr = state->config->demod_address;
+	int err;
+
+	dprintk("%s: write reg 0x%02x, value 0x%02x\n", __func__, reg, data);
+
+	err = m88dc2800_i2c_write(state, addr, buf, 2);
+
+	if (err != 1) {
+		printk(KERN_ERR
+		       "%s: writereg error(err == %i, reg == 0x%02x,"
+		       " value == 0x%02x)\n", __func__, err, reg, data);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int ReadReg(struct m88dc2800_state *state, u8 reg)
+{
+	int ret;
+	u8 b0[] = { reg };
+	u8 b1[] = { 0 };
+	u8 addr = state->config->demod_address;
+
+	ret = m88dc2800_i2c_write(state, addr, b0, 1);
+
+	if (ret != 1) {
+		printk(KERN_ERR "%s: reg=0x%x (error=%d)\n",
+		       __func__, reg, ret);
+		return -EIO;
+	}
+
+	ret = m88dc2800_i2c_read(state, addr, b1, 1);
+
+	dprintk("%s: read reg 0x%02x, value 0x%02x\n", __func__, reg, b1[0]);
+	return b1[0];
+}
+
+static int _mt_fe_tn_set_reg(struct m88dc2800_state *state, u8 reg,
+			     u8 data)
+{
+	int ret;
+	u8 buf[2];
+	u8 addr = state->tuner_dev_addr;
+
+	buf[1] = ReadReg(state, 0x86);
+	buf[1] |= 0x80;
+	ret = WriteReg(state, 0x86, buf[1]);
+
+	buf[0] = reg;
+	buf[1] = data;
+
+	ret = m88dc2800_i2c_write(state, addr, buf, 2);
+	if (ret != 1)
+		return -EIO;
+	return 0;
+}
+
+static int _mt_fe_tn_get_reg(struct m88dc2800_state *state, u8 reg,
+			     u8 * p_data)
+{
+	int ret;
+	u8 buf[2];
+	u8 addr = state->tuner_dev_addr;
+
+	buf[1] = ReadReg(state, 0x86);
+	buf[1] |= 0x80;
+	ret = WriteReg(state, 0x86, buf[1]);
+
+	buf[0] = reg;
+	ret = m88dc2800_i2c_write(state, addr, buf, 1);
+
+	msleep(1);
+
+	buf[1] = ReadReg(state, 0x86);
+	buf[1] |= 0x80;
+	ret = WriteReg(state, 0x86, buf[1]);
+
+	return m88dc2800_i2c_read(state, addr, p_data, 1);
+}
+
+/* Tuner operation functions.*/
+static int _mt_fe_tn_set_RF_front_tc2800(struct m88dc2800_state *state)
+{
+	u32 freq_KHz = state->tuner_freq;
+	u8 a, b, c;
+	if (state->tuner_mtt == 0xD1) {	/* D1 */
+		if (freq_KHz <= 123000) {
+			if (freq_KHz <= 56000) {
+				a = 0x00; b = 0x00; c = 0x00;
+			} else if (freq_KHz <= 64000) {
+				a = 0x10; b = 0x01; c = 0x08;
+			} else if (freq_KHz <= 72000) {
+				a = 0x20; b = 0x02; c = 0x10;
+			} else if (freq_KHz <= 80000) {
+				a = 0x30; b = 0x03; c = 0x18;
+			} else if (freq_KHz <= 88000) {
+				a = 0x40; b = 0x04; c = 0x20;
+			} else if (freq_KHz <= 96000) {
+				a = 0x50; b = 0x05; c = 0x28;
+			} else if (freq_KHz <= 104000) {
+				a = 0x60; b = 0x06; c = 0x30;
+			} else {
+				a = 0x70; b = 0x07; c = 0x38;
+			}
+			_mt_fe_tn_set_reg(state, 0x58, 0x9b);
+			_mt_fe_tn_set_reg(state, 0x59, a);
+			_mt_fe_tn_set_reg(state, 0x5d, b);
+			_mt_fe_tn_set_reg(state, 0x5e, c);
+			_mt_fe_tn_set_reg(state, 0x5a, 0x75);
+			_mt_fe_tn_set_reg(state, 0x73, 0x0c);
+		} else {	/* if (freq_KHz > 112000) */
+			_mt_fe_tn_set_reg(state, 0x58, 0x7b);
+			if (freq_KHz <= 304000) {
+				if (freq_KHz <= 136000) {
+					_mt_fe_tn_set_reg(state, 0x5e, 0x40);
+				} else if (freq_KHz <= 160000) {
+					_mt_fe_tn_set_reg(state, 0x5e, 0x48);
+				} else if (freq_KHz <= 184000) {
+					_mt_fe_tn_set_reg(state, 0x5e, 0x50);
+				} else if (freq_KHz <= 208000) {
+					_mt_fe_tn_set_reg(state, 0x5e, 0x58);
+				} else if (freq_KHz <= 232000) {
+					_mt_fe_tn_set_reg(state, 0x5e, 0x60);
+				} else if (freq_KHz <= 256000) {
+					_mt_fe_tn_set_reg(state, 0x5e, 0x68);
+				} else if (freq_KHz <= 280000) {
+					_mt_fe_tn_set_reg(state, 0x5e, 0x70);
+				} else {	/* if (freq_KHz <= 304000) */
+					_mt_fe_tn_set_reg(state, 0x5e, 0x78);
+				}
+				if (freq_KHz <= 171000) {
+					_mt_fe_tn_set_reg(state, 0x73, 0x08);
+				} else if (freq_KHz <= 211000) {
+					_mt_fe_tn_set_reg(state, 0x73, 0x0a);
+				} else {
+					_mt_fe_tn_set_reg(state, 0x73, 0x0e);
+				}
+			} else {	/* if (freq_KHz > 304000) */
+				_mt_fe_tn_set_reg(state, 0x5e, 0x88);
+				if (freq_KHz <= 400000) {
+					_mt_fe_tn_set_reg(state, 0x73, 0x0c);
+				} else if (freq_KHz <= 450000) {
+					_mt_fe_tn_set_reg(state, 0x73, 0x09);
+				} else if (freq_KHz <= 550000) {
+					_mt_fe_tn_set_reg(state, 0x73, 0x0e);
+				} else if (freq_KHz <= 650000) {
+					_mt_fe_tn_set_reg(state, 0x73, 0x0d);
+				} else {	/*if (freq_KHz > 650000) */
+					_mt_fe_tn_set_reg(state, 0x73, 0x0e);
+				}
+			}
+		}
+		if (freq_KHz > 800000)
+			_mt_fe_tn_set_reg(state, 0x87, 0x24);
+		else if (freq_KHz > 700000)
+			_mt_fe_tn_set_reg(state, 0x87, 0x34);
+		else if (freq_KHz > 500000)
+			_mt_fe_tn_set_reg(state, 0x87, 0x44);
+		else if (freq_KHz > 300000)
+			_mt_fe_tn_set_reg(state, 0x87, 0x43);
+		else if (freq_KHz > 220000)
+			_mt_fe_tn_set_reg(state, 0x87, 0x54);
+		else if (freq_KHz > 110000)
+			_mt_fe_tn_set_reg(state, 0x87, 0x14);
+		else
+			_mt_fe_tn_set_reg(state, 0x87, 0x54);
+		if (freq_KHz > 600000)
+			_mt_fe_tn_set_reg(state, 0x6a, 0x53);
+		else if (freq_KHz > 500000)
+			_mt_fe_tn_set_reg(state, 0x6a, 0x57);
+		else
+			_mt_fe_tn_set_reg(state, 0x6a, 0x59);
+		if (freq_KHz < 200000) {
+			_mt_fe_tn_set_reg(state, 0x20, 0x5d);
+		} else if (freq_KHz < 500000) {
+			_mt_fe_tn_set_reg(state, 0x20, 0x7d);
+		} else {
+			_mt_fe_tn_set_reg(state, 0x20, 0xfd);
+		}		/* end of 0xD1 */
+	} else if (state->tuner_mtt == 0xE1) {	/* E1 */
+		if (freq_KHz <= 112000) {	/* 123MHz */
+			if (freq_KHz <= 56000) {
+				_mt_fe_tn_set_reg(state, 0x5c, 0x01);
+			} else if (freq_KHz <= 64000) {
+				_mt_fe_tn_set_reg(state, 0x5c, 0x09);
+			} else if (freq_KHz <= 72000) {
+				_mt_fe_tn_set_reg(state, 0x5c, 0x11);
+			} else if (freq_KHz <= 80000) {
+				_mt_fe_tn_set_reg(state, 0x5c, 0x19);
+			} else if (freq_KHz <= 88000) {
+				_mt_fe_tn_set_reg(state, 0x5c, 0x21);
+			} else if (freq_KHz <= 96000) {
+				_mt_fe_tn_set_reg(state, 0x5c, 0x29);
+			} else if (freq_KHz <= 104000) {
+				_mt_fe_tn_set_reg(state, 0x5c, 0x31);
+			} else {	/* if (freq_KHz <= 112000) */
+				_mt_fe_tn_set_reg(state, 0x5c, 0x39);
+			}
+			_mt_fe_tn_set_reg(state, 0x5b, 0x30);
+		} else {	/* if (freq_KHz > 112000) */
+			if (freq_KHz <= 304000) {
+				if (freq_KHz <= 136000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x41);
+				} else if (freq_KHz <= 160000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x49);
+				} else if (freq_KHz <= 184000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x51);
+				} else if (freq_KHz <= 208000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x59);
+				} else if (freq_KHz <= 232000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x61);
+				} else if (freq_KHz <= 256000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x69);
+				} else if (freq_KHz <= 280000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x71);
+				} else {	/* if (freq_KHz <= 304000) */
+					_mt_fe_tn_set_reg(state, 0x5c, 0x79);
+				}
+				if (freq_KHz <= 150000) {
+					_mt_fe_tn_set_reg(state, 0x5b, 0x28);
+				} else if (freq_KHz <= 256000) {
+					_mt_fe_tn_set_reg(state, 0x5b, 0x29);
+				} else {
+					_mt_fe_tn_set_reg(state, 0x5b, 0x2a);
+				}
+			} else {	/* if (freq_KHz > 304000) */
+				if (freq_KHz <= 400000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x89);
+				} else if (freq_KHz <= 450000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x91);
+				} else if (freq_KHz <= 650000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x98);
+				} else if (freq_KHz <= 850000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0xa0);
+				} else {
+					_mt_fe_tn_set_reg(state, 0x5c, 0xa8);
+				}
+				_mt_fe_tn_set_reg(state, 0x5b, 0x08);
+			}
+		}
+	}			/* end of 0xE1 */
+	return 0;
+}
+
+static int _mt_fe_tn_cali_PLL_tc2800(struct m88dc2800_state *state,
+				     u32 freq_KHz,
+				     u32 cali_freq_thres_div2,
+				     u32 cali_freq_thres_div3r,
+				     u32 cali_freq_thres_div3)
+{
+	s32 N, F, MUL;
+	u8 buf, tmp, tmp2;
+	s32 M;
+	const s32 crystal_KHz = state->tuner_crystal;
+	 if (state->tuner_mtt == 0xD1) {
+		M = state->tuner_crystal / 4000;
+		if (freq_KHz > cali_freq_thres_div2) {
+			MUL = 4;
+			tmp = 2;
+		} else if (freq_KHz > 300000) {
+			MUL = 8;
+			tmp = 3;
+		} else if (freq_KHz > (cali_freq_thres_div2 / 2)) {
+			MUL = 8;
+			tmp = 4;
+		} else if (freq_KHz > (cali_freq_thres_div2 / 4)) {
+			MUL = 16;
+			tmp = 5;
+		} else if (freq_KHz > (cali_freq_thres_div2 / 8)) {
+			MUL = 32;
+			tmp = 6;
+		} else if (freq_KHz > (cali_freq_thres_div2 / 16)) {
+			MUL = 64;
+			tmp = 7;
+		} else {	/* invalid */
+			MUL = 0;
+			tmp = 0;
+			return 1;
+		}
+	} else if (state->tuner_mtt == 0xE1) {
+		M = state->tuner_crystal / 1000;
+		_mt_fe_tn_set_reg(state, 0x30, 0xff);
+		_mt_fe_tn_set_reg(state, 0x32, 0xe0);
+		_mt_fe_tn_set_reg(state, 0x33, 0x86);
+		_mt_fe_tn_set_reg(state, 0x37, 0x70);
+		_mt_fe_tn_set_reg(state, 0x38, 0x20);
+		_mt_fe_tn_set_reg(state, 0x39, 0x18);
+		_mt_fe_tn_set_reg(state, 0x89, 0x83);
+		if (freq_KHz > cali_freq_thres_div2) {
+			M = M / 4;
+			MUL = 4;
+			tmp = 2;
+			tmp2 = M + 16;	/* 48 */
+		} else if (freq_KHz > cali_freq_thres_div3r) {
+			M = M / 3;
+			MUL = 6;
+			tmp = 2;
+			tmp2 = M + 32;	/* 32 */
+		} else if (freq_KHz > cali_freq_thres_div3) {
+			M = M / 3;
+			MUL = 6;
+			tmp = 2;
+			tmp2 = M;	/* 16 */
+		} else if (freq_KHz > 304000) {
+			M = M / 4;
+			MUL = 8;
+			tmp = 3;
+			tmp2 = M + 16;	/* 48 */
+		} else if (freq_KHz > (cali_freq_thres_div2 / 2)) {
+			M = M / 4;
+			MUL = 8;
+			tmp = 4;
+			tmp2 = M + 16;	/* 48 */
+		} else if (freq_KHz > (cali_freq_thres_div3r / 2)) {
+			M = M / 3;
+			MUL = 12;
+			tmp = 4;
+			tmp2 = M + 32;	/* 32 */
+		} else if (freq_KHz > (cali_freq_thres_div3 / 2)) {
+			M = M / 3;
+			MUL = 12;
+			tmp = 4;
+			tmp2 = M;	/* 16 */
+		} else if (freq_KHz > (cali_freq_thres_div2 / 4)) {
+			M = M / 4;
+			MUL = 16;
+			tmp = 5;
+			tmp2 = M + 16;	/* 48 */
+		} else if (freq_KHz > (cali_freq_thres_div3r / 4)) {
+			M = M / 3;
+			MUL = 24;
+			tmp = 5;
+			tmp2 = M + 32;	/* 32 */
+		} else if (freq_KHz > (cali_freq_thres_div3 / 4)) {
+			M = M / 3;
+			MUL = 24;
+			tmp = 5;
+			tmp2 = M;	/* 16 */
+		} else if (freq_KHz > (cali_freq_thres_div2 / 8)) {
+			M = M / 4;
+			MUL = 32;
+			tmp = 6;
+			tmp2 = M + 16;	/* 48 */
+		} else if (freq_KHz > (cali_freq_thres_div3r / 8)) {
+			M = M / 3;
+			MUL = 48;
+			tmp = 6;
+			tmp2 = M + 32;	/* 32 */
+		} else if (freq_KHz > (cali_freq_thres_div3 / 8)) {
+			M = M / 3;
+			MUL = 48;
+			tmp = 6;
+			tmp2 = M;	/* 16 */
+		} else if (freq_KHz > (cali_freq_thres_div2 / 16)) {
+			M = M / 4;
+			MUL = 64;
+			tmp = 7;
+			tmp2 = M + 16;	/* 48 */
+		} else if (freq_KHz > (cali_freq_thres_div3r / 16)) {
+			M = M / 3;
+			MUL = 96;
+			tmp = 7;
+			tmp2 = M + 32;	/* 32 */
+		} else if (freq_KHz > (cali_freq_thres_div3 / 16)) {
+			M = M / 3;
+			MUL = 96;
+			tmp = 7;
+			tmp2 = M;	/* 16 */
+		} else {	/* invalid */
+			M = M / 4;
+			MUL = 0;
+			tmp = 0;
+			tmp2 = 48;
+			return 1;
+		}
+		if (freq_KHz == 291000) {
+			M = state->tuner_crystal / 1000 / 3;
+			MUL = 12;
+			tmp = 4;
+			tmp2 = M + 32;	/* 32 */
+		}
+		/*
+		   if (freq_KHz == 578000) {
+		   M = state->tuner_crystal / 1000 / 4;
+		   MUL = 4;
+		   tmp = 2;
+		   tmp2 = M + 16;	// 48
+		   }
+		 */
+		if (freq_KHz == 690000) {
+			M = state->tuner_crystal / 1000 / 3;
+			MUL = 4;
+			tmp = 2;
+			tmp2 = M + 16;	/* 48 */
+		}
+		_mt_fe_tn_get_reg(state, 0x33, &buf);
+		buf &= 0xc0;
+		buf += tmp2;
+		_mt_fe_tn_set_reg(state, 0x33, buf);
+	} else {
+		return 1;
+	}
+	_mt_fe_tn_get_reg(state, 0x39, &buf);
+	buf &= 0xf8;
+	buf += tmp;
+	_mt_fe_tn_set_reg(state, 0x39, buf);
+	N = (freq_KHz * MUL * M / crystal_KHz) / 2 * 2 - 256;
+	buf = (N >> 8) & 0xcf;
+	if (state->tuner_mtt == 0xE1) {
+		buf |= 0x30;
+	}
+	_mt_fe_tn_set_reg(state, 0x34, buf);
+	buf = N & 0xff;
+	_mt_fe_tn_set_reg(state, 0x35, buf);
+	F = ((freq_KHz * MUL * M / (crystal_KHz / 1000) / 2) -
+	     (freq_KHz * MUL * M / crystal_KHz / 2 * 1000)) * 64 / 1000;
+	buf = F & 0xff;
+	_mt_fe_tn_set_reg(state, 0x36, buf);
+	if (F == 0) {
+		if (state->tuner_mtt == 0xD1) {
+			_mt_fe_tn_set_reg(state, 0x3d, 0xca);
+		} else if (state->tuner_mtt == 0xE1) {
+			_mt_fe_tn_set_reg(state, 0x3d, 0xfe);
+		} else {
+			return 1;
+		}
+		_mt_fe_tn_set_reg(state, 0x3e, 0x9c);
+		_mt_fe_tn_set_reg(state, 0x3f, 0x34);
+	}
+	if (F > 0) {
+		if (state->tuner_mtt == 0xD1) {
+			if ((F == 32) || (F == 16) || (F == 48)) {
+				_mt_fe_tn_set_reg(state, 0x3e, 0xa4);
+				_mt_fe_tn_set_reg(state, 0x3d, 0x4a);
+				_mt_fe_tn_set_reg(state, 0x3f, 0x36);
+			} else {
+				_mt_fe_tn_set_reg(state, 0x3e, 0xa4);
+				_mt_fe_tn_set_reg(state, 0x3d, 0x4a);
+				_mt_fe_tn_set_reg(state, 0x3f, 0x36);
+			}
+		} else if (state->tuner_mtt == 0xE1) {
+			_mt_fe_tn_set_reg(state, 0x3e, 0xa4);
+			_mt_fe_tn_set_reg(state, 0x3d, 0x7e);
+			_mt_fe_tn_set_reg(state, 0x3f, 0x36);
+			_mt_fe_tn_set_reg(state, 0x89, 0x84);
+			_mt_fe_tn_get_reg(state, 0x39, &buf);
+			buf = buf & 0x1f;
+			_mt_fe_tn_set_reg(state, 0x39, buf);
+			_mt_fe_tn_get_reg(state, 0x32, &buf);
+			buf = buf | 0x02;
+			_mt_fe_tn_set_reg(state, 0x32, buf);
+		} else {
+			return 1;
+		}
+	}
+	_mt_fe_tn_set_reg(state, 0x41, 0x00);
+	if (state->tuner_mtt == 0xD1) {
+		msleep(5);
+	} else if (state->tuner_mtt == 0xE1) {
+		msleep(2);
+	} else {
+		return 1;
+	}
+	_mt_fe_tn_set_reg(state, 0x41, 0x02);
+	_mt_fe_tn_set_reg(state, 0x30, 0x7f);
+	_mt_fe_tn_set_reg(state, 0x30, 0xff);
+	_mt_fe_tn_set_reg(state, 0x31, 0x80);
+	_mt_fe_tn_set_reg(state, 0x31, 0x00);
+
+	return 0;
+}
+
+static int _mt_fe_tn_set_PLL_freq_tc2800(struct m88dc2800_state *state)
+{
+	u8 buf, buf1;
+	u32 freq_thres_div2_KHz, freq_thres_div3r_KHz,
+	    freq_thres_div3_KHz;
+	const u32 freq_KHz = state->tuner_freq;
+	if (state->tuner_mtt == 0xD1) {
+		_mt_fe_tn_set_reg(state, 0x32, 0xe1);
+		_mt_fe_tn_set_reg(state, 0x33, 0xa6);
+		_mt_fe_tn_set_reg(state, 0x37, 0x7f);
+		_mt_fe_tn_set_reg(state, 0x38, 0x20);
+		_mt_fe_tn_set_reg(state, 0x39, 0x18);
+		_mt_fe_tn_set_reg(state, 0x40, 0x40);
+		 freq_thres_div2_KHz = 520000;
+		_mt_fe_tn_cali_PLL_tc2800(state, freq_KHz,
+					   freq_thres_div2_KHz, 0, 0);
+		 msleep(5);
+		_mt_fe_tn_get_reg(state, 0x3a, &buf);
+		buf1 = buf;
+		buf = buf & 0x03;
+		buf1 = buf1 & 0x01;
+		if ((buf1 == 0) || (buf == 3)) {
+			freq_thres_div2_KHz = 420000;
+			_mt_fe_tn_cali_PLL_tc2800(state, freq_KHz,
+						   freq_thres_div2_KHz, 0,
+						   0);
+			msleep(5);
+			 _mt_fe_tn_get_reg(state, 0x3a, &buf);
+			buf = buf & 0x07;
+			if (buf == 5) {
+				freq_thres_div2_KHz = 520000;
+				_mt_fe_tn_cali_PLL_tc2800(state, freq_KHz,
+							   freq_thres_div2_KHz,
+							   0, 0);
+				msleep(5);
+			}
+		}
+		 _mt_fe_tn_get_reg(state, 0x38, &buf);
+		_mt_fe_tn_set_reg(state, 0x38, buf);
+		 _mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = buf | 0x10;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		 _mt_fe_tn_set_reg(state, 0x30, 0x7f);
+		_mt_fe_tn_set_reg(state, 0x30, 0xff);
+		 _mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = buf & 0xdf;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		_mt_fe_tn_set_reg(state, 0x40, 0x0);
+		 _mt_fe_tn_set_reg(state, 0x30, 0x7f);
+		_mt_fe_tn_set_reg(state, 0x30, 0xff);
+		_mt_fe_tn_set_reg(state, 0x31, 0x80);
+		_mt_fe_tn_set_reg(state, 0x31, 0x00);
+		msleep(5);
+		 _mt_fe_tn_get_reg(state, 0x39, &buf);
+		buf = buf >> 5;
+		if (buf < 5) {
+			_mt_fe_tn_get_reg(state, 0x39, &buf);
+			buf = buf | 0xa0;
+			buf = buf & 0xbf;
+			_mt_fe_tn_set_reg(state, 0x39, buf);
+			 _mt_fe_tn_get_reg(state, 0x32, &buf);
+			buf = buf | 0x02;
+			_mt_fe_tn_set_reg(state, 0x32, buf);
+		}
+		 _mt_fe_tn_get_reg(state, 0x37, &buf);
+		if (buf > 0x70) {
+			buf = 0x7f;
+			_mt_fe_tn_set_reg(state, 0x40, 0x40);
+		}
+		_mt_fe_tn_set_reg(state, 0x37, buf);
+		  _mt_fe_tn_get_reg(state, 0x38, &buf);
+		if (buf < 0x0f) {
+			buf = (buf & 0x0f) << 2;
+			buf = buf + 0x0f;
+			_mt_fe_tn_set_reg(state, 0x37, buf);
+		} else if (buf < 0x1f) {
+			buf = buf + 0x0f;
+			_mt_fe_tn_set_reg(state, 0x37, buf);
+		}
+		 _mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = (buf | 0x20) & 0xef;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		 _mt_fe_tn_set_reg(state, 0x41, 0x00);
+		msleep(5);
+		_mt_fe_tn_set_reg(state, 0x41, 0x02);
+	} else if (state->tuner_mtt == 0xE1) {
+		freq_thres_div2_KHz = 580000;
+		freq_thres_div3r_KHz = 500000;
+		freq_thres_div3_KHz = 440000;
+		_mt_fe_tn_cali_PLL_tc2800(state, freq_KHz,
+					   freq_thres_div2_KHz,
+					   freq_thres_div3r_KHz,
+					   freq_thres_div3_KHz);
+		msleep(3);
+		_mt_fe_tn_get_reg(state, 0x38, &buf);
+		_mt_fe_tn_set_reg(state, 0x38, buf);
+		_mt_fe_tn_set_reg(state, 0x30, 0x7f);
+		_mt_fe_tn_set_reg(state, 0x30, 0xff);
+		_mt_fe_tn_set_reg(state, 0x31, 0x80);
+		_mt_fe_tn_set_reg(state, 0x31, 0x00);
+		msleep(3);
+		_mt_fe_tn_get_reg(state, 0x38, &buf);
+		_mt_fe_tn_set_reg(state, 0x38, buf);
+		_mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = buf | 0x10;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		 _mt_fe_tn_set_reg(state, 0x30, 0x7f);
+		_mt_fe_tn_set_reg(state, 0x30, 0xff);
+		_mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = buf & 0xdf;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		_mt_fe_tn_set_reg(state, 0x31, 0x80);
+		_mt_fe_tn_set_reg(state, 0x31, 0x00);
+		msleep(3);
+		_mt_fe_tn_get_reg(state, 0x37, &buf);
+		_mt_fe_tn_set_reg(state, 0x37, buf);
+		/*
+		   if ((freq_KHz == 802000) || (freq_KHz == 826000)) {
+		   _mt_fe_tn_set_reg(state, 0x37, 0x5e);
+		   }
+		 */
+		_mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = (buf & 0xef) | 0x30;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		 _mt_fe_tn_set_reg(state, 0x41, 0x00);
+		msleep(2);
+		_mt_fe_tn_set_reg(state, 0x41, 0x02);
+	} else {
+		return 1;
+	}
+	return 0;
+}
+
+static int _mt_fe_tn_set_BB_tc2800(struct m88dc2800_state *state)
+{
+	return 0;
+}
+
+ static int _mt_fe_tn_set_appendix_tc2800(struct m88dc2800_state *state)
+
+{
+	u8 buf;
+	const u32 freq_KHz = state->tuner_freq;
+	if (state->tuner_mtt == 0xD1) {
+		if ((freq_KHz == 123000) || (freq_KHz == 147000) ||
+		    (freq_KHz == 171000) || (freq_KHz == 195000)) {
+			_mt_fe_tn_set_reg(state, 0x20, 0x1b);
+		}
+		if ((freq_KHz == 371000) || (freq_KHz == 419000) ||
+		    (freq_KHz == 610000) || (freq_KHz == 730000) ||
+		    (freq_KHz == 754000) || (freq_KHz == 826000)) {
+			_mt_fe_tn_get_reg(state, 0x0d, &buf);
+			_mt_fe_tn_set_reg(state, 0x0d, (u8) (buf + 1));
+		}
+		if ((freq_KHz == 522000) || (freq_KHz == 578000) ||
+		    (freq_KHz == 634000) || (freq_KHz == 690000) ||
+		    (freq_KHz == 834000)) {
+			_mt_fe_tn_get_reg(state, 0x0d, &buf);
+			_mt_fe_tn_set_reg(state, 0x0d, (u8) (buf - 1));
+		}
+	} else if (state->tuner_mtt == 0xE1) {
+		_mt_fe_tn_set_reg(state, 0x20, 0xfc);
+		if (freq_KHz == 123000 || freq_KHz == 147000 ||
+		    freq_KHz == 171000 || freq_KHz == 195000 ||
+		    freq_KHz == 219000 || freq_KHz == 267000 ||
+		    freq_KHz == 291000 || freq_KHz == 339000 ||
+		    freq_KHz == 387000 || freq_KHz == 435000 ||
+		    freq_KHz == 482000 || freq_KHz == 530000 ||
+		    freq_KHz == 722000 ||
+		    (state->tuner_custom_cfg == 1 && freq_KHz == 315000)) {
+			_mt_fe_tn_set_reg(state, 0x20, 0x5c);
+		}
+	}
+	return 0;
+}
+
+ static int _mt_fe_tn_set_DAC_tc2800(struct m88dc2800_state *state)
+{
+	u8 buf, tempnumber;
+	s32 N;
+	s32 f1f2number, f1, f2, delta1, Totalnum1;
+	s32 cntT, cntin, NCOI, z0, z1, z2, tmp;
+	u32 fc, fadc, fsd, f2d;
+	u32 FreqTrue108_Hz;
+	s32 M = state->tuner_crystal / 4000;
+	/* const u8 bandwidth = state->tuner_bandwidth; */
+	const u16 DAC_fre = 108;
+	const u32 crystal_KHz = state->tuner_crystal;
+	const u32 DACFreq_KHz = state->tuner_dac;
+	const u32 freq_KHz = state->tuner_freq;
+
+	if (state->tuner_mtt == 0xE1) {
+		_mt_fe_tn_get_reg(state, 0x33, &buf);
+		M = buf & 0x0f;
+		if (M == 0)
+			M = 6;
+	}
+	_mt_fe_tn_get_reg(state, 0x34, &buf);
+	N = buf & 0x07;
+	_mt_fe_tn_get_reg(state, 0x35, &buf);
+	N = (N << 8) + buf;
+	buf = ((N + 256) * crystal_KHz / M / DAC_fre + 500) / 1000;
+	if (state->tuner_mtt == 0xE1) {
+		_mt_fe_tn_set_appendix_tc2800(state);
+		if (freq_KHz == 187000 || freq_KHz == 195000 ||
+		    freq_KHz == 131000 || freq_KHz == 211000 ||
+		    freq_KHz == 219000 || freq_KHz == 227000 ||
+		    freq_KHz == 267000 || freq_KHz == 299000 ||
+		    freq_KHz == 347000 || freq_KHz == 363000 ||
+		    freq_KHz == 395000 || freq_KHz == 403000 ||
+		    freq_KHz == 435000 || freq_KHz == 482000 ||
+		    freq_KHz == 474000 || freq_KHz == 490000 ||
+		    freq_KHz == 610000 || freq_KHz == 642000 ||
+		    freq_KHz == 666000 || freq_KHz == 722000 ||
+		    freq_KHz == 754000 ||
+		    ((freq_KHz == 379000 || freq_KHz == 467000 ||
+		      freq_KHz == 762000) && state->tuner_custom_cfg != 1)) {
+			buf = buf + 1;
+		}
+		if (freq_KHz == 123000 || freq_KHz == 139000 ||
+		    freq_KHz == 147000 || freq_KHz == 171000 ||
+		    freq_KHz == 179000 || freq_KHz == 203000 ||
+		    freq_KHz == 235000 || freq_KHz == 251000 ||
+		    freq_KHz == 259000 || freq_KHz == 283000 ||
+		    freq_KHz == 331000 || freq_KHz == 363000 ||
+		    freq_KHz == 371000 || freq_KHz == 387000 ||
+		    freq_KHz == 411000 || freq_KHz == 427000 ||
+		    freq_KHz == 443000 || freq_KHz == 451000 ||
+		    freq_KHz == 459000 || freq_KHz == 506000 ||
+		    freq_KHz == 514000 || freq_KHz == 538000 ||
+		    freq_KHz == 546000 || freq_KHz == 554000 ||
+		    freq_KHz == 562000 || freq_KHz == 570000 ||
+		    freq_KHz == 578000 || freq_KHz == 602000 ||
+		    freq_KHz == 626000 || freq_KHz == 658000 ||
+		    freq_KHz == 690000 || freq_KHz == 714000 ||
+		    freq_KHz == 746000 || freq_KHz == 522000 ||
+		    freq_KHz == 826000 || freq_KHz == 155000 ||
+		    freq_KHz == 530000 ||
+		    ((freq_KHz == 275000 || freq_KHz == 355000) &&
+		     state->tuner_custom_cfg != 1) ||
+		    ((freq_KHz == 467000 || freq_KHz == 762000 ||
+		      freq_KHz == 778000 || freq_KHz == 818000) &&
+		     state->tuner_custom_cfg == 1)) {
+			buf = buf - 1;
+		}
+	}
+	 _mt_fe_tn_set_reg(state, 0x0e, buf);
+	_mt_fe_tn_set_reg(state, 0x0d, buf);
+	f1f2number =
+	    (((DACFreq_KHz * M * buf) / crystal_KHz) << 16) / (N + 256) +
+	    (((DACFreq_KHz * M * buf) % crystal_KHz) << 16) / ((N + 256) *
+								crystal_KHz);
+	_mt_fe_tn_set_reg(state, 0xf1, (f1f2number & 0xff00) >> 8);
+	_mt_fe_tn_set_reg(state, 0xf2, f1f2number & 0x00ff);
+	 FreqTrue108_Hz =
+	    (N + 256) * crystal_KHz / (M * buf) * 1000 +
+	    (((N + 256) * crystal_KHz) % (M * buf)) * 1000 / (M * buf);
+	f1 = 4096;
+	fc = FreqTrue108_Hz;
+	fadc = fc / 4;
+	fsd = 27000000;
+	f2d = state->tuner_bandwidth * 1000 / 2 - 150;
+	f2 = (fsd / 250) * f2d / ((fc + 500) / 1000);
+	delta1 = ((f1 - f2) << 15) / f2;
+	Totalnum1 = ((f1 - f2) << 15) - delta1 * f2;
+	cntT = f2;
+	cntin = Totalnum1;
+	NCOI = delta1;
+	 z0 = cntin;
+	z1 = cntT;
+	z2 = NCOI;
+	tempnumber = (z0 & 0xff00) >> 8;
+	_mt_fe_tn_set_reg(state, 0xc9, (u8) (tempnumber & 0x0f));
+	tempnumber = (z0 & 0xff);
+	_mt_fe_tn_set_reg(state, 0xca, tempnumber);
+	 tempnumber = (z1 & 0xff00) >> 8;
+	_mt_fe_tn_set_reg(state, 0xcb, tempnumber);
+	tempnumber = (z1 & 0xff);
+	_mt_fe_tn_set_reg(state, 0xcc, tempnumber);
+	 tempnumber = (z2 & 0xff00) >> 8;
+	_mt_fe_tn_set_reg(state, 0xcd, tempnumber);
+	tempnumber = (z2 & 0xff);
+	_mt_fe_tn_set_reg(state, 0xce, tempnumber);
+	 tmp = f1;
+	f1 = f2;
+	f2 = tmp / 2;
+	delta1 = ((f1 - f2) << 15) / f2;
+	Totalnum1 = ((f1 - f2) << 15) - delta1 * f2;
+	NCOI = (f1 << 15) / f2 - (1 << 15);
+	cntT = f2;
+	cntin = Totalnum1;
+	z0 = cntin;
+	z1 = cntT;
+	z2 = NCOI;
+	tempnumber = (z0 & 0xff00) >> 8;
+	_mt_fe_tn_set_reg(state, 0xd9, (u8) (tempnumber & 0x0f));
+	tempnumber = (z0 & 0xff);
+	_mt_fe_tn_set_reg(state, 0xda, tempnumber);
+	 tempnumber = (z1 & 0xff00) >> 8;
+	_mt_fe_tn_set_reg(state, 0xdb, tempnumber);
+	tempnumber = (z1 & 0xff);
+	_mt_fe_tn_set_reg(state, 0xdc, tempnumber);
+	 tempnumber = (z2 & 0xff00) >> 8;
+	_mt_fe_tn_set_reg(state, 0xdd, tempnumber);
+	tempnumber = (z2 & 0xff);
+	_mt_fe_tn_set_reg(state, 0xde, tempnumber);
+
+	return 0;
+}
+
+static int _mt_fe_tn_preset_tc2800(struct m88dc2800_state *state)
+{
+	if (state->tuner_mtt == 0xD1) {
+		_mt_fe_tn_set_reg(state, 0x19, 0x4a);
+		_mt_fe_tn_set_reg(state, 0x1b, 0x4b);
+		 _mt_fe_tn_set_reg(state, 0x04, 0x04);
+		_mt_fe_tn_set_reg(state, 0x17, 0x0d);
+		_mt_fe_tn_set_reg(state, 0x62, 0x6c);
+		_mt_fe_tn_set_reg(state, 0x63, 0xf4);
+		_mt_fe_tn_set_reg(state, 0x1f, 0x0e);
+		_mt_fe_tn_set_reg(state, 0x6b, 0xf4);
+		_mt_fe_tn_set_reg(state, 0x14, 0x01);
+		_mt_fe_tn_set_reg(state, 0x5a, 0x75);
+		_mt_fe_tn_set_reg(state, 0x66, 0x74);
+		_mt_fe_tn_set_reg(state, 0x72, 0xe0);
+		_mt_fe_tn_set_reg(state, 0x70, 0x07);
+		_mt_fe_tn_set_reg(state, 0x15, 0x7b);
+		_mt_fe_tn_set_reg(state, 0x55, 0x71);
+		 _mt_fe_tn_set_reg(state, 0x75, 0x55);
+		_mt_fe_tn_set_reg(state, 0x76, 0xac);
+		_mt_fe_tn_set_reg(state, 0x77, 0x6c);
+		_mt_fe_tn_set_reg(state, 0x78, 0x8b);
+		_mt_fe_tn_set_reg(state, 0x79, 0x42);
+		_mt_fe_tn_set_reg(state, 0x7a, 0xd2);
+		 _mt_fe_tn_set_reg(state, 0x81, 0x01);
+		_mt_fe_tn_set_reg(state, 0x82, 0x00);
+		_mt_fe_tn_set_reg(state, 0x82, 0x02);
+		_mt_fe_tn_set_reg(state, 0x82, 0x04);
+		_mt_fe_tn_set_reg(state, 0x82, 0x06);
+		_mt_fe_tn_set_reg(state, 0x82, 0x08);
+		_mt_fe_tn_set_reg(state, 0x82, 0x09);
+		_mt_fe_tn_set_reg(state, 0x82, 0x29);
+		_mt_fe_tn_set_reg(state, 0x82, 0x49);
+		_mt_fe_tn_set_reg(state, 0x82, 0x58);
+		_mt_fe_tn_set_reg(state, 0x82, 0x59);
+		_mt_fe_tn_set_reg(state, 0x82, 0x98);
+		_mt_fe_tn_set_reg(state, 0x82, 0x99);
+		_mt_fe_tn_set_reg(state, 0x10, 0x05);
+		_mt_fe_tn_set_reg(state, 0x10, 0x0d);
+		_mt_fe_tn_set_reg(state, 0x11, 0x95);
+		_mt_fe_tn_set_reg(state, 0x11, 0x9d);
+		if (state->tuner_loopthrough != 0) {
+			_mt_fe_tn_set_reg(state, 0x67, 0x25);
+		} else {
+			_mt_fe_tn_set_reg(state, 0x67, 0x05);
+		}
+	} else if (state->tuner_mtt == 0xE1) {
+		_mt_fe_tn_set_reg(state, 0x1b, 0x47);
+		if (state->tuner_mode == 0) {	/* DVB-C */
+			_mt_fe_tn_set_reg(state, 0x66, 0x74);
+			_mt_fe_tn_set_reg(state, 0x62, 0x2c);
+			_mt_fe_tn_set_reg(state, 0x63, 0x54);
+			_mt_fe_tn_set_reg(state, 0x68, 0x0b);
+			_mt_fe_tn_set_reg(state, 0x14, 0x00);
+		} else {			/* CTTB */
+			_mt_fe_tn_set_reg(state, 0x66, 0x74);
+			_mt_fe_tn_set_reg(state, 0x62, 0x0c);
+			_mt_fe_tn_set_reg(state, 0x63, 0x54);
+			_mt_fe_tn_set_reg(state, 0x68, 0x0b);
+			_mt_fe_tn_set_reg(state, 0x14, 0x05);
+		}
+		_mt_fe_tn_set_reg(state, 0x6f, 0x00);
+		_mt_fe_tn_set_reg(state, 0x84, 0x04);
+		_mt_fe_tn_set_reg(state, 0x5e, 0xbe);
+		_mt_fe_tn_set_reg(state, 0x87, 0x07);
+		_mt_fe_tn_set_reg(state, 0x8a, 0x1f);
+		_mt_fe_tn_set_reg(state, 0x8b, 0x1f);
+		_mt_fe_tn_set_reg(state, 0x88, 0x30);
+		_mt_fe_tn_set_reg(state, 0x58, 0x34);
+		_mt_fe_tn_set_reg(state, 0x61, 0x8c);
+		_mt_fe_tn_set_reg(state, 0x6a, 0x42);
+	}
+	return 0;
+}
+
+static int mt_fe_tn_wakeup_tc2800(struct m88dc2800_state *state)
+{
+	_mt_fe_tn_set_reg(state, 0x16, 0xb1);
+	_mt_fe_tn_set_reg(state, 0x09, 0x7d);
+	return 0;
+}
+
+  static int mt_fe_tn_sleep_tc2800(struct m88dc2800_state *state)
+{
+	_mt_fe_tn_set_reg(state, 0x16, 0xb0);
+	_mt_fe_tn_set_reg(state, 0x09, 0x6d);
+	return 0;
+}
+
+ static int mt_fe_tn_init_tc2800(struct m88dc2800_state *state)
+{
+	if (state->tuner_init_OK != 1) {
+		state->tuner_dev_addr = 0x61;	/* TUNER_I2C_ADDR_TC2800 */
+		state->tuner_freq = 650000;
+		state->tuner_qam = 0;
+		state->tuner_mode = 0;	// 0: DVB-C, 1: CTTB
+		state->tuner_bandwidth = 8;
+		state->tuner_loopthrough = 0;
+		state->tuner_crystal = 24000;
+		state->tuner_dac = 7200;
+		state->tuner_mtt = 0x00;
+		state->tuner_custom_cfg = 0;
+		state->tuner_version = 30022;	/* Driver version number */
+		state->tuner_time = 12092611;
+		state->tuner_init_OK = 1;
+	}
+	_mt_fe_tn_set_reg(state, 0x2b, 0x46);
+	_mt_fe_tn_set_reg(state, 0x2c, 0x75);
+	if (state->tuner_mtt == 0x00) {
+		u8 tmp = 0;
+		_mt_fe_tn_get_reg(state, 0x01, &tmp);
+		printk(KERN_INFO "m88dc2800: tuner id = 0x%02x ", tmp);
+		switch (tmp) {
+		case 0x0d:
+			state->tuner_mtt = 0xD1;
+			break;
+		case 0x8e:
+		default:
+			state->tuner_mtt = 0xE1;
+			break;
+		}
+	}
+	return 0;
+}
+
+ static int mt_fe_tn_set_freq_tc2800(struct m88dc2800_state *state,
+				       u32 freq_KHz)
+{
+	u8 buf;
+	u8 buf1;
+
+	mt_fe_tn_init_tc2800(state);
+	state->tuner_freq = freq_KHz;
+	_mt_fe_tn_set_reg(state, 0x21, freq_KHz > 500000 ? 0xb9 : 0x99);
+	mt_fe_tn_wakeup_tc2800(state);
+	 _mt_fe_tn_set_reg(state, 0x05, 0x7f);
+	_mt_fe_tn_set_reg(state, 0x06, 0xf8);
+	 _mt_fe_tn_set_RF_front_tc2800(state);
+	_mt_fe_tn_set_PLL_freq_tc2800(state);
+	_mt_fe_tn_set_DAC_tc2800(state);
+	_mt_fe_tn_set_BB_tc2800(state);
+	_mt_fe_tn_preset_tc2800(state);
+	 _mt_fe_tn_set_reg(state, 0x05, 0x00);
+	_mt_fe_tn_set_reg(state, 0x06, 0x00);
+	 if (state->tuner_mtt == 0xD1) {
+		_mt_fe_tn_set_reg(state, 0x00, 0x01);
+		_mt_fe_tn_set_reg(state, 0x00, 0x00);
+		 msleep(5);
+		_mt_fe_tn_set_reg(state, 0x41, 0x00);
+		msleep(5);
+		_mt_fe_tn_set_reg(state, 0x41, 0x02);
+
+		_mt_fe_tn_get_reg(state, 0x69, &buf1);
+		buf1 = buf1 & 0x0f;
+		_mt_fe_tn_get_reg(state, 0x61, &buf);
+		buf = buf & 0x0f;
+		if (buf == 0x0c)
+			_mt_fe_tn_set_reg(state, 0x6a, 0x59);
+		if (buf1 > 0x02) {
+			if (freq_KHz > 600000)
+				_mt_fe_tn_set_reg(state, 0x66, 0x44);
+			else if (freq_KHz > 500000)
+				_mt_fe_tn_set_reg(state, 0x66, 0x64);
+			else
+				_mt_fe_tn_set_reg(state, 0x66, 0x74);
+		}		
+		if (buf1 < 0x03) {
+			if (freq_KHz > 800000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x64);
+			else if (freq_KHz > 600000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x54);
+			else if (freq_KHz > 500000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x54);
+			else if (freq_KHz > 300000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x43);
+			else if (freq_KHz > 220000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x54);
+			else if (freq_KHz > 110000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x14);
+			else
+				_mt_fe_tn_set_reg(state, 0x87, 0x54);
+			msleep(5);
+		} else if (buf < 0x0c) {
+			if (freq_KHz > 800000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x14);
+			else if (freq_KHz > 600000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x14);
+			else if (freq_KHz > 500000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x34);
+			else if (freq_KHz > 300000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x43);
+			else if (freq_KHz > 220000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x54);
+			else if (freq_KHz > 110000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x14);
+			else
+				_mt_fe_tn_set_reg(state, 0x87, 0x54);
+			msleep(5);
+		}
+	} else if ((state->tuner_mtt == 0xE1)) {
+		_mt_fe_tn_set_reg(state, 0x00, 0x01);
+		_mt_fe_tn_set_reg(state, 0x00, 0x00);
+		 msleep(20);
+		 _mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = (buf & 0xef) | 0x28;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		 msleep(50);
+		_mt_fe_tn_get_reg(state, 0x38, &buf);
+		_mt_fe_tn_set_reg(state, 0x38, buf);
+		_mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = (buf & 0xf7) | 0x10;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		 msleep(10);
+		 _mt_fe_tn_get_reg(state, 0x69, &buf);
+		buf = buf & 0x03;
+		_mt_fe_tn_set_reg(state, 0x2a, buf);
+		if (buf > 0) {
+			msleep(20);
+			_mt_fe_tn_get_reg(state, 0x84, &buf);
+			buf = buf & 0x1f;
+			_mt_fe_tn_set_reg(state, 0x68, 0x0a);
+			_mt_fe_tn_get_reg(state, 0x88, &buf1);
+			buf1 = buf1 & 0x1f;
+			if (buf <= buf1)
+				_mt_fe_tn_set_reg(state, 0x66, 0x44);
+			else
+				_mt_fe_tn_set_reg(state, 0x66, 0x74);
+		} else {
+			if (freq_KHz <= 600000)
+				_mt_fe_tn_set_reg(state, 0x68, 0x0c);
+			else
+				_mt_fe_tn_set_reg(state, 0x68, 0x0e);
+			_mt_fe_tn_set_reg(state, 0x30, 0xfb);
+			_mt_fe_tn_set_reg(state, 0x30, 0xff);
+			_mt_fe_tn_set_reg(state, 0x31, 0x04);
+			_mt_fe_tn_set_reg(state, 0x31, 0x00);
+		}
+		if (state->tuner_loopthrough != 0) {
+			_mt_fe_tn_get_reg(state, 0x28, &buf);
+			if (buf == 0) {
+				_mt_fe_tn_set_reg(state, 0x28, 0xff);
+				_mt_fe_tn_get_reg(state, 0x61, &buf);
+				buf = buf & 0x0f;
+				if (buf > 9)
+					_mt_fe_tn_set_reg(state, 0x67, 0x74);
+				else if (buf > 6)
+					_mt_fe_tn_set_reg(state, 0x67, 0x64);
+				else if (buf > 3)
+					_mt_fe_tn_set_reg(state, 0x67, 0x54);
+				else
+					_mt_fe_tn_set_reg(state, 0x67, 0x44);
+			}
+		} else {
+			_mt_fe_tn_set_reg(state, 0x67, 0x34);
+		}
+	} else {
+		return 1;
+	}
+	return 0;
+}
+
+
+/*
+static int mt_fe_tn_set_BB_filter_band_tc2800(struct m88dc2800_state *state,
+					      u8 bandwidth)
+{
+	u8 buf, tmp;
+
+	_mt_fe_tn_get_reg(state, 0x53, &tmp);
+
+	if (bandwidth == 6)
+		buf = 0x01 << 1;
+	else if (bandwidth == 7)
+		buf = 0x02 << 1;
+	else if (bandwidth == 8)
+		buf = 0x04 << 1;
+	else
+		buf = 0x04 << 1;
+
+	tmp &= 0xf1;
+	tmp |= buf;
+	_mt_fe_tn_set_reg(state, 0x53, tmp);
+	state->tuner_bandwidth = bandwidth;
+	return 0;
+}
+*/
+
+static s32 mt_fe_tn_get_signal_strength_tc2800(struct m88dc2800_state
+					       *state)
+{
+	s32 level = -107;
+	s32 tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
+	s32 val1, val2, val;
+	s32 result2, result3, result4, result5, result6;
+	s32 append;
+	u8 tmp;
+	s32 freq_KHz = (s32) state->tuner_freq;
+	if (state->tuner_mtt == 0xD1) {
+		_mt_fe_tn_get_reg(state, 0x61, &tmp);
+		tmp1 = tmp & 0x0f;
+		 _mt_fe_tn_get_reg(state, 0x69, &tmp);
+		tmp2 = tmp & 0x0f;
+		 _mt_fe_tn_get_reg(state, 0x73, &tmp);
+		tmp3 = tmp & 0x07;
+		 _mt_fe_tn_get_reg(state, 0x7c, &tmp);
+		tmp4 = (tmp >> 4) & 0x0f;
+		 _mt_fe_tn_get_reg(state, 0x7b, &tmp);
+		tmp5 = tmp & 0x0f;
+		 _mt_fe_tn_get_reg(state, 0x7f, &tmp);
+		tmp6 = (tmp >> 5) & 0x01;
+		if (tmp1 > 6) {
+			val1 = 0;
+			if (freq_KHz <= 200000) {
+				val2 = (tmp1 - 6) * 267;
+			} else if (freq_KHz <= 600000) {
+				val2 = (tmp1 - 6) * 280;
+			} else {
+				val2 = (tmp1 - 6) * 290;
+			}
+			val = val1 + val2;
+		} else {
+			if (tmp1 == 0) {
+				val1 = -550;
+			} else {
+				val1 = 0;
+			}
+			if ((tmp1 < 4) && (freq_KHz >= 506000)) {
+				val1 = -850;
+			}
+			val2 = 0;
+			val = val1 + val2;
+		}
+		if (freq_KHz <= 95000) {
+			result2 = tmp2 * 289;
+		} else if (freq_KHz <= 155000) {
+			result2 = tmp2 * 278;
+		} else if (freq_KHz <= 245000) {
+			result2 = tmp2 * 267;
+		} else if (freq_KHz <= 305000) {
+			result2 = tmp2 * 256;
+		} else if (freq_KHz <= 335000) {
+			result2 = tmp2 * 244;
+		} else if (freq_KHz <= 425000) {
+			result2 = tmp2 * 233;
+		} else if (freq_KHz <= 575000) {
+			result2 = tmp2 * 222;
+		} else if (freq_KHz <= 665000) {
+			result2 = tmp2 * 211;
+		} else {
+			result2 = tmp2 * 200;
+		}
+		result3 = (6 - tmp3) * 100;
+		result4 = 300 * tmp4;
+		result5 = 50 * tmp5;
+		result6 = 300 * tmp6;
+		if (freq_KHz < 105000) {
+			append = -450;
+		} else if (freq_KHz <= 227000) {
+			append = -4 * (freq_KHz / 1000 - 100) + 150;
+		} else if (freq_KHz <= 305000) {
+			append = -4 * (freq_KHz / 1000 - 100);
+		} else if (freq_KHz <= 419000) {
+			append = 500 - 40 * (freq_KHz / 1000 - 300) / 17 + 130;
+		} else if (freq_KHz <= 640000) {
+			append = 500 - 40 * (freq_KHz / 1000 - 300) / 17;
+		} else {
+			append = -500;
+		}
+		level = append - (val + result2 + result3 + result4 +
+				  result5 + result6);
+		level /= 100;
+	} else if (state->tuner_mtt == 0xE1) {
+		_mt_fe_tn_get_reg(state, 0x61, &tmp);
+		tmp1 = tmp & 0x0f;
+		 _mt_fe_tn_get_reg(state, 0x84, &tmp);
+		tmp2 = tmp & 0x1f;
+		 _mt_fe_tn_get_reg(state, 0x69, &tmp);
+		tmp3 = tmp & 0x03;
+		 _mt_fe_tn_get_reg(state, 0x73, &tmp);
+		tmp4 = tmp & 0x0f;
+		 _mt_fe_tn_get_reg(state, 0x7c, &tmp);
+		tmp5 = (tmp >> 4) & 0x0f;
+		 _mt_fe_tn_get_reg(state, 0x7b, &tmp);
+		tmp6 = tmp & 0x0f;
+		if (freq_KHz < 151000) {
+			result2 = (1150 - freq_KHz / 100) * 163 / 33 + 4230;
+			result3 = (1150 - freq_KHz / 100) * 115 / 33 + 1850;
+			result4 = -3676 * (freq_KHz / 1000) / 100 + 6115;
+		} else if (freq_KHz < 257000) {
+			result2 = (1540 - freq_KHz / 100) * 11 / 4 + 3870;
+			result3 = (1540 - freq_KHz / 100) * 205 / 96 + 2100;
+			result4 = -21 * freq_KHz / 1000 + 5084;
+		} else if (freq_KHz < 305000) {
+			result2 = (2620 - freq_KHz / 100) * 5 / 3 + 2770;
+			result3 = (2620 - freq_KHz / 100) * 10 / 7 + 1700;
+			result4 = 650;
+		} else if (freq_KHz < 449000) {
+			result2 = (307 - freq_KHz / 1000) * 82 / 27 + 11270;
+			result3 = (3100 - freq_KHz / 100) * 5 / 3 + 10000;
+			result4 = 134 * freq_KHz / 10000 + 11875;
+		} else {
+			result2 = (307 - freq_KHz / 1000) * 82 / 27 + 11270;
+			result3 = 8400;
+			result4 = 5300;
+		}
+		if (tmp1 > 6) {
+			val1 = result2;
+			val2 = 2900;
+			val = 500;
+		} else if (tmp1 > 0) {
+			val1 = result3;
+			val2 = 2700;
+			val = 500;
+		} else {
+			val1 = result4;
+			val2 = 2700;
+			val = 400;
+		}
+		level = val1 - (val2 * tmp1 + 500 * tmp2 + 3000 * tmp3 -
+			    500 * tmp4 + 3000 * tmp5 + val * tmp6) - 1000;
+		level /= 1000;
+	}
+	return level;
+}
+
+
+/* m88dc2800 operation functions */
+u8 M88DC2000GetLock(struct m88dc2800_state * state)
+{
+	u8 u8ret = 0;
+	if (ReadReg(state, 0x80) < 0x06) {
+		if ((ReadReg(state, 0xdf) & 0x80) == 0x80
+		     &&(ReadReg(state, 0x91) & 0x23) == 0x03
+		     &&(ReadReg(state, 0x43) & 0x08) == 0x08)
+			u8ret = 1;
+		else
+			u8ret = 0;
+	} else {
+		if ((ReadReg(state, 0x85) & 0x08) == 0x08)
+			u8ret = 1;
+		else
+			u8ret = 0;
+	}
+	dprintk("%s, lock=%d\n", __func__, u8ret);
+	return u8ret;
+}
+
+static int M88DC2000SetTsType(struct m88dc2800_state *state, u8 type)
+{
+	u8 regC2H;
+
+	if (type == 3) {
+		WriteReg(state, 0x84, 0x6A);
+		WriteReg(state, 0xC0, 0x43);
+		WriteReg(state, 0xE2, 0x06);
+		regC2H = ReadReg(state, 0xC2);
+		regC2H &= 0xC0;
+		regC2H |= 0x1B;
+		WriteReg(state, 0xC2, regC2H);
+		WriteReg(state, 0xC1, 0x60);	/* common interface */
+	} else if (type == 1) {
+		WriteReg(state, 0x84, 0x6A);
+		WriteReg(state, 0xC0, 0x47);	/* serial format */
+		WriteReg(state, 0xE2, 0x02);
+		regC2H = ReadReg(state, 0xC2);
+		regC2H &= 0xC7;
+		WriteReg(state, 0xC2, regC2H);
+		WriteReg(state, 0xC1, 0x00);
+	} else {
+		WriteReg(state, 0x84, 0x6C);
+		WriteReg(state, 0xC0, 0x43);	/* parallel format */
+		WriteReg(state, 0xE2, 0x06);
+		regC2H = ReadReg(state, 0xC2);
+		regC2H &= 0xC7;
+		WriteReg(state, 0xC2, regC2H);
+		WriteReg(state, 0xC1, 0x00);
+	}
+	return 0;
+}
+
+static int M88DC2000RegInitial_TC2800(struct m88dc2800_state *state)
+{
+	u8 RegE3H, RegE4H;
+
+	WriteReg(state, 0x00, 0x48);
+	WriteReg(state, 0x01, 0x09);
+	WriteReg(state, 0xFB, 0x0A);
+	WriteReg(state, 0xFC, 0x0B);
+	WriteReg(state, 0x02, 0x0B);
+	WriteReg(state, 0x03, 0x18);
+	WriteReg(state, 0x05, 0x0D);
+	WriteReg(state, 0x36, 0x80);
+	WriteReg(state, 0x43, 0x40);
+	WriteReg(state, 0x55, 0x7A);
+	WriteReg(state, 0x56, 0xD9);
+	WriteReg(state, 0x57, 0xDF);
+	WriteReg(state, 0x58, 0x39);
+	WriteReg(state, 0x5A, 0x00);
+	WriteReg(state, 0x5C, 0x71);
+	WriteReg(state, 0x5D, 0x23);
+	WriteReg(state, 0x86, 0x40);
+	WriteReg(state, 0xF9, 0x08);
+	WriteReg(state, 0x61, 0x40);
+	WriteReg(state, 0x62, 0x0A);
+	WriteReg(state, 0x90, 0x06);
+	WriteReg(state, 0xDE, 0x00);
+	WriteReg(state, 0xA0, 0x03);
+	WriteReg(state, 0xDF, 0x81);
+	WriteReg(state, 0xFA, 0x40);
+	WriteReg(state, 0x37, 0x10);
+	WriteReg(state, 0xF0, 0x40);
+	WriteReg(state, 0xF2, 0x9C);
+	WriteReg(state, 0xF3, 0x40);
+	RegE3H = ReadReg(state, 0xE3);
+	RegE4H = ReadReg(state, 0xE4);
+	if (((RegE3H & 0xC0) == 0x00) && ((RegE4H & 0xC0) == 0x00)) {
+		WriteReg(state, 0x30, 0xFF);
+		WriteReg(state, 0x31, 0x00);
+		WriteReg(state, 0x32, 0x00);
+		WriteReg(state, 0x33, 0x00);
+		WriteReg(state, 0x35, 0x32);
+		WriteReg(state, 0x40, 0x00);
+		WriteReg(state, 0x41, 0x10);
+		WriteReg(state, 0xF1, 0x02);
+		WriteReg(state, 0xF4, 0x04);
+		WriteReg(state, 0xF5, 0x00);
+		WriteReg(state, 0x42, 0x14);
+		WriteReg(state, 0xE1, 0x25);
+	} else if (((RegE3H & 0xC0) == 0x80) && ((RegE4H & 0xC0) == 0x40)) {
+		WriteReg(state, 0x30, 0xFF);
+		WriteReg(state, 0x31, 0x00);
+		WriteReg(state, 0x32, 0x00);
+		WriteReg(state, 0x33, 0x00);
+		WriteReg(state, 0x35, 0x32);
+		WriteReg(state, 0x39, 0x00);
+		WriteReg(state, 0x3A, 0x00);
+		WriteReg(state, 0x40, 0x00);
+		WriteReg(state, 0x41, 0x10);
+		WriteReg(state, 0xF1, 0x00);
+		WriteReg(state, 0xF4, 0x00);
+		WriteReg(state, 0xF5, 0x40);
+		WriteReg(state, 0x42, 0x14);
+		WriteReg(state, 0xE1, 0x25);
+	} else if ((RegE3H == 0x80 || RegE3H == 0x81)
+		    && (RegE4H == 0x80 || RegE4H == 0x81)) {
+		WriteReg(state, 0x30, 0xFF);
+		WriteReg(state, 0x31, 0x00);
+		WriteReg(state, 0x32, 0x00);
+		WriteReg(state, 0x33, 0x00);
+		WriteReg(state, 0x35, 0x32);
+		WriteReg(state, 0x39, 0x00);
+		WriteReg(state, 0x3A, 0x00);
+		WriteReg(state, 0xF1, 0x00);
+		WriteReg(state, 0xF4, 0x00);
+		WriteReg(state, 0xF5, 0x40);
+		WriteReg(state, 0x42, 0x24);
+		WriteReg(state, 0xE1, 0x25);
+		WriteReg(state, 0x92, 0x7F);
+		WriteReg(state, 0x93, 0x91);
+		WriteReg(state, 0x95, 0x00);
+		WriteReg(state, 0x2B, 0x33);
+		WriteReg(state, 0x2A, 0x2A);
+		WriteReg(state, 0x2E, 0x80);
+		WriteReg(state, 0x25, 0x25);
+		WriteReg(state, 0x2D, 0xFF);
+		WriteReg(state, 0x26, 0xFF);
+		WriteReg(state, 0x27, 0x00);
+		WriteReg(state, 0x24, 0x25);
+		WriteReg(state, 0xA4, 0xFF);
+		WriteReg(state, 0xA3, 0x0D);
+	} else {
+		WriteReg(state, 0x30, 0xFF);
+		WriteReg(state, 0x31, 0x00);
+		WriteReg(state, 0x32, 0x00);
+		WriteReg(state, 0x33, 0x00);
+		WriteReg(state, 0x35, 0x32);
+		WriteReg(state, 0x39, 0x00);
+		WriteReg(state, 0x3A, 0x00);
+		WriteReg(state, 0xF1, 0x00);
+		WriteReg(state, 0xF4, 0x00);
+		WriteReg(state, 0xF5, 0x40);
+		WriteReg(state, 0x42, 0x24);
+		WriteReg(state, 0xE1, 0x27);
+		WriteReg(state, 0x92, 0x7F);
+		WriteReg(state, 0x93, 0x91);
+		WriteReg(state, 0x95, 0x00);
+		WriteReg(state, 0x2B, 0x33);
+		WriteReg(state, 0x2A, 0x2A);
+		WriteReg(state, 0x2E, 0x80);
+		WriteReg(state, 0x25, 0x25);
+		WriteReg(state, 0x2D, 0xFF);
+		WriteReg(state, 0x26, 0xFF);
+		WriteReg(state, 0x27, 0x00);
+		WriteReg(state, 0x24, 0x25);
+		WriteReg(state, 0xA4, 0xFF);
+		WriteReg(state, 0xA3, 0x10);
+	}
+	WriteReg(state, 0xF6, 0x4E);
+	WriteReg(state, 0xF7, 0x20);
+	WriteReg(state, 0x89, 0x02);
+	WriteReg(state, 0x14, 0x08);
+	WriteReg(state, 0x6F, 0x0D);
+	WriteReg(state, 0x10, 0xFF);
+	WriteReg(state, 0x11, 0x00);
+	WriteReg(state, 0x12, 0x30);
+	WriteReg(state, 0x13, 0x23);
+	WriteReg(state, 0x60, 0x00);
+	WriteReg(state, 0x69, 0x00);
+	WriteReg(state, 0x6A, 0x03);
+	WriteReg(state, 0xE0, 0x75);
+	WriteReg(state, 0x8D, 0x29);
+	WriteReg(state, 0x4E, 0xD8);
+	WriteReg(state, 0x88, 0x80);
+	WriteReg(state, 0x52, 0x79);
+	WriteReg(state, 0x53, 0x03);
+	WriteReg(state, 0x59, 0x30);
+	WriteReg(state, 0x5E, 0x02);
+	WriteReg(state, 0x5F, 0x0F);
+	WriteReg(state, 0x71, 0x03);
+	WriteReg(state, 0x72, 0x12);
+	WriteReg(state, 0x73, 0x12);
+
+	return 0;
+}
+
+static int M88DC2000AutoTSClock_P(struct m88dc2800_state *state, u32 sym,
+				  u16 qam)
+{
+	u32 dataRate;
+	u8 clk_div, value;
+	printk(KERN_INFO
+	       "m88dc2800: M88DC2000AutoTSClock_P, symrate=%d qam=%d\n",
+	       sym, qam);
+	switch (qam) {
+	case 16:
+		dataRate = 4;
+		break;
+	case 32:
+		dataRate = 5;
+		break;
+	case 128:
+		dataRate = 7;
+		break;
+	case 256:
+		dataRate = 8;
+		break;
+	case 64:
+	default:
+		dataRate = 6;
+		break;
+	}
+	dataRate *= sym * 105;
+	dataRate /= 800;
+	if (dataRate <= 4115)
+		clk_div = 0x05;
+	else if (dataRate <= 4800)
+		clk_div = 0x04;
+	else if (dataRate <= 5760)
+		clk_div = 0x03;
+	else if (dataRate <= 7200)
+		clk_div = 0x02;
+	else if (dataRate <= 9600)
+		clk_div = 0x01;
+	else
+		clk_div = 0x00;
+	value = ReadReg(state, 0xC2);
+	value &= 0xc0;
+	value |= clk_div;
+	WriteReg(state, 0xC2, value);
+	return 0;
+}
+
+static int M88DC2000AutoTSClock_C(struct m88dc2800_state *state, u32 sym,
+				  u16 qam)
+{
+	u32 dataRate;
+	u8 clk_div, value;
+	printk(KERN_INFO
+	       "m88dc2800: M88DC2000AutoTSClock_C, symrate=%d qam=%d\n",
+	       sym, qam);
+	switch (qam) {
+	case 16:
+		dataRate = 4;
+		break;
+	case 32:
+		dataRate = 5;
+		break;
+	case 128:
+		dataRate = 7;
+		break;
+	case 256:
+		dataRate = 8;
+		break;
+	case 64:
+	default:
+		dataRate = 6;
+		break;
+	}
+	dataRate *= sym * 105;
+	dataRate /= 800;
+	if (dataRate <= 4115)
+		clk_div = 0x3F;
+	else if (dataRate <= 4800)
+		clk_div = 0x36;
+	else if (dataRate <= 5760)
+		clk_div = 0x2D;
+	else if (dataRate <= 7200)
+		clk_div = 0x24;
+	else if (dataRate <= 9600)
+		clk_div = 0x1B;
+	else
+		clk_div = 0x12;
+	value = ReadReg(state, 0xC2);
+	value &= 0xc0;
+	value |= clk_div;
+	WriteReg(state, 0xC2, value);
+	return 0;
+}
+
+static int M88DC2000SetTxMode(struct m88dc2800_state *state, u8 inverted,
+			      u8 j83)
+{
+	u8 value = 0;
+	if (inverted)
+		value |= 0x08;	/*	spectrum inverted	*/
+	if (j83)
+		value |= 0x01;	/*	J83C			*/
+	WriteReg(state, 0x83, value);
+	return 0;
+}
+
+static int M88DC2000SoftReset(struct m88dc2800_state *state)
+{
+	WriteReg(state, 0x80, 0x01);
+	WriteReg(state, 0x82, 0x00);
+	msleep(1);
+	WriteReg(state, 0x80, 0x00);
+	return 0;
+}
+
+static int M88DC2000SetSym(struct m88dc2800_state *state, u32 sym, u32 xtal)
+{
+	u8 value;
+	u8 reg6FH, reg12H;
+	u64 fValue;
+	u32 dwValue;
+
+	printk(KERN_INFO "%s, sym=%d, xtal=%d\n", __func__, sym, xtal);
+	fValue = 4294967296 * (sym + 10);
+	do_div(fValue, xtal);
+
+	/* fValue  = 4294967296 * (sym + 10) / xtal; */
+	dwValue = (u32) fValue;
+	printk(KERN_INFO "%s, fvalue1=%x\n", __func__, dwValue);
+	WriteReg(state, 0x58, (u8) ((dwValue >> 24) & 0xff));
+	WriteReg(state, 0x57, (u8) ((dwValue >> 16) & 0xff));
+	WriteReg(state, 0x56, (u8) ((dwValue >> 8) & 0xff));
+	WriteReg(state, 0x55, (u8) ((dwValue >> 0) & 0xff));
+
+	/* fValue = 2048 * xtal / sym; */
+	fValue = 2048 * xtal;
+	do_div(fValue, sym);
+	dwValue = (u32) fValue;
+	printk(KERN_INFO "%s, fvalue2=%x\n", __func__, dwValue);
+	WriteReg(state, 0x5D, (u8) ((dwValue >> 8) & 0xff));
+	WriteReg(state, 0x5C, (u8) ((dwValue >> 0) & 0xff));
+	value = ReadReg(state, 0x5A);
+	if (((dwValue >> 16) & 0x0001) == 0)
+		value &= 0x7F;
+	else
+		value |= 0x80;
+	WriteReg(state, 0x5A, value);
+	value = ReadReg(state, 0x89);
+	if (sym <= 1800)
+		value |= 0x01;
+	else
+		value &= 0xFE;
+	WriteReg(state, 0x89, value);
+	if (sym >= 6700) {
+		reg6FH = 0x0D;
+		reg12H = 0x30;
+	} else if (sym >= 4000) {
+		fValue = 22 * 4096 / sym;
+		reg6FH = (u8) fValue;
+		reg12H = 0x30;
+	} else if (sym >= 2000) {
+		fValue = 14 * 4096 / sym;
+		reg6FH = (u8) fValue;
+		reg12H = 0x20;
+	} else {
+		fValue = 7 * 4096 / sym;
+		reg6FH = (u8) fValue;
+		reg12H = 0x10;
+	}
+	WriteReg(state, 0x6F, reg6FH);
+	WriteReg(state, 0x12, reg12H);
+	if (((ReadReg(state, 0xE3) & 0x80) == 0x80)
+	       && ((ReadReg(state, 0xE4) & 0x80) == 0x80)) {
+		if (sym < 3000) {
+			WriteReg(state, 0x6C, 0x16);
+			WriteReg(state, 0x6D, 0x10);
+			WriteReg(state, 0x6E, 0x18);
+		} else {
+			WriteReg(state, 0x6C, 0x14);
+			WriteReg(state, 0x6D, 0x0E);
+			WriteReg(state, 0x6E, 0x36);
+		}
+	} else {
+		WriteReg(state, 0x6C, 0x16);
+		WriteReg(state, 0x6D, 0x10);
+		WriteReg(state, 0x6E, 0x18);
+	}
+	return 0;
+}
+
+static int M88DC2000SetQAM(struct m88dc2800_state *state, u16 qam)
+{
+	u8 reg00H, reg4AH, regC2H, reg44H, reg4CH, reg4DH, reg74H, value;
+	u8 reg8BH, reg8EH;
+	printk(KERN_INFO "%s, qam=%d\n", __func__, qam);
+	regC2H = ReadReg(state, 0xC2);
+	regC2H &= 0xF8;
+	switch (qam) {
+	case 16:		/* 16 QAM */
+		reg00H = 0x08;
+		reg4AH = 0x0F;
+		regC2H |= 0x02;
+		reg44H = 0xAA;
+		reg4CH = 0x0C;
+		reg4DH = 0xF7;
+		reg74H = 0x0E;
+		if (((ReadReg(state, 0xE3) & 0x80) == 0x80)
+		     && ((ReadReg(state, 0xE4) & 0x80) == 0x80)) {
+			reg8BH = 0x5A;
+			reg8EH = 0xBD;
+		} else {
+			reg8BH = 0x5B;
+			reg8EH = 0x9D;
+		}
+		WriteReg(state, 0x6E, 0x18);
+		break;
+	case 32:		/* 32 QAM */
+		reg00H = 0x18;
+		reg4AH = 0xFB;
+		regC2H |= 0x02;
+		reg44H = 0xAA;
+		reg4CH = 0x0C;
+		reg4DH = 0xF7;
+		reg74H = 0x0E;
+		if (((ReadReg(state, 0xE3) & 0x80) == 0x80)
+		     && ((ReadReg(state, 0xE4) & 0x80) == 0x80)) {
+			reg8BH = 0x5A;
+			reg8EH = 0xBD;
+		} else {
+			reg8BH = 0x5B;
+			reg8EH = 0x9D;
+		}
+		WriteReg(state, 0x6E, 0x18);
+		break;
+	case 64:		/* 64 QAM */
+		reg00H = 0x48;
+		reg4AH = 0xCD;
+		regC2H |= 0x02;
+		reg44H = 0xAA;
+		reg4CH = 0x0C;
+		reg4DH = 0xF7;
+		reg74H = 0x0E;
+		if (((ReadReg(state, 0xE3) & 0x80) == 0x80)
+		     && ((ReadReg(state, 0xE4) & 0x80) == 0x80)) {
+			reg8BH = 0x5A;
+			reg8EH = 0xBD;
+		} else {
+			reg8BH = 0x5B;
+			reg8EH = 0x9D;
+		}
+		break;
+	case 128:		/* 128 QAM */
+		reg00H = 0x28;
+		reg4AH = 0xFF;
+		regC2H |= 0x02;
+		reg44H = 0xA9;
+		reg4CH = 0x08;
+		reg4DH = 0xF5;
+		reg74H = 0x0E;
+		reg8BH = 0x5B;
+		reg8EH = 0x9D;
+		break;
+	case 256:		/* 256 QAM */
+		reg00H = 0x38;
+		reg4AH = 0xCD;
+		if (((ReadReg(state, 0xE3) & 0x80) == 0x80)
+		     && ((ReadReg(state, 0xE4) & 0x80) == 0x80)) {
+			regC2H |= 0x02;
+		} else {
+			regC2H |= 0x01;
+		}
+		reg44H = 0xA9;
+		reg4CH = 0x08;
+		reg4DH = 0xF5;
+		reg74H = 0x0E;
+		reg8BH = 0x5B;
+		reg8EH = 0x9D;
+		break;
+	default:		/* 64 QAM */
+		reg00H = 0x48;
+		reg4AH = 0xCD;
+		regC2H |= 0x02;
+		reg44H = 0xAA;
+		reg4CH = 0x0C;
+		reg4DH = 0xF7;
+		reg74H = 0x0E;
+		if (((ReadReg(state, 0xE3) & 0x80) == 0x80)
+		     && ((ReadReg(state, 0xE4) & 0x80) == 0x80)) {
+			reg8BH = 0x5A;
+			reg8EH = 0xBD;
+		} else {
+			reg8BH = 0x5B;
+			reg8EH = 0x9D;
+		}
+		break;
+	}
+	WriteReg(state, 0x00, reg00H);
+	value = ReadReg(state, 0x88);
+	value |= 0x08;
+	WriteReg(state, 0x88, value);
+	WriteReg(state, 0x4B, 0xFF);
+	WriteReg(state, 0x4A, reg4AH);
+	value &= 0xF7;
+	WriteReg(state, 0x88, value);
+	WriteReg(state, 0xC2, regC2H);
+	WriteReg(state, 0x44, reg44H);
+	WriteReg(state, 0x4C, reg4CH);
+	WriteReg(state, 0x4D, reg4DH);
+	WriteReg(state, 0x74, reg74H);
+	WriteReg(state, 0x8B, reg8BH);
+	WriteReg(state, 0x8E, reg8EH);
+	return 0;
+}
+
+static int M88DC2000WriteTuner_TC2800(struct m88dc2800_state *state,
+				      u32 freq_KHz)
+{
+	printk(KERN_INFO "%s, freq=%d KHz\n", __func__, freq_KHz);
+	return mt_fe_tn_set_freq_tc2800(state, freq_KHz);
+}
+
+static int m88dc2800_init(struct dvb_frontend *fe)
+{
+	dprintk("%s()\n", __func__);
+	return 0;
+}
+
+static int m88dc2800_set_parameters(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u8 is_annex_c, is_update;
+	u16 temp_qam;
+	s32 waiting_time;
+	struct m88dc2800_state *state = fe->demodulator_priv;
+
+	is_annex_c = c->delivery_system == SYS_DVBC_ANNEX_C ? 1 : 0;
+
+	switch (c->modulation) {
+	case QAM_16:
+		temp_qam = 16;
+		break;
+	case QAM_32:
+		temp_qam = 32;
+		break;
+	case QAM_128:
+		temp_qam = 128;
+		break;
+	case QAM_256:
+		temp_qam = 256;
+		break;
+	default:		/* QAM_64 */
+		temp_qam = 64;
+		break;
+	}
+
+	state->inverted = c->inversion == INVERSION_ON ? 1 : 0;
+
+	printk(KERN_INFO
+	     "m88dc2800: state, freq=%d qam=%d sym=%d inverted=%d xtal=%d\n",
+	     state->freq, state->qam, state->sym, state->inverted,
+	     state->xtal);
+	printk(KERN_INFO
+	     "m88dc2800: set frequency to %d qam=%d symrate=%d annex-c=%d\n",
+	     c->frequency, temp_qam, c->symbol_rate, is_annex_c);
+
+	is_update = 0;
+	WriteReg(state, 0x80, 0x01);
+	if (c->frequency != state->freq) {
+		M88DC2000WriteTuner_TC2800(state, c->frequency / 1000);
+		state->freq = c->frequency;
+	}
+	if (c->symbol_rate != state->sym) {
+		M88DC2000SetSym(state, c->symbol_rate / 1000, state->xtal);
+		state->sym = c->symbol_rate;
+		is_update = 1;
+	}
+	if (temp_qam != state->qam) {
+		M88DC2000SetQAM(state, temp_qam);
+		state->qam = temp_qam;
+		is_update = 1;
+	}
+
+	if (is_update != 0) {
+		if (state->config->ts_mode == 3)
+			M88DC2000AutoTSClock_C(state, state->sym / 1000,
+					       temp_qam);
+		else
+			M88DC2000AutoTSClock_P(state, state->sym / 1000,
+					       temp_qam);
+	}
+
+	M88DC2000SetTxMode(state, state->inverted, is_annex_c);
+	M88DC2000SoftReset(state);
+	if (((ReadReg(state, 0xE3) & 0x80) == 0x80)
+	    && ((ReadReg(state, 0xE4) & 0x80) == 0x80))
+		waiting_time = 800;
+	else
+		waiting_time = 500;
+	while (waiting_time > 0) {
+		msleep(50);
+		waiting_time -= 50;
+		if (M88DC2000GetLock(state))
+			return 0;
+	}
+
+	state->inverted = (state->inverted != 0) ? 0 : 1;
+	M88DC2000SetTxMode(state, state->inverted, is_annex_c);
+	M88DC2000SoftReset(state);
+	if (((ReadReg(state, 0xE3) & 0x80) == 0x80) &&
+	    ((ReadReg(state, 0xE4) & 0x80) == 0x80))
+		waiting_time = 800;
+	else
+		waiting_time = 500;
+	while (waiting_time > 0) {
+		msleep(50);
+		waiting_time -= 50;
+		if (M88DC2000GetLock(state))
+			return 0;
+	}
+	return 0;
+}
+
+static int m88dc2800_read_status(struct dvb_frontend *fe,
+				 fe_status_t * status)
+{
+	struct m88dc2800_state *state = fe->demodulator_priv;
+	*status = 0;
+
+	if (M88DC2000GetLock(state)) {
+		*status = FE_HAS_SIGNAL | FE_HAS_CARRIER
+		    |FE_HAS_SYNC | FE_HAS_VITERBI | FE_HAS_LOCK;
+	}
+	return 0;
+}
+
+static int m88dc2800_read_ber(struct dvb_frontend *fe, u32 * ber)
+{
+	struct m88dc2800_state *state = fe->demodulator_priv;
+	u16 tmp;
+
+	if (M88DC2000GetLock(state) == 0) {
+		state->ber = 0;
+	} else if ((ReadReg(state, 0xA0) & 0x80) != 0x80) {
+		tmp = ReadReg(state, 0xA2) << 8;
+		tmp += ReadReg(state, 0xA1);
+		state->ber = tmp;
+		WriteReg(state, 0xA0, 0x05);
+		WriteReg(state, 0xA0, 0x85);
+	}
+	*ber = state->ber;
+	return 0;
+}
+
+static int m88dc2800_read_signal_strength(struct dvb_frontend *fe,
+					  u16 * strength)
+{
+	struct m88dc2800_state *state = fe->demodulator_priv;
+	s16 tuner_strength;
+
+	tuner_strength = mt_fe_tn_get_signal_strength_tc2800(state);
+	*strength = tuner_strength < -107 ? 0 : tuner_strength + 107;
+
+	return 0;
+}
+
+static int m88dc2800_read_snr(struct dvb_frontend *fe, u16 * snr)
+{
+	static const u32 mes_log[] = {
+		0, 3010, 4771, 6021, 6990, 7781, 8451, 9031, 9542, 10000,
+		10414, 10792, 11139, 11461, 11761, 12041, 12304, 12553, 12788,
+		13010, 13222, 13424, 13617, 13802, 13979, 14150, 14314, 14472,
+		14624, 14771, 14914, 15052, 15185, 15315, 15441, 15563, 15682,
+		15798, 15911, 16021, 16128, 16232, 16335, 16435, 16532, 16628,
+		16721, 16812, 16902, 16990, 17076, 17160, 17243, 17324, 17404,
+		17482, 17559, 17634, 17709, 17782, 17853, 17924, 17993, 18062,
+		18129, 18195, 18261, 18325, 18388, 18451, 18513, 18573, 18633,
+		18692, 18751, 18808, 18865, 18921, 18976, 19031
+	};
+	struct m88dc2800_state *state = fe->demodulator_priv;
+	u8 i;
+	u32 _snr, mse;
+
+	if ((ReadReg(state, 0x91) & 0x23) != 0x03) {
+		*snr = 0;
+		return 0;
+	}
+	mse = 0;
+	for (i = 0; i < 30; i++) {
+		mse += (ReadReg(state, 0x08) << 8) + ReadReg(state, 0x07);
+	}
+	mse /= 30;
+	if (mse > 80)
+		mse = 80;
+	switch (state->qam) {
+	case 16:
+		_snr = 34080;
+		break;		/*      16QAM                           */
+	case 32:
+		_snr = 37600;
+		break;		/*      32QAM                           */
+	case 64:
+		_snr = 40310;
+		break;		/*      64QAM                           */
+	case 128:
+		_snr = 43720;
+		break;		/*      128QAM                          */
+	case 256:
+		_snr = 46390;
+		break;		/*      256QAM                          */
+	default:
+		_snr = 40310;
+		break;
+	}
+	_snr -= mes_log[mse - 1];	/*      C - 10*log10(MSE)       */
+	_snr /= 1000;
+	if (_snr > 0xff)
+		_snr = 0xff;
+	*snr = _snr;
+	return 0;
+}
+
+static int m88dc2800_read_ucblocks(struct dvb_frontend *fe, u32 * ucblocks)
+{
+	struct m88dc2800_state *state = fe->demodulator_priv;
+	u8 u8Value;
+
+	u8Value = ReadReg(state, 0xdf);
+	u8Value |= 0x02;	/* Hold */
+	WriteReg(state, 0xdf, u8Value);
+
+	*ucblocks = ReadReg(state, 0xd5);
+	*ucblocks = (*ucblocks << 8) | ReadReg(state, 0xd4);
+
+	u8Value &= 0xfe;	/* Clear */
+	WriteReg(state, 0xdf, u8Value);
+	u8Value &= 0xfc;	/* Update */
+	u8Value |= 0x01;
+	WriteReg(state, 0xdf, u8Value);
+
+	return 0;
+}
+
+static int m88dc2800_sleep(struct dvb_frontend *fe)
+{
+	struct m88dc2800_state *state = fe->demodulator_priv;
+
+	mt_fe_tn_sleep_tc2800(state);
+	state->freq = 0;
+
+	return 0;
+}
+
+static void m88dc2800_release(struct dvb_frontend *fe)
+{
+	struct m88dc2800_state *state = fe->demodulator_priv;
+	kfree(state);
+}
+
+static struct dvb_frontend_ops m88dc2800_ops;
+
+struct dvb_frontend *m88dc2800_attach(const struct m88dc2800_config
+				      *config, struct i2c_adapter *i2c)
+{
+	struct m88dc2800_state *state = NULL;
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct m88dc2800_state), GFP_KERNEL);
+	if (state == NULL)
+		goto error;
+
+	/* setup the state */
+	state->config = config;
+	state->i2c = i2c;
+	state->xtal = 28800;
+
+	WriteReg(state, 0x80, 0x01);
+	M88DC2000RegInitial_TC2800(state);
+	M88DC2000SetTsType(state, state->config->ts_mode);
+	mt_fe_tn_init_tc2800(state);
+
+	/* create dvb_frontend */
+	memcpy(&state->frontend.ops, &m88dc2800_ops,
+	       sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+	return &state->frontend;
+
+      error:
+	kfree(state);
+	return NULL;
+}
+
+EXPORT_SYMBOL(m88dc2800_attach);
+
+static struct dvb_frontend_ops m88dc2800_ops = {
+	.delsys = {SYS_DVBC_ANNEX_A, SYS_DVBC_ANNEX_C},
+	.info = {
+		 .name = "Montage M88DC2800 DVB-C",
+		 .frequency_stepsize = 62500,
+		 .frequency_min = 48000000,
+		 .frequency_max = 870000000,
+		 .symbol_rate_min = 870000,
+		 .symbol_rate_max = 9000000,
+		 .caps = FE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 |
+			 FE_CAN_QAM_128 | FE_CAN_QAM_256 | FE_CAN_FEC_AUTO
+	},
+	.release = m88dc2800_release,
+	.init = m88dc2800_init,
+	.sleep = m88dc2800_sleep,
+	.set_frontend = m88dc2800_set_parameters,
+	.read_status = m88dc2800_read_status,
+	.read_ber = m88dc2800_read_ber,
+	.read_signal_strength = m88dc2800_read_signal_strength,
+	.read_snr = m88dc2800_read_snr,
+	.read_ucblocks = m88dc2800_read_ucblocks,
+};
+
+MODULE_DESCRIPTION("Montage DVB-C demodulator driver");
+MODULE_AUTHOR("Max Nibble <nibble.max@gmail.com>");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.00");
diff -urN a/drivers/media/dvb-frontends/m88dc2800.h b/drivers/media/dvb-frontends/m88dc2800.h
--- a/drivers/media/dvb-frontends/m88dc2800.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/m88dc2800.h	2013-01-26 14:57:32.000000000 +0800
@@ -0,0 +1,43 @@
+/*
+    M88DC2800/M88TC2800  - DVB-C demodulator and tuner from Montage
+
+    Copyright (C) 2012 Max Nibble <nibble.max@gmail.com>
+    Copyright (C) 2011 Montage Technology - www.montage-tech.com
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef M88DC2800_H
+#define M88DC2800_H
+
+#include <linux/dvb/frontend.h>
+
+struct m88dc2800_config {
+	u8 demod_address;
+	u8 ts_mode;
+};
+
+#if defined(CONFIG_DVB_M88DC2800) || (defined(CONFIG_DVB_M88DC2800_MODULE) && defined(MODULE))
+extern struct dvb_frontend* m88dc2800_attach(const struct m88dc2800_config* config,
+					    struct i2c_adapter* i2c);
+#else
+static inline struct dvb_frontend* m88dc2800_attach(const struct m88dc2800_config* config,
+					    struct i2c_adapter* i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif /* CONFIG_DVB_M88DC2800 */
+#endif /* M88DC2800_H */
diff -urN a/drivers/media/dvb-frontends/m88ds3103.c b/drivers/media/dvb-frontends/m88ds3103.c
--- a/drivers/media/dvb-frontends/m88ds3103.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/m88ds3103.c	2013-01-30 12:33:47.000000000 +0800
@@ -0,0 +1,1710 @@
+/*
+    Montage Technology M88DS3103/M88TS2022 - DVBS/S2 Satellite demod/tuner driver
+
+    Copyright (C) 2011 Max nibble<nibble.max@gmail.com>
+    Copyright (C) 2010 Montage Technology<www.montage-tech.com>
+    Copyright (C) 2009 Konstantin Dimitrov.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/firmware.h>
+
+#include "dvb_frontend.h"
+#include "m88ds3103.h"
+#include "m88ds3103_priv.h"
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Activates frontend debugging (default:0)");
+
+#define dprintk(args...) \
+	do { \
+		if (debug) \
+			printk(KERN_INFO "m88ds3103: " args); \
+	} while (0)
+
+/*demod register operations.*/
+static int m88ds3103_writereg(struct m88ds3103_state *state, int reg, int data)
+{
+	u8 buf[] = { reg, data };
+	struct i2c_msg msg = { .addr = state->config->demod_address,
+		.flags = 0, .buf = buf, .len = 2 };
+	int err;
+
+	if (debug > 1)
+		printk("m88ds3103: %s: write reg 0x%02x, value 0x%02x\n",
+			__func__, reg, data);
+
+	err = i2c_transfer(state->i2c, &msg, 1);
+	if (err != 1) {
+		printk(KERN_ERR "%s: writereg error(err == %i, reg == 0x%02x,"
+			 " value == 0x%02x)\n", __func__, err, reg, data);
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+static int m88ds3103_readreg(struct m88ds3103_state *state, u8 reg)
+{
+	int ret;
+	u8 b0[] = { reg };
+	u8 b1[] = { 0 };
+	struct i2c_msg msg[] = {
+		{ .addr = state->config->demod_address, .flags = 0,
+			.buf = b0, .len = 1 },
+		{ .addr = state->config->demod_address, .flags = I2C_M_RD,
+			.buf = b1, .len = 1 }
+	};
+	ret = i2c_transfer(state->i2c, msg, 2);
+
+	if (ret != 2) {
+		printk(KERN_ERR "%s: reg=0x%x (error=%d)\n",
+			__func__, reg, ret);
+		return ret;
+	}
+
+	if (debug > 1)
+		printk(KERN_INFO "m88ds3103: read reg 0x%02x, value 0x%02x\n",
+			reg, b1[0]);
+
+	return b1[0];
+}
+
+/*tuner register operations.*/
+static int m88ds3103_tuner_writereg(struct m88ds3103_state *state, int reg, int data)
+{
+	u8 buf[] = { reg, data };
+	struct i2c_msg msg = { .addr = 0x60,
+		.flags = 0, .buf = buf, .len = 2 };
+	int err;
+
+	m88ds3103_writereg(state, 0x03, 0x11);
+	err = i2c_transfer(state->i2c, &msg, 1);
+	
+	if (err != 1) {
+		printk("%s: writereg error(err == %i, reg == 0x%02x,"
+			 " value == 0x%02x)\n", __func__, err, reg, data);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static int m88ds3103_tuner_readreg(struct m88ds3103_state *state, u8 reg)
+{
+	int ret;
+	u8 b0[] = { reg };
+	u8 b1[] = { 0 };
+	struct i2c_msg msg[] = {
+		{ .addr = 0x60, .flags = 0,
+			.buf = b0, .len = 1 },
+		{ .addr = 0x60, .flags = I2C_M_RD,
+			.buf = b1, .len = 1 }
+	};
+
+	m88ds3103_writereg(state, 0x03, 0x11);	
+	ret = i2c_transfer(state->i2c, msg, 2);
+
+	if (ret != 2) {
+		printk(KERN_ERR "%s: reg=0x%x(error=%d)\n", __func__, reg, ret);
+		return ret;
+	}
+
+	return b1[0];
+}
+
+/* Bulk demod I2C write, for firmware download. */
+static int m88ds3103_writeregN(struct m88ds3103_state *state, int reg,
+				const u8 *data, u16 len)
+{
+	int ret = -EREMOTEIO;
+	struct i2c_msg msg;
+	u8 *buf;
+
+	buf = kmalloc(len + 1, GFP_KERNEL);
+	if (buf == NULL) {
+		printk("Unable to kmalloc\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	*(buf) = reg;
+	memcpy(buf + 1, data, len);
+
+	msg.addr = state->config->demod_address;
+	msg.flags = 0;
+	msg.buf = buf;
+	msg.len = len + 1;
+
+	if (debug > 1)
+		printk(KERN_INFO "m88ds3103: %s:  write regN 0x%02x, len = %d\n",
+			__func__, reg, len);
+
+	ret = i2c_transfer(state->i2c, &msg, 1);
+	if (ret != 1) {
+		printk(KERN_ERR "%s: writereg error(err == %i, reg == 0x%02x\n",
+			 __func__, ret, reg);
+		ret = -EREMOTEIO;
+	}
+	
+error:
+	kfree(buf);
+
+	return ret;
+}
+
+static int m88ds3103_load_firmware(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	const struct firmware *fw;
+	int i, ret = 0;
+
+	dprintk("%s()\n", __func__);
+		
+	if (state->skip_fw_load)
+		return 0;
+	/* Load firmware */
+	/* request the firmware, this will block until someone uploads it */	
+	if(state->demod_id == DS3000_ID){
+		printk(KERN_INFO "%s: Waiting for firmware upload (%s)...\n", __func__,
+				DS3000_DEFAULT_FIRMWARE);		
+		ret = request_firmware(&fw, DS3000_DEFAULT_FIRMWARE,
+					state->i2c->dev.parent);
+	}else if(state->demod_id == DS3103_ID){
+		printk(KERN_INFO "%s: Waiting for firmware upload (%s)...\n", __func__,
+				DS3103_DEFAULT_FIRMWARE);
+		ret = request_firmware(&fw, DS3103_DEFAULT_FIRMWARE,
+					state->i2c->dev.parent);
+	}
+	
+	printk(KERN_INFO "%s: Waiting for firmware upload(2)...\n", __func__);
+	if (ret) {
+		printk(KERN_ERR "%s: No firmware uploaded (timeout or file not "
+				"found?)\n", __func__);
+		return ret;
+	}
+
+	/* Make sure we don't recurse back through here during loading */
+	state->skip_fw_load = 1;
+
+	dprintk("Firmware is %zu bytes (%02x %02x .. %02x %02x)\n",
+			fw->size,
+			fw->data[0],
+			fw->data[1],
+			fw->data[fw->size - 2],
+			fw->data[fw->size - 1]);
+			
+	/* stop internal mcu. */
+	m88ds3103_writereg(state, 0xb2, 0x01);
+	/* split firmware to download.*/
+	for(i = 0; i < FW_DOWN_LOOP; i++){
+		ret = m88ds3103_writeregN(state, 0xb0, &(fw->data[FW_DOWN_SIZE*i]), FW_DOWN_SIZE);
+		if(ret != 1) break;		
+	}
+	/* start internal mcu. */
+	if(ret == 1)
+		m88ds3103_writereg(state, 0xb2, 0x00);
+		
+	release_firmware(fw);
+
+	dprintk("%s: Firmware upload %s\n", __func__,
+			ret == 1 ? "complete" : "failed");
+
+	if(ret == 1) ret = 0;
+	
+	/* Ensure firmware is always loaded if required */
+	state->skip_fw_load = 0;
+
+	return ret;
+}
+
+
+static int m88ds3103_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8 data;
+
+	dprintk("%s(%d)\n", __func__, voltage);
+
+	dprintk("m88ds3103:pin_ctrl = (%02x)\n", state->config->pin_ctrl);
+	
+	if(state->config->set_voltage)
+		state->config->set_voltage(fe, voltage);
+	
+	data = m88ds3103_readreg(state, 0xa2);
+	
+        if(state->config->pin_ctrl & 0x80){ /*If control pin is assigned.*/
+	        data &= ~0x03; /* bit0 V/H, bit1 off/on */
+	        if(state->config->pin_ctrl & 0x02)
+		     data |= 0x02;
+
+	        switch (voltage) {
+	        case SEC_VOLTAGE_18:
+		     if((state->config->pin_ctrl & 0x01) == 0)
+			  data |= 0x01;
+		     break;
+	        case SEC_VOLTAGE_13:
+		     if(state->config->pin_ctrl & 0x01)
+			  data |= 0x01;
+		     break;
+	        case SEC_VOLTAGE_OFF:
+		     if(state->config->pin_ctrl & 0x02)
+			   data &= ~0x02;			
+		     else
+			   data |= 0x02;
+		     break;
+	         }
+        }
+
+	m88ds3103_writereg(state, 0xa2, data);
+
+	return 0;
+}
+
+static int m88ds3103_read_status(struct dvb_frontend *fe, fe_status_t* status)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	int lock = 0;
+	
+	*status = 0;
+	
+	switch (state->delivery_system){
+	case SYS_DVBS:
+		lock = m88ds3103_readreg(state, 0xd1);
+		dprintk("%s: SYS_DVBS status=%x.\n", __func__, lock);
+		
+		if ((lock & 0x07) == 0x07){
+			/*if((m88ds3103_readreg(state, 0x0d) & 0x07) == 0x07)*/
+				*status = FE_HAS_SIGNAL | FE_HAS_CARRIER 
+					| FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+			
+		}
+		break;
+	case SYS_DVBS2:
+		lock = m88ds3103_readreg(state, 0x0d);
+		dprintk("%s: SYS_DVBS2 status=%x.\n", __func__, lock);
+
+		if ((lock & 0x8f) == 0x8f)
+			*status = FE_HAS_SIGNAL | FE_HAS_CARRIER 
+				| FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+			
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int m88ds3103_read_ber(struct dvb_frontend *fe, u32* ber)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8 tmp1, tmp2, tmp3;
+	u32 ldpc_frame_cnt, pre_err_packags, code_rate_fac = 0;
+
+	dprintk("%s()\n", __func__);
+
+	switch (state->delivery_system) {
+	case SYS_DVBS:
+		m88ds3103_writereg(state, 0xf9, 0x04);
+		tmp3 = m88ds3103_readreg(state, 0xf8);
+		if ((tmp3&0x10) == 0){
+			tmp1 = m88ds3103_readreg(state, 0xf7);
+			tmp2 = m88ds3103_readreg(state, 0xf6);
+			tmp3 |= 0x10;
+			m88ds3103_writereg(state, 0xf8, tmp3);
+			state->preBer = (tmp1<<8) | tmp2;
+		}
+		break;
+	case SYS_DVBS2:
+		tmp1 = m88ds3103_readreg(state, 0x7e) & 0x0f;
+		switch(tmp1){
+		case 0:	code_rate_fac = 16008 - 80; break;
+		case 1:	code_rate_fac = 21408 - 80; break;
+		case 2:	code_rate_fac = 25728 - 80; break;
+		case 3:	code_rate_fac = 32208 - 80; break;
+		case 4:	code_rate_fac = 38688 - 80; break;
+		case 5:	code_rate_fac = 43040 - 80; break;
+		case 6:	code_rate_fac = 48408 - 80; break;
+		case 7:	code_rate_fac = 51648 - 80; break;
+		case 8:	code_rate_fac = 53840 - 80; break;
+		case 9:	code_rate_fac = 57472 - 80; break;
+		case 10: code_rate_fac = 58192 - 80; break;
+		}
+		
+		tmp1 = m88ds3103_readreg(state, 0xd7) & 0xff;
+		tmp2 = m88ds3103_readreg(state, 0xd6) & 0xff;
+		tmp3 = m88ds3103_readreg(state, 0xd5) & 0xff;		
+		ldpc_frame_cnt = (tmp1 << 16) | (tmp2 << 8) | tmp3;
+
+		tmp1 = m88ds3103_readreg(state, 0xf8) & 0xff;
+		tmp2 = m88ds3103_readreg(state, 0xf7) & 0xff;
+		pre_err_packags = tmp1<<8 | tmp2;
+		
+		if (ldpc_frame_cnt > 1000){
+			m88ds3103_writereg(state, 0xd1, 0x01);
+			m88ds3103_writereg(state, 0xf9, 0x01);
+			m88ds3103_writereg(state, 0xf9, 0x00);
+			m88ds3103_writereg(state, 0xd1, 0x00);
+			state->preBer = pre_err_packags;
+		} 				
+		break;
+	default:
+		break;
+	}
+	*ber = state->preBer;
+	
+	return 0;
+}
+
+static int m88ds3103_read_signal_strength(struct dvb_frontend *fe,
+						u16 *signal_strength)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u16 gain;
+	u8 gain1, gain2, gain3 = 0;
+
+	dprintk("%s()\n", __func__);
+
+	gain1 = m88ds3103_tuner_readreg(state, 0x3d) & 0x1f;
+	dprintk("%s: gain1 = 0x%02x \n", __func__, gain1);
+	
+	if (gain1 > 15) gain1 = 15;
+	gain2 = m88ds3103_tuner_readreg(state, 0x21) & 0x1f;
+	dprintk("%s: gain2 = 0x%02x \n", __func__, gain2);
+	
+	if(state->tuner_id == TS2022_ID){
+		gain3 = (m88ds3103_tuner_readreg(state, 0x66)>>3) & 0x07;
+		dprintk("%s: gain3 = 0x%02x \n", __func__, gain3);
+		
+		if (gain2 > 16) gain2 = 16;
+		if (gain2 < 2) gain2 = 2;			
+		if (gain3 > 6) gain3 = 6;
+	}else{
+		if (gain2 > 13) gain2 = 13;
+		gain3 = 0;
+	}
+
+	gain = gain1*23 + gain2*35 + gain3*29;
+	*signal_strength = 60000 - gain*55;
+
+	return 0;
+}
+
+
+static int m88ds3103_read_snr(struct dvb_frontend *fe, u16 *p_snr)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8 val, npow1, npow2, spow1, cnt;
+	u16 tmp, snr;
+	u32 npow, spow, snr_total;	
+	static const u16 mes_log10[] ={
+		0,	3010,	4771,	6021, 	6990,	7781,	8451,	9031,	9542,	10000,
+		10414,	10792,	11139,	11461,	11761,	12041,	12304,	12553,	12788,	13010,
+		13222,	13424,	13617,	13802,	13979,	14150,	14314,	14472,	14624,	14771,
+		14914,	15052,	15185,	15315,	15441,	15563,	15682,	15798,	15911,	16021,
+		16128,	16232,	16335,	16435,	16532,	16628,	16721,	16812,	16902,	16990,
+		17076,	17160,	17243,	17324,	17404,	17482,	17559,	17634,	17709,	17782,
+		17853,	17924,	17993,	18062,	18129,	18195,	18261,	18325,	18388,	18451,
+		18513,	18573,	18633,	18692,	18751,	18808,	18865,	18921,	18976,	19031
+	};
+	static const u16 mes_loge[] ={
+		0,	6931,	10986,	13863, 	16094,	17918,	19459,	20794,	21972,	23026,
+		23979,	24849,	25649,	26391,	27081,	27726,	28332,	28904,	29444,	29957,
+		30445,	30910,	31355,	31781,	32189,	32581,	32958,	33322,	33673,	34012,
+		34340,	34657,
+	};
+
+	dprintk("%s()\n", __func__);
+
+	snr = 0;
+	
+	switch (state->delivery_system){
+	case SYS_DVBS:
+		cnt = 10; snr_total = 0;
+		while(cnt > 0){
+			val = m88ds3103_readreg(state, 0xff);
+			snr_total += val;
+			cnt--;
+		}
+		tmp = (u16)(snr_total/80);
+		if(tmp > 0){
+			if (tmp > 32) tmp = 32;
+			snr = (mes_loge[tmp - 1] * 100) / 45;
+		}else{
+			snr = 0;
+		}
+		break;
+	case SYS_DVBS2:
+		cnt  = 10; npow = 0; spow = 0;
+		while(cnt >0){
+			npow1 = m88ds3103_readreg(state, 0x8c) & 0xff;
+			npow2 = m88ds3103_readreg(state, 0x8d) & 0xff;
+			npow += (((npow1 & 0x3f) + (u16)(npow2 << 6)) >> 2);
+
+			spow1 = m88ds3103_readreg(state, 0x8e) & 0xff;
+			spow += ((spow1 * spow1) >> 1);
+			cnt--;
+		}
+		npow /= 10; spow /= 10;
+		if(spow == 0){
+			snr = 0;
+		}else if(npow == 0){
+			snr = 19;
+		}else{
+			if(spow > npow){
+				tmp = (u16)(spow / npow);
+				if (tmp > 80) tmp = 80;
+				snr = mes_log10[tmp - 1]*3;
+			}else{
+				tmp = (u16)(npow / spow);
+				if (tmp > 80) tmp = 80;
+				snr = -(mes_log10[tmp - 1] / 1000);
+			}
+		}			
+		break;
+	default:
+		break;
+	}
+	*p_snr = snr;
+
+	return 0;
+}
+
+
+static int m88ds3103_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8 tmp1, tmp2, tmp3, data;
+
+	dprintk("%s()\n", __func__);
+
+	switch (state->delivery_system) {
+	case SYS_DVBS:
+		data = m88ds3103_readreg(state, 0xf8);
+		data |= 0x40;
+		m88ds3103_writereg(state, 0xf8, data);		
+		tmp1 = m88ds3103_readreg(state, 0xf5);
+		tmp2 = m88ds3103_readreg(state, 0xf4);
+		*ucblocks = (tmp1 <<8) | tmp2;		
+		data &= ~0x20;
+		m88ds3103_writereg(state, 0xf8, data);
+		data |= 0x20;
+		m88ds3103_writereg(state, 0xf8, data);
+		data &= ~0x40;
+		m88ds3103_writereg(state, 0xf8, data);
+		break;
+	case SYS_DVBS2:
+		tmp1 = m88ds3103_readreg(state, 0xda);
+		tmp2 = m88ds3103_readreg(state, 0xd9);
+		tmp3 = m88ds3103_readreg(state, 0xd8);
+		*ucblocks = (tmp1 <<16)|(tmp2 <<8)|tmp3;
+		data = m88ds3103_readreg(state, 0xd1);
+		data |= 0x01;
+		m88ds3103_writereg(state, 0xd1, data);
+		data &= ~0x01;
+		m88ds3103_writereg(state, 0xd1, data);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int m88ds3103_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8 data_a1, data_a2;
+
+	dprintk("%s(%d)\n", __func__, tone);
+	if ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {
+		printk(KERN_ERR "%s: Invalid, tone=%d\n", __func__, tone);
+		return -EINVAL;
+	}
+
+	data_a1 = m88ds3103_readreg(state, 0xa1);
+	data_a2 = m88ds3103_readreg(state, 0xa2);
+	if(state->demod_id == DS3103_ID)
+		data_a2 &= 0xdf; /* Normal mode */
+	switch (tone) {
+	case SEC_TONE_ON:
+		dprintk("%s: SEC_TONE_ON\n", __func__);
+		data_a1 |= 0x04;
+		data_a1 &= ~0x03;
+		data_a1 &= ~0x40;
+		data_a2 &= ~0xc0;
+		break;
+	case SEC_TONE_OFF:
+		dprintk("%s: SEC_TONE_OFF\n", __func__);
+		data_a2 &= ~0xc0;
+		data_a2 |= 0x80;
+		break;
+	}
+	m88ds3103_writereg(state, 0xa2, data_a2);
+	m88ds3103_writereg(state, 0xa1, data_a1);
+	return 0;
+}
+
+static int m88ds3103_send_diseqc_msg(struct dvb_frontend *fe,
+				struct dvb_diseqc_master_cmd *d)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	int i, ret = 0;
+	u8 tmp, time_out;
+
+	/* Dump DiSEqC message */
+	if (debug) {
+		printk(KERN_INFO "m88ds3103: %s(", __func__);
+		for (i = 0 ; i < d->msg_len ;) {
+			printk(KERN_INFO "0x%02x", d->msg[i]);
+			if (++i < d->msg_len)
+				printk(KERN_INFO ", ");
+		}
+	}
+
+	tmp = m88ds3103_readreg(state, 0xa2);
+	tmp &= ~0xc0;
+	if(state->demod_id == DS3103_ID)
+		tmp &= ~0x20;
+	m88ds3103_writereg(state, 0xa2, tmp);
+	
+	for (i = 0; i < d->msg_len; i ++)
+		m88ds3103_writereg(state, (0xa3+i), d->msg[i]);
+
+	tmp = m88ds3103_readreg(state, 0xa1);	
+	tmp &= ~0x38;
+	tmp &= ~0x40;
+	tmp |= ((d->msg_len-1) << 3) | 0x07;
+	tmp &= ~0x80;
+	m88ds3103_writereg(state, 0xa1, tmp);
+	/*	1.5 * 9 * 8	= 108ms	*/
+	time_out = 150;
+	while (time_out > 0){
+		msleep(10);
+		time_out -= 10;
+		tmp = m88ds3103_readreg(state, 0xa1);		
+		if ((tmp & 0x40) == 0)
+			break;
+	}
+	if (time_out == 0){
+		tmp = m88ds3103_readreg(state, 0xa1);
+		tmp &= ~0x80;
+		tmp |= 0x40;
+		m88ds3103_writereg(state, 0xa1, tmp);
+		ret = 1;
+	}
+	tmp = m88ds3103_readreg(state, 0xa2);
+	tmp &= ~0xc0;
+	tmp |= 0x80;
+	m88ds3103_writereg(state, 0xa2, tmp);	
+	return ret;
+}
+
+
+static int m88ds3103_diseqc_send_burst(struct dvb_frontend *fe,
+					fe_sec_mini_cmd_t burst)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8	val, time_out;
+	
+	dprintk("%s()\n", __func__);
+
+	val = m88ds3103_readreg(state, 0xa2);
+	val &= ~0xc0;
+	if(state->demod_id == DS3103_ID)
+		val &= 0xdf; /* Normal mode */
+	m88ds3103_writereg(state, 0xa2, val);
+	/* DiSEqC burst */
+	if (burst == SEC_MINI_B)
+		m88ds3103_writereg(state, 0xa1, 0x01);
+	else
+		m88ds3103_writereg(state, 0xa1, 0x02);
+
+	msleep(13);
+
+	time_out = 5;
+	do{
+		val = m88ds3103_readreg(state, 0xa1);
+		if ((val & 0x40) == 0)
+			break;
+		msleep(1);
+		time_out --;
+	} while (time_out > 0);
+
+	val = m88ds3103_readreg(state, 0xa2);
+	val &= ~0xc0;
+	val |= 0x80;
+	m88ds3103_writereg(state, 0xa2, val);
+	
+	return 0;
+}
+
+static void m88ds3103_release(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+
+	dprintk("%s\n", __func__);
+	kfree(state);
+}
+
+static int m88ds3103_check_id(struct m88ds3103_state *state)
+{
+	int val_00, val_01;
+	
+	/*check demod id*/
+	val_01 = m88ds3103_readreg(state, 0x01);
+	printk(KERN_INFO "DS3000 chip version: %x attached.\n", val_01);
+			
+	if(val_01 == 0xD0)
+		state->demod_id = DS3103_ID;
+	else if(val_01 == 0xC0)
+		state->demod_id = DS3000_ID;
+	else
+		state->demod_id = UNKNOW_ID;
+		
+	/*check tuner id*/
+	val_00 = m88ds3103_tuner_readreg(state, 0x00);
+	printk(KERN_INFO "TS202x chip version[1]: %x attached.\n", val_00);
+	val_00 &= 0x03;
+	if(val_00 == 0)
+	{
+		m88ds3103_tuner_writereg(state, 0x00, 0x01);
+		msleep(3);		
+	}
+	m88ds3103_tuner_writereg(state, 0x00, 0x03);
+	msleep(5);
+	
+	val_00 = m88ds3103_tuner_readreg(state, 0x00);
+	printk(KERN_INFO "TS202x chip version[2]: %x attached.\n", val_00);
+	val_00 &= 0xff;
+	if((val_00 == 0x01) || (val_00 == 0x41) || (val_00 == 0x81))
+		state->tuner_id = TS2020_ID;
+	else if(((val_00 & 0xc0)== 0xc0) || (val_00 == 0x83))
+		state->tuner_id = TS2022_ID;
+	else
+		state->tuner_id = UNKNOW_ID;
+			
+	return state->demod_id;	
+}
+
+static struct dvb_frontend_ops m88ds3103_ops;
+static int m88ds3103_initilaze(struct dvb_frontend *fe);
+
+struct dvb_frontend *m88ds3103_attach(const struct m88ds3103_config *config,
+				    struct i2c_adapter *i2c)
+{
+	struct m88ds3103_state *state = NULL;
+
+	dprintk("%s\n", __func__);
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct m88ds3103_state), GFP_KERNEL);
+	if (state == NULL) {
+		printk(KERN_ERR "Unable to kmalloc\n");
+		goto error2;
+	}
+
+	state->config = config;
+	state->i2c = i2c;
+	state->preBer = 0xffff;
+	state->delivery_system = SYS_DVBS; /*Default to DVB-S.*/
+	
+	/* check demod id */
+	if(m88ds3103_check_id(state) == UNKNOW_ID){
+		printk(KERN_ERR "Unable to find Montage chip\n");
+		goto error3;
+	}
+
+	memcpy(&state->frontend.ops, &m88ds3103_ops,
+			sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+	
+	m88ds3103_initilaze(&state->frontend);
+	
+	return &state->frontend;
+
+error3:
+	kfree(state);
+error2:
+	return NULL;
+}
+EXPORT_SYMBOL(m88ds3103_attach);
+
+static int m88ds3103_set_carrier_offset(struct dvb_frontend *fe,
+					s32 carrier_offset_khz)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	s32 tmp;
+
+	tmp = carrier_offset_khz;
+	tmp *= 65536;
+	
+	tmp = (2*tmp + MT_FE_MCLK_KHZ) / (2*MT_FE_MCLK_KHZ);
+
+	if (tmp < 0)
+		tmp += 65536;
+
+	m88ds3103_writereg(state, 0x5f, tmp >> 8);
+	m88ds3103_writereg(state, 0x5e, tmp & 0xff);
+
+	return 0;
+}
+
+static int m88ds3103_set_symrate(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u16 value;
+	
+	value = (((c->symbol_rate / 1000) << 15) + (MT_FE_MCLK_KHZ / 4)) / (MT_FE_MCLK_KHZ / 2);
+	m88ds3103_writereg(state, 0x61, value & 0x00ff);
+	m88ds3103_writereg(state, 0x62, (value & 0xff00) >> 8);
+
+	return 0;
+}
+
+static int m88ds3103_set_CCI(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8 tmp;
+
+	tmp = m88ds3103_readreg(state, 0x56);
+	tmp &= ~0x01;
+	m88ds3103_writereg(state, 0x56, tmp);
+
+	tmp = m88ds3103_readreg(state, 0x76);
+	tmp &= ~0x80;
+	m88ds3103_writereg(state, 0x76, tmp);
+
+	return 0;
+}
+
+static int m88ds3103_init_reg(struct m88ds3103_state *state, const u8 *p_reg_tab, u32 size)
+{
+	u32 i;
+	
+	for(i = 0; i < size; i+=2)
+		m88ds3103_writereg(state, p_reg_tab[i], p_reg_tab[i+1]);
+		
+	return 0;
+}
+
+static int m88ds3103_get_locked_sym_rate(struct m88ds3103_state *state, u32 *sym_rate_KSs)
+{
+	u16	tmp;
+	u32	sym_rate_tmp;
+	u8	val_0x6d, val_0x6e;
+
+	val_0x6d = m88ds3103_readreg(state, 0x6d);
+	val_0x6e = m88ds3103_readreg(state, 0x6e);
+
+	tmp = (u16)((val_0x6e<<8) | val_0x6d);
+
+	sym_rate_tmp = (u32)(tmp * MT_FE_MCLK_KHZ);
+	sym_rate_tmp = (u32)(sym_rate_tmp / (1<<16));
+	*sym_rate_KSs = sym_rate_tmp;
+
+	return 0;
+}
+
+static int m88ds3103_get_channel_info(struct m88ds3103_state *state, u8 *p_mode, u8 *p_coderate)
+{
+	u8	tmp, val_0x7E;
+
+	if(state->delivery_system == SYS_DVBS2){
+		val_0x7E = m88ds3103_readreg(state, 0x7e);
+		tmp = (u8)((val_0x7E&0xC0) >> 6);
+		*p_mode = tmp;
+		tmp = (u8)(val_0x7E & 0x0f);
+		*p_coderate = tmp;
+	} else {
+		*p_mode = 0;
+		tmp = m88ds3103_readreg(state, 0xe6);		
+		tmp = (u8)(tmp >> 5);
+		*p_coderate = tmp;
+	}
+	
+	return 0;
+}
+
+static int m88ds3103_set_clock_ratio(struct m88ds3103_state *state)
+{
+	u8	val, mod_fac, tmp1, tmp2;
+	u32	input_datarate, locked_sym_rate_KSs;
+	u32 MClk_KHz = 96000;
+	u8 mod_mode, code_rate, divid_ratio = 0;
+
+	locked_sym_rate_KSs = 0;
+	m88ds3103_get_locked_sym_rate(state, &locked_sym_rate_KSs);
+	if(locked_sym_rate_KSs == 0)
+		return 0;
+
+	m88ds3103_get_channel_info(state, &mod_mode, &code_rate);
+
+	if (state->delivery_system == SYS_DVBS2)
+	{
+		switch(mod_mode) {
+			case 1: mod_fac = 3; break;
+			case 2:	mod_fac = 4; break;
+			case 3:	mod_fac = 5; break;
+			default: mod_fac = 2; break;
+		}
+
+		switch(code_rate) {
+			case 0: input_datarate = locked_sym_rate_KSs*mod_fac/8/4; break;
+			case 1: input_datarate = locked_sym_rate_KSs*mod_fac/8/3;  	break;
+			case 2: input_datarate = locked_sym_rate_KSs*mod_fac*2/8/5;	break;
+			case 3:	input_datarate = locked_sym_rate_KSs*mod_fac/8/2;	break;
+			case 4:	input_datarate = locked_sym_rate_KSs*mod_fac*3/8/5;	break;
+			case 5:	input_datarate = locked_sym_rate_KSs*mod_fac*2/8/3;	break;
+			case 6:	input_datarate = locked_sym_rate_KSs*mod_fac*3/8/4;	break;
+			case 7:	input_datarate = locked_sym_rate_KSs*mod_fac*4/8/5;	break;
+			case 8:	input_datarate = locked_sym_rate_KSs*mod_fac*5/8/6;	break;
+			case 9:	input_datarate = locked_sym_rate_KSs*mod_fac*8/8/9;	break;
+			case 10: input_datarate = locked_sym_rate_KSs*mod_fac*9/8/10; break;
+			default: input_datarate = locked_sym_rate_KSs*mod_fac*2/8/3; break;
+		}
+
+		if(state->demod_id == DS3000_ID)
+			input_datarate = input_datarate * 115 / 100;
+
+		if(input_datarate < 4800)  {tmp1 = 15;tmp2 = 15;} //4.8MHz         TS clock
+		else if(input_datarate < 4966)  {tmp1 = 14;tmp2 = 15;} //4.966MHz  TS clock
+		else if(input_datarate < 5143)  {tmp1 = 14;tmp2 = 14;} //5.143MHz  TS clock
+		else if(input_datarate < 5333)  {tmp1 = 13;tmp2 = 14;} //5.333MHz  TS clock
+		else if(input_datarate < 5538)  {tmp1 = 13;tmp2 = 13;} //5.538MHz  TS clock
+		else if(input_datarate < 5760)  {tmp1 = 12;tmp2 = 13;} //5.76MHz   TS clock       allan 0809
+		else if(input_datarate < 6000)  {tmp1 = 12;tmp2 = 12;} //6MHz      TS clock
+		else if(input_datarate < 6260)  {tmp1 = 11;tmp2 = 12;} //6.26MHz   TS clock
+		else if(input_datarate < 6545)  {tmp1 = 11;tmp2 = 11;} //6.545MHz  TS clock
+		else if(input_datarate < 6857)  {tmp1 = 10;tmp2 = 11;} //6.857MHz  TS clock
+		else if(input_datarate < 7200)  {tmp1 = 10;tmp2 = 10;} //7.2MHz    TS clock
+		else if(input_datarate < 7578)  {tmp1 = 9;tmp2 = 10;}  //7.578MHz  TS clock
+		else if(input_datarate < 8000)	{tmp1 = 9;tmp2 = 9;}   //8MHz      TS clock
+		else if(input_datarate < 8470)	{tmp1 = 8;tmp2 = 9;}   //8.47MHz   TS clock
+		else if(input_datarate < 9000)	{tmp1 = 8;tmp2 = 8;}   //9MHz      TS clock
+		else if(input_datarate < 9600)	{tmp1 = 7;tmp2 = 8;}   //9.6MHz    TS clock
+		else if(input_datarate < 10285)	{tmp1 = 7;tmp2 = 7;}   //10.285MHz TS clock
+		else if(input_datarate < 12000)	{tmp1 = 6;tmp2 = 6;}   //12MHz     TS clock
+		else if(input_datarate < 14400)	{tmp1 = 5;tmp2 = 5;}   //14.4MHz   TS clock
+		else if(input_datarate < 18000)	{tmp1 = 4;tmp2 = 4;}   //18MHz     TS clock
+		else							{tmp1 = 3;tmp2 = 3;}   //24MHz     TS clock
+
+		if(state->demod_id == DS3000_ID) {
+			val = (u8)((tmp1<<4) + tmp2);
+			m88ds3103_writereg(state, 0xfe, val);
+		} else {
+			tmp1 = m88ds3103_readreg(state, 0x22);
+			tmp2 = m88ds3103_readreg(state, 0x24);
+
+			tmp1 >>= 6;
+			tmp1 &= 0x03;
+			tmp2 >>= 6;
+			tmp2 &= 0x03;
+
+			if((tmp1 == 0x00) && (tmp2 == 0x01))
+				MClk_KHz = 144000;
+			else if((tmp1 == 0x00) && (tmp2 == 0x03))
+				MClk_KHz = 72000;
+			else if((tmp1 == 0x01) && (tmp2 == 0x01))
+				MClk_KHz = 115200;
+			else if((tmp1 == 0x02) && (tmp2 == 0x01))
+				MClk_KHz = 96000;
+			else if((tmp1 == 0x03) && (tmp2 == 0x00))
+				MClk_KHz = 192000;
+			else
+				return 0;
+
+			if(input_datarate < 5200) /*Max. 2011-12-23 11:55*/
+				input_datarate = 5200;
+				
+			if(input_datarate != 0)
+				divid_ratio = (u8)(MClk_KHz / input_datarate);
+			else
+				divid_ratio = 0xFF;
+
+			if(divid_ratio > 128)
+				divid_ratio = 128;
+
+			if(divid_ratio < 2)
+				divid_ratio = 2;
+
+			tmp1 = (u8)(divid_ratio / 2);
+			tmp2 = (u8)(divid_ratio / 2);
+
+			if((divid_ratio % 2) != 0)
+				tmp2 += 1;
+
+			tmp1 -= 1;
+			tmp2 -= 1;
+
+			tmp1 &= 0x3f;
+			tmp2 &= 0x3f;
+
+			val = m88ds3103_readreg(state, 0xfe);
+			val &= 0xF0;
+			val |= (tmp2 >> 2) & 0x0f;
+			m88ds3103_writereg(state, 0xfe, val);
+
+			val = (u8)((tmp2 & 0x03) << 6);	
+			val |= tmp1;
+			m88ds3103_writereg(state, 0xea, val);
+		}
+	} else {
+		mod_fac = 2;
+
+		switch(code_rate) {
+			case 4:	input_datarate = locked_sym_rate_KSs*mod_fac/2/8;	break;
+			case 3:	input_datarate = locked_sym_rate_KSs*mod_fac*2/3/8;	break;
+			case 2:	input_datarate = locked_sym_rate_KSs*mod_fac*3/4/8;	break;
+			case 1:	input_datarate = locked_sym_rate_KSs*mod_fac*5/6/8;	break;
+			case 0:	input_datarate = locked_sym_rate_KSs*mod_fac*7/8/8;	break;
+			default: input_datarate = locked_sym_rate_KSs*mod_fac*3/4/8;	break;
+		}
+
+		if(state->demod_id == DS3000_ID)
+			input_datarate = input_datarate * 115 / 100;
+
+		if(input_datarate < 6857)		{tmp1 = 7;tmp2 = 7;} //6.857MHz     TS clock
+		else if(input_datarate < 7384)	{tmp1 = 6;tmp2 = 7;} //7.384MHz     TS clock
+		else if(input_datarate < 8000)	{tmp1 = 6;tmp2 = 6;} //8MHz     	TS clock
+		else if(input_datarate < 8727)	{tmp1 = 5;tmp2 = 6;} //8.727MHz 	TS clock
+		else if(input_datarate < 9600)	{tmp1 = 5;tmp2 = 5;} //9.6MHz    	TS clock
+		else if(input_datarate < 10666)	{tmp1 = 4;tmp2 = 5;} //10.666MHz 	TS clock
+		else if(input_datarate < 12000)	{tmp1 = 4;tmp2 = 4;} //12MHz 	 	TS clock
+		else if(input_datarate < 13714)	{tmp1 = 3;tmp2 = 4;} //13.714MHz 	TS clock
+		else if(input_datarate < 16000)	{tmp1 = 3;tmp2 = 3;} //16MHz     	TS clock
+		else if(input_datarate < 19200)	{tmp1 = 2;tmp2 = 3;} //19.2MHz   	TS clock
+		else 							{tmp1 = 2;tmp2 = 2;} //24MHz     	TS clock
+
+		if(state->demod_id == DS3000_ID) {
+			val = m88ds3103_readreg(state, 0xfe);
+			val &= 0xc0;
+			val |= ((u8)((tmp1<<3) + tmp2));
+			m88ds3103_writereg(state, 0xfe, val);
+		} else {
+			if(input_datarate < 5200) /*Max. 2011-12-23 11:55*/
+				input_datarate = 5200;
+			
+			if(input_datarate != 0)
+				divid_ratio = (u8)(MClk_KHz / input_datarate);
+			else
+				divid_ratio = 0xFF;
+
+			if(divid_ratio > 128)
+				divid_ratio = 128;
+
+			if(divid_ratio < 2)
+				divid_ratio = 2;
+
+			tmp1 = (u8)(divid_ratio / 2);
+			tmp2 = (u8)(divid_ratio / 2);
+
+			if((divid_ratio % 2) != 0)
+				tmp2 += 1;
+
+			tmp1 -= 1;
+			tmp2 -= 1;
+
+			tmp1 &= 0x3f;
+			tmp2 &= 0x3f;
+
+			val = m88ds3103_readreg(state, 0xfe);
+			val &= 0xF0;
+			val |= (tmp2 >> 2) & 0x0f;
+			m88ds3103_writereg(state, 0xfe, val);
+			
+			val = (u8)((tmp2 & 0x03) << 6);
+			val |= tmp1;
+			m88ds3103_writereg(state, 0xea, val);
+		}
+	}
+	return 0;
+}
+
+static int m88ds3103_demod_connect(struct dvb_frontend *fe, s32 carrier_offset_khz) 
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u16 value;
+	u8 val1,val2,data;
+	
+	dprintk("connect delivery system = %d\n", state->delivery_system);
+	
+	/* ds3000 global reset */
+	m88ds3103_writereg(state, 0x07, 0x80);
+	m88ds3103_writereg(state, 0x07, 0x00);
+	/* ds3000 build-in uC reset */
+	m88ds3103_writereg(state, 0xb2, 0x01);
+	/* ds3000 software reset */
+	m88ds3103_writereg(state, 0x00, 0x01);
+
+	switch (state->delivery_system) {
+	case SYS_DVBS:
+		/* initialise the demod in DVB-S mode */
+		if(state->demod_id == DS3000_ID){
+			m88ds3103_init_reg(state, ds3000_dvbs_init_tab, sizeof(ds3000_dvbs_init_tab));
+			
+			value = m88ds3103_readreg(state, 0xfe);
+			value &= 0xc0;
+			value |= 0x1b;
+			m88ds3103_writereg(state, 0xfe, value);
+			
+			if(state->config->ci_mode)
+				val1 = 0x80;
+			else if(state->config->ts_mode)
+				val1 = 0x60;
+			else
+				val1 = 0x20;
+			m88ds3103_writereg(state, 0xfd, val1);
+			
+		}else if(state->demod_id == DS3103_ID){
+			m88ds3103_init_reg(state, ds3103_dvbs_init_tab, sizeof(ds3103_dvbs_init_tab));
+			
+			/* set ts clock */
+			if(state->config->ci_mode == 2){
+				val1 = 6; val2 = 6;
+			}else if(state->config->ts_mode == 0)	{
+				val1 = 3; val2 = 3;
+			}else{
+				val1 = 0; val2 = 0;
+			}
+			val1 -= 1; val2 -= 1;
+			val1 &= 0x3f; val2 &= 0x3f;
+			data = m88ds3103_readreg(state, 0xfe);
+			data &= 0xf0;
+			data |= (val2 >> 2) & 0x0f;
+			m88ds3103_writereg(state, 0xfe, data);
+			data = (val2 & 0x03) << 6;
+			data |= val1;
+			m88ds3103_writereg(state, 0xea, data);
+			
+			m88ds3103_writereg(state, 0x4d, 0xfd & m88ds3103_readreg(state, 0x4d));
+			m88ds3103_writereg(state, 0x30, 0xef & m88ds3103_readreg(state, 0x30));
+			
+			/* set master clock */
+			val1 = m88ds3103_readreg(state, 0x22);
+			val2 = m88ds3103_readreg(state, 0x24);
+			
+			val1 &= 0x3f;
+			val2 &= 0x3f;
+			val1 |= 0x80;
+			val2 |= 0x40;
+
+			m88ds3103_writereg(state, 0x22, val1);
+			m88ds3103_writereg(state, 0x24, val2);	
+			
+			if(state->config->ci_mode)
+				val1 = 0x03;
+			else if(state->config->ts_mode)
+				val1 = 0x06;
+			else
+				val1 = 0x42;
+			m88ds3103_writereg(state, 0xfd, val1);		
+		}
+		break;
+	case SYS_DVBS2:
+		/* initialise the demod in DVB-S2 mode */
+		if(state->demod_id == DS3000_ID){
+			m88ds3103_init_reg(state, ds3000_dvbs2_init_tab, sizeof(ds3000_dvbs2_init_tab));
+		
+			if (c->symbol_rate >= 30000000)
+				m88ds3103_writereg(state, 0xfe, 0x54);
+			else
+				m88ds3103_writereg(state, 0xfe, 0x98);
+								
+		}else if(state->demod_id == DS3103_ID){
+			m88ds3103_init_reg(state, ds3103_dvbs2_init_tab, sizeof(ds3103_dvbs2_init_tab));
+
+			/* set ts clock */
+			if(state->config->ci_mode == 2){
+				val1 = 6; val2 = 6;
+			}else if(state->config->ts_mode == 0){
+				val1 = 5; val2 = 4;
+			}else{
+				val1 = 0; val2 = 0;
+			}
+			val1 -= 1; val2 -= 1;
+			val1 &= 0x3f; val2 &= 0x3f;
+			data = m88ds3103_readreg(state, 0xfe);
+			data &= 0xf0;
+			data |= (val2 >> 2) & 0x0f;
+			m88ds3103_writereg(state, 0xfe, data);
+			data = (val2 & 0x03) << 6;
+			data |= val1;
+			m88ds3103_writereg(state, 0xea, data);
+			
+			m88ds3103_writereg(state, 0x4d, 0xfd & m88ds3103_readreg(state, 0x4d));
+			m88ds3103_writereg(state, 0x30, 0xef & m88ds3103_readreg(state, 0x30));
+			
+			/* set master clock */
+			val1 = m88ds3103_readreg(state, 0x22);
+			val2 = m88ds3103_readreg(state, 0x24);
+			
+			val1 &= 0x3f;
+			val2 &= 0x3f;
+			if((state->config->ci_mode == 2) || (state->config->ts_mode == 1)){
+				val1 |= 0x80;
+				val2 |= 0x40;
+			}else{
+				if (c->symbol_rate >= 28000000){
+					val1 |= 0xc0;
+				}else if (c->symbol_rate >= 18000000){
+					val2 |= 0x40;
+				}else{
+					val1 |= 0x80;
+					val2 |= 0x40;
+				}				
+			}
+			m88ds3103_writereg(state, 0x22, val1);
+			m88ds3103_writereg(state, 0x24, val2);					
+		}
+		
+		if(state->config->ci_mode)
+			val1 = 0x03;
+		else if(state->config->ts_mode)
+			val1 = 0x06;
+		else
+			val1 = 0x42;
+		m88ds3103_writereg(state, 0xfd, val1);
+		
+		break;
+	default:
+		return 1;
+	}
+	/* disable 27MHz clock output */
+	m88ds3103_writereg(state, 0x29, 0x80);
+	/* enable ac coupling */
+	m88ds3103_writereg(state, 0x25, 0x8a);
+
+	if ((c->symbol_rate / 1000) <= 3000){
+		m88ds3103_writereg(state, 0xc3, 0x08); /* 8 * 32 * 100 / 64 = 400*/
+		m88ds3103_writereg(state, 0xc8, 0x20);
+		m88ds3103_writereg(state, 0xc4, 0x08); /* 8 * 0 * 100 / 128 = 0*/
+		m88ds3103_writereg(state, 0xc7, 0x00);
+	}else if((c->symbol_rate / 1000) <= 10000){
+		m88ds3103_writereg(state, 0xc3, 0x08); /* 8 * 16 * 100 / 64 = 200*/
+		m88ds3103_writereg(state, 0xc8, 0x10);
+		m88ds3103_writereg(state, 0xc4, 0x08); /* 8 * 0 * 100 / 128 = 0*/
+		m88ds3103_writereg(state, 0xc7, 0x00);
+	}else{
+		m88ds3103_writereg(state, 0xc3, 0x08); /* 8 * 6 * 100 / 64 = 75*/
+		m88ds3103_writereg(state, 0xc8, 0x06);
+		m88ds3103_writereg(state, 0xc4, 0x08); /* 8 * 0 * 100 / 128 = 0*/
+		m88ds3103_writereg(state, 0xc7, 0x00);
+	}
+
+	m88ds3103_set_symrate(fe);
+	
+	m88ds3103_set_CCI(fe);
+
+	m88ds3103_set_carrier_offset(fe, carrier_offset_khz);
+		
+	/* ds3000 out of software reset */
+	m88ds3103_writereg(state, 0x00, 0x00);
+	/* start ds3000 build-in uC */
+	m88ds3103_writereg(state, 0xb2, 0x00);	
+	
+	return 0;
+}
+
+static int m88ds3103_set_frontend(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+
+	int i;
+	fe_status_t status;
+	u8 lpf_mxdiv, mlpf_max, mlpf_min, nlpf, div4, capCode, changePLL;
+	s32 offset_khz, lpf_offset_KHz;
+	u16 value, ndiv, lpf_coeff;
+	u32 f3db, gdiv28, realFreq;
+	u8 RFgain;
+
+	dprintk("%s() ", __func__);
+	dprintk("c frequency = %d\n", c->frequency);
+	dprintk("symbol rate = %d\n", c->symbol_rate);
+	dprintk("delivery system = %d\n", c->delivery_system);
+	
+	realFreq = c->frequency;
+	lpf_offset_KHz = 0;
+	if(c->symbol_rate < 5000000){
+		lpf_offset_KHz = FREQ_OFFSET_AT_SMALL_SYM_RATE_KHz;
+		realFreq += FREQ_OFFSET_AT_SMALL_SYM_RATE_KHz;
+	}
+	
+	if (state->config->set_ts_params)
+		state->config->set_ts_params(fe, 0);
+
+	div4 = 0;
+	RFgain = 0;
+	if(state->tuner_id == TS2022_ID){
+		m88ds3103_tuner_writereg(state, 0x10, 0x0a);
+		m88ds3103_tuner_writereg(state, 0x11, 0x40);
+		if (realFreq < 1103000) {
+			m88ds3103_tuner_writereg(state, 0x10, 0x1b);
+			div4 = 1;
+			ndiv = (realFreq * (6 + 8) * 4)/MT_FE_CRYSTAL_KHZ;				
+		}else {
+			ndiv = (realFreq * (6 + 8) * 2)/MT_FE_CRYSTAL_KHZ;
+		}
+		ndiv = ndiv + ndiv%2;
+		if(ndiv < 4095)
+			ndiv = ndiv - 1024;
+		else if (ndiv < 6143)
+			ndiv = ndiv + 1024;
+		else
+			ndiv = ndiv + 3072;	
+		
+		m88ds3103_tuner_writereg(state, 0x01, (ndiv & 0x3f00) >> 8);											
+	}else{
+		m88ds3103_tuner_writereg(state, 0x10, 0x00);			
+		if (realFreq < 1146000){
+			m88ds3103_tuner_writereg(state, 0x10, 0x11);
+			div4 = 1;
+			ndiv = (realFreq * (6 + 8) * 4) / MT_FE_CRYSTAL_KHZ;
+		}else{
+			m88ds3103_tuner_writereg(state, 0x10, 0x01);
+			ndiv = (realFreq * (6 + 8) * 2) / MT_FE_CRYSTAL_KHZ;
+		}
+		ndiv = ndiv + ndiv%2;
+		ndiv = ndiv - 1024;
+		m88ds3103_tuner_writereg(state, 0x01, (ndiv>>8)&0x0f);
+	}
+	/* set pll */
+	m88ds3103_tuner_writereg(state, 0x02, ndiv & 0x00ff);
+	m88ds3103_tuner_writereg(state, 0x03, 0x06);
+	m88ds3103_tuner_writereg(state, 0x51, 0x0f);
+	m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+	m88ds3103_tuner_writereg(state, 0x50, 0x10);
+	m88ds3103_tuner_writereg(state, 0x50, 0x00);	
+
+	if(state->tuner_id == TS2022_ID){
+		if(( realFreq >= 1650000 ) && (realFreq <= 1850000)){
+			msleep(5);
+			value = m88ds3103_tuner_readreg(state, 0x14);
+			value &= 0x7f;
+			if(value < 64){
+				m88ds3103_tuner_writereg(state, 0x10, 0x82);
+				m88ds3103_tuner_writereg(state, 0x11, 0x6f);
+
+				m88ds3103_tuner_writereg(state, 0x51, 0x0f);
+				m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+				m88ds3103_tuner_writereg(state, 0x50, 0x10);
+				m88ds3103_tuner_writereg(state, 0x50, 0x00);
+			}
+		}
+		msleep(5);
+		value = m88ds3103_tuner_readreg(state, 0x14);
+		value &= 0x1f;
+
+		if(value > 19){
+			value = m88ds3103_tuner_readreg(state, 0x10);
+			value &= 0x1d;
+			m88ds3103_tuner_writereg(state, 0x10, value);
+		}				
+	}else{
+		msleep(5);
+		value = m88ds3103_tuner_readreg(state, 0x66);
+		changePLL = (((value & 0x80) >> 7) != div4);
+
+		if(changePLL){
+			m88ds3103_tuner_writereg(state, 0x10, 0x11);
+			div4 = 1;
+			ndiv = (realFreq * (6 + 8) * 4)/MT_FE_CRYSTAL_KHZ;
+			ndiv = ndiv + ndiv%2;
+			ndiv = ndiv - 1024;
+					
+			m88ds3103_tuner_writereg(state, 0x01, (ndiv>>8) & 0x0f);
+			m88ds3103_tuner_writereg(state, 0x02, ndiv & 0xff);
+			
+			m88ds3103_tuner_writereg(state, 0x51, 0x0f);
+			m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+			m88ds3103_tuner_writereg(state, 0x50, 0x10);
+			m88ds3103_tuner_writereg(state, 0x50, 0x00);
+		}		
+	}
+	/*set the RF gain*/
+	if(state->tuner_id == TS2020_ID)
+		m88ds3103_tuner_writereg(state, 0x60, 0x79);
+			
+	m88ds3103_tuner_writereg(state, 0x51, 0x17);
+	m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+	m88ds3103_tuner_writereg(state, 0x50, 0x08);
+	m88ds3103_tuner_writereg(state, 0x50, 0x00);
+	msleep(5);
+
+	if(state->tuner_id == TS2020_ID){
+		RFgain = m88ds3103_tuner_readreg(state, 0x3d);
+		RFgain &= 0x0f;
+		if(RFgain < 15){
+			if(RFgain < 4) 
+				RFgain = 0;
+			else
+				RFgain = RFgain -3;
+			value = ((RFgain << 3) | 0x01) & 0x79;
+			m88ds3103_tuner_writereg(state, 0x60, value);
+			m88ds3103_tuner_writereg(state, 0x51, 0x17);
+			m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+			m88ds3103_tuner_writereg(state, 0x50, 0x08);
+			m88ds3103_tuner_writereg(state, 0x50, 0x00);
+		}
+	}
+	
+	/* set the LPF */
+	if(state->tuner_id == TS2022_ID){
+		m88ds3103_tuner_writereg(state, 0x25, 0x00);
+		m88ds3103_tuner_writereg(state, 0x27, 0x70);
+		m88ds3103_tuner_writereg(state, 0x41, 0x09);
+		m88ds3103_tuner_writereg(state, 0x08, 0x0b);
+	}
+
+	f3db = ((c->symbol_rate / 1000) *135) / 200 + 2000;
+	f3db += lpf_offset_KHz;
+	if (f3db < 7000)
+		f3db = 7000;
+	if (f3db > 40000)
+		f3db = 40000;
+			
+	gdiv28 = (MT_FE_CRYSTAL_KHZ / 1000 * 1694 + 500) / 1000;
+	m88ds3103_tuner_writereg(state, 0x04, gdiv28 & 0xff);
+	m88ds3103_tuner_writereg(state, 0x51, 0x1b);
+	m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+	m88ds3103_tuner_writereg(state, 0x50, 0x04);
+	m88ds3103_tuner_writereg(state, 0x50, 0x00);
+	msleep(5);
+
+	value = m88ds3103_tuner_readreg(state, 0x26);
+	capCode = value & 0x3f;
+	if(state->tuner_id == TS2022_ID){
+		m88ds3103_tuner_writereg(state, 0x41, 0x0d);
+
+		m88ds3103_tuner_writereg(state, 0x51, 0x1b);
+		m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+		m88ds3103_tuner_writereg(state, 0x50, 0x04);
+		m88ds3103_tuner_writereg(state, 0x50, 0x00);
+
+		msleep(2);
+
+		value = m88ds3103_tuner_readreg(state, 0x26);
+		value &= 0x3f;
+		value = (capCode + value) / 2;		
+	}
+	else
+		value = capCode;
+		
+	gdiv28 = gdiv28 * 207 / (value * 2 + 151);	
+	mlpf_max = gdiv28 * 135 / 100;
+	mlpf_min = gdiv28 * 78 / 100;
+	if (mlpf_max > 63)
+		mlpf_max = 63;
+
+	if(state->tuner_id == TS2022_ID)
+		lpf_coeff = 3200;
+	else
+		lpf_coeff = 2766;
+		
+	nlpf = (f3db * gdiv28 * 2 / lpf_coeff / (MT_FE_CRYSTAL_KHZ / 1000)  + 1) / 2 ;	
+	if (nlpf > 23) nlpf = 23;
+	if (nlpf < 1) nlpf = 1;
+
+	lpf_mxdiv = (nlpf * (MT_FE_CRYSTAL_KHZ / 1000) * lpf_coeff * 2 / f3db + 1) / 2;
+
+	if (lpf_mxdiv < mlpf_min){
+		nlpf++;
+		lpf_mxdiv = (nlpf * (MT_FE_CRYSTAL_KHZ / 1000) * lpf_coeff * 2  / f3db + 1) / 2;
+	}
+
+	if (lpf_mxdiv > mlpf_max)
+		lpf_mxdiv = mlpf_max;
+
+	m88ds3103_tuner_writereg(state, 0x04, lpf_mxdiv);
+	m88ds3103_tuner_writereg(state, 0x06, nlpf);
+	m88ds3103_tuner_writereg(state, 0x51, 0x1b);
+	m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+	m88ds3103_tuner_writereg(state, 0x50, 0x04);
+	m88ds3103_tuner_writereg(state, 0x50, 0x00);
+	msleep(5);
+	
+	if(state->tuner_id == TS2022_ID){
+		msleep(2);
+		value = m88ds3103_tuner_readreg(state, 0x26);
+		capCode = value & 0x3f;
+
+		m88ds3103_tuner_writereg(state, 0x41, 0x09);
+
+		m88ds3103_tuner_writereg(state, 0x51, 0x1b);
+		m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+		m88ds3103_tuner_writereg(state, 0x50, 0x04);
+		m88ds3103_tuner_writereg(state, 0x50, 0x00);
+
+		msleep(2);
+		value = m88ds3103_tuner_readreg(state, 0x26);
+		value &= 0x3f;
+		value = (capCode + value) / 2;
+
+		value = value | 0x80;
+		m88ds3103_tuner_writereg(state, 0x25, value);
+		m88ds3103_tuner_writereg(state, 0x27, 0x30);
+
+		m88ds3103_tuner_writereg(state, 0x08, 0x09);		
+	}
+
+	/* Set the BB gain */
+	m88ds3103_tuner_writereg(state, 0x51, 0x1e);
+	m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+	m88ds3103_tuner_writereg(state, 0x50, 0x01);
+	m88ds3103_tuner_writereg(state, 0x50, 0x00);
+	if(state->tuner_id == TS2020_ID){
+		if(RFgain == 15){
+			msleep(40);
+			value = m88ds3103_tuner_readreg(state, 0x21);
+			value &= 0x0f;
+			if(value < 3){
+				m88ds3103_tuner_writereg(state, 0x60, 0x61);
+				m88ds3103_tuner_writereg(state, 0x51, 0x17);
+				m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+				m88ds3103_tuner_writereg(state, 0x50, 0x08);
+				m88ds3103_tuner_writereg(state, 0x50, 0x00);
+			}			
+		}
+	}
+	msleep(60);
+	
+	offset_khz = (ndiv - ndiv % 2 + 1024) * MT_FE_CRYSTAL_KHZ
+		/ (6 + 8) / (div4 + 1) / 2 - realFreq;
+
+	m88ds3103_demod_connect(fe, offset_khz+lpf_offset_KHz);
+
+	for (i = 0; i < 30 ; i++) {
+		m88ds3103_read_status(fe, &status);
+		if (status & FE_HAS_LOCK){
+			break;
+                }
+		msleep(20);
+	}
+	
+	if((status & FE_HAS_LOCK) == 0){
+		state->delivery_system = (state->delivery_system == SYS_DVBS) ? SYS_DVBS2 : SYS_DVBS;
+		m88ds3103_demod_connect(fe, offset_khz);
+	
+		for (i = 0; i < 30 ; i++) {
+			m88ds3103_read_status(fe, &status);
+			if (status & FE_HAS_LOCK){
+				break;
+                	}
+			msleep(20);
+		}
+	}
+	
+	if (status & FE_HAS_LOCK){
+		if(state->config->ci_mode == 2)
+			m88ds3103_set_clock_ratio(state);
+		if(state->config->start_ctrl){
+			if(state->first_lock == 0){
+				state->config->start_ctrl(fe);
+				state->first_lock = 1;	
+			}
+		}		
+	}
+		
+	return 0;
+}
+
+static int m88ds3103_tune(struct dvb_frontend *fe,
+			bool re_tune,
+			unsigned int mode_flags,
+			unsigned int *delay,
+			fe_status_t *status)
+{	
+	*delay = HZ / 5;
+	
+	dprintk("%s() ", __func__);
+	dprintk("re_tune = %d\n", re_tune);
+	
+	if (re_tune) {
+		int ret = m88ds3103_set_frontend(fe);
+		if (ret)
+			return ret;
+	}
+	
+	return m88ds3103_read_status(fe, status);
+}
+
+static enum dvbfe_algo m88ds3103_get_algo(struct dvb_frontend *fe)
+{
+	return DVBFE_ALGO_HW;
+}
+ 
+ /*
+ * Power config will reset and load initial firmware if required
+ */
+static int m88ds3103_initilaze(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	int ret;
+
+	dprintk("%s()\n", __func__);
+	/* hard reset */
+	m88ds3103_writereg(state, 0x07, 0x80);
+	m88ds3103_writereg(state, 0x07, 0x00);
+	msleep(1);
+	
+	m88ds3103_writereg(state, 0x08, 0x01 | m88ds3103_readreg(state, 0x08));
+	msleep(1);
+
+	if(state->tuner_id == TS2020_ID){
+		/* TS2020 init */
+		m88ds3103_tuner_writereg(state, 0x42, 0x73);
+		msleep(2);
+		m88ds3103_tuner_writereg(state, 0x05, 0x01);
+		m88ds3103_tuner_writereg(state, 0x62, 0xb5);
+		m88ds3103_tuner_writereg(state, 0x07, 0x02);
+		m88ds3103_tuner_writereg(state, 0x08, 0x01);
+	}
+	else if(state->tuner_id == TS2022_ID){
+		/* TS2022 init */
+		m88ds3103_tuner_writereg(state, 0x62, 0x6c);
+		msleep(2);
+		m88ds3103_tuner_writereg(state, 0x42, 0x6c);
+		msleep(2);
+		m88ds3103_tuner_writereg(state, 0x7d, 0x9d);
+		m88ds3103_tuner_writereg(state, 0x7c, 0x9a);
+		m88ds3103_tuner_writereg(state, 0x7a, 0x76);
+
+		m88ds3103_tuner_writereg(state, 0x3b, 0x01);
+		m88ds3103_tuner_writereg(state, 0x63, 0x88);
+
+		m88ds3103_tuner_writereg(state, 0x61, 0x85);
+		m88ds3103_tuner_writereg(state, 0x22, 0x30);
+		m88ds3103_tuner_writereg(state, 0x30, 0x40);
+		m88ds3103_tuner_writereg(state, 0x20, 0x23);
+		m88ds3103_tuner_writereg(state, 0x24, 0x02);
+		m88ds3103_tuner_writereg(state, 0x12, 0xa0);	
+	}
+		
+	if(state->demod_id == DS3103_ID){
+		m88ds3103_writereg(state, 0x07, 0xe0);
+		m88ds3103_writereg(state, 0x07, 0x00);
+		msleep(1);		
+	}
+	m88ds3103_writereg(state, 0xb2, 0x01);
+	
+	/* Load the firmware if required */
+	ret = m88ds3103_load_firmware(fe);
+	if (ret != 0){
+		printk(KERN_ERR "%s: Unable initialize firmware\n", __func__);
+		return ret;
+	}
+	if(state->demod_id == DS3103_ID){
+		m88ds3103_writereg(state, 0x4d, 0xfd & m88ds3103_readreg(state, 0x4d));
+		m88ds3103_writereg(state, 0x30, 0xef & m88ds3103_readreg(state, 0x30));		
+	}
+
+	return 0;
+}
+
+/*
+ * Initialise or wake up device
+ */
+static int m88ds3103_initfe(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8 val;
+
+	dprintk("%s()\n", __func__);
+
+	/* 1st step to wake up demod */
+	m88ds3103_writereg(state, 0x08, 0x01 | m88ds3103_readreg(state, 0x08));
+	m88ds3103_writereg(state, 0x04, 0xfe & m88ds3103_readreg(state, 0x04));
+	m88ds3103_writereg(state, 0x23, 0xef & m88ds3103_readreg(state, 0x23));
+	
+	/* 2nd step to wake up tuner */
+	val = m88ds3103_tuner_readreg(state, 0x00) & 0xff;
+	if((val & 0x01) == 0){
+		m88ds3103_tuner_writereg(state, 0x00, 0x01);
+		msleep(50);
+	}
+	m88ds3103_tuner_writereg(state, 0x00, 0x03);
+	msleep(50);
+	
+	return 0;	
+}
+
+/* Put device to sleep */
+static int m88ds3103_sleep(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+
+	dprintk("%s()\n", __func__);
+	
+	/* 1st step to sleep tuner */
+	m88ds3103_tuner_writereg(state, 0x00, 0x00);
+	
+	/* 2nd step to sleep demod */
+	m88ds3103_writereg(state, 0x08, 0xfe & m88ds3103_readreg(state, 0x08));
+	m88ds3103_writereg(state, 0x04, 0x01 | m88ds3103_readreg(state, 0x04));
+	m88ds3103_writereg(state, 0x23, 0x10 | m88ds3103_readreg(state, 0x23));
+	
+
+	return 0;
+}
+
+static struct dvb_frontend_ops m88ds3103_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2},
+	.info = {
+		.name = "Montage DS3103/TS2022",
+		.type = FE_QPSK,
+		.frequency_min = 950000,
+		.frequency_max = 2150000,
+		.frequency_stepsize = 1011, /* kHz for QPSK frontends */
+		.frequency_tolerance = 5000,
+		.symbol_rate_min = 1000000,
+		.symbol_rate_max = 45000000,
+		.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
+			FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_2G_MODULATION |
+			FE_CAN_QPSK | FE_CAN_RECOVER
+	},
+
+	.release = m88ds3103_release,
+
+	.init = m88ds3103_initfe,
+	.sleep = m88ds3103_sleep,
+	.read_status = m88ds3103_read_status,
+	.read_ber = m88ds3103_read_ber,
+	.read_signal_strength = m88ds3103_read_signal_strength,
+	.read_snr = m88ds3103_read_snr,
+	.read_ucblocks = m88ds3103_read_ucblocks,
+	.set_tone = m88ds3103_set_tone,
+	.set_voltage = m88ds3103_set_voltage,
+	.diseqc_send_master_cmd = m88ds3103_send_diseqc_msg,
+	.diseqc_send_burst = m88ds3103_diseqc_send_burst,
+	.get_frontend_algo = m88ds3103_get_algo,
+	.tune = m88ds3103_tune,
+	.set_frontend = m88ds3103_set_frontend,
+};
+
+MODULE_DESCRIPTION("DVB Frontend module for Montage DS3103/TS2022 hardware");
+MODULE_AUTHOR("Max nibble");
+MODULE_LICENSE("GPL");
diff -urN a/drivers/media/dvb-frontends/m88ds3103.h b/drivers/media/dvb-frontends/m88ds3103.h
--- a/drivers/media/dvb-frontends/m88ds3103.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/m88ds3103.h	2013-01-30 12:33:51.000000000 +0800
@@ -0,0 +1,53 @@
+/*
+    Montage Technology M88DS3103/M88TS2022 - DVBS/S2 Satellite demod/tuner driver
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef M88DS3103_H
+#define M88DS3103_H
+
+#include <linux/dvb/frontend.h>
+
+struct m88ds3103_config {
+	/* the demodulator's i2c address */
+	u8 demod_address;
+	u8 ci_mode;
+	u8 pin_ctrl;
+	u8 ts_mode; /* 0: Parallel, 1: Serial */
+
+	/* Set device param to start dma */
+	int (*set_ts_params)(struct dvb_frontend *fe, int is_punctured);
+    /* Start to transfer data */
+    int (*start_ctrl)(struct dvb_frontend *fe);
+    /* Set LNB voltage */
+    int (*set_voltage)(struct dvb_frontend* fe, fe_sec_voltage_t voltage);
+};
+
+#if defined(CONFIG_DVB_M88DS3103) || \
+	(defined(CONFIG_DVB_M88DS3103_MODULE) && defined(MODULE))
+extern struct dvb_frontend *m88ds3103_attach(
+       const struct m88ds3103_config *config,
+       struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *m88ds3103_attach(
+       const struct m88ds3103_config *config,
+       struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif /* CONFIG_DVB_M88DS3103 */
+#endif /* M88DS3103_H */
diff -urN a/drivers/media/dvb-frontends/m88ds3103_priv.h b/drivers/media/dvb-frontends/m88ds3103_priv.h
--- a/drivers/media/dvb-frontends/m88ds3103_priv.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/m88ds3103_priv.h	2013-01-30 12:33:56.000000000 +0800
@@ -0,0 +1,403 @@
+/*
+    Montage Technology M88DS3103/M88TS2022 - DVBS/S2 Satellite demod/tuner driver
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef M88DS3103_PRIV_H
+#define M88DS3103_PRIV_H
+
+#define FW_DOWN_SIZE 32
+#define FW_DOWN_LOOP (8192/FW_DOWN_SIZE)
+#define DS3103_DEFAULT_FIRMWARE "dvb-fe-ds3103.fw"
+#define DS3000_DEFAULT_FIRMWARE "dvb-fe-ds300x.fw"
+#define MT_FE_MCLK_KHZ 96000 /* in kHz */
+#define MT_FE_CRYSTAL_KHZ   27000 /* in kHz */
+#define FREQ_OFFSET_AT_SMALL_SYM_RATE_KHz 3000
+#define DS3000_ID	0x3000
+#define DS3103_ID	0x3103
+#define TS2020_ID	0x2020
+#define TS2022_ID	0x2022
+#define UNKNOW_ID	0x0000
+
+struct m88ds3103_state {
+	struct i2c_adapter *i2c;
+	const struct m88ds3103_config *config;
+	
+	struct dvb_frontend frontend;
+	
+	u32 preBer;
+	u8 skip_fw_load;	
+	u8 first_lock; /* The first time of signal lock */
+	u16 demod_id; /* demod chip type */
+	u16 tuner_id; /* tuner chip type */
+	fe_delivery_system_t delivery_system;
+};
+
+/* For M88DS3103 demod dvbs mode.*/
+static u8 ds3103_dvbs_init_tab[] = {
+	0x23, 0x07,
+	0x08, 0x03,
+	0x0c, 0x02,
+	0x21, 0x54,
+	0x25, 0x82,
+	0x27, 0x31,
+	0x30, 0x08,
+	0x31, 0x40,
+	0x32, 0x32,
+	0x33, 0x35,
+	0x35, 0xff,
+	0x3a, 0x00,
+	0x37, 0x10,
+	0x38, 0x10,
+	0x39, 0x02,
+	0x42, 0x60,
+	0x4a, 0x80,
+	0x4b, 0x04,
+	0x4d, 0x91,
+	0x5d, 0xc8,
+	0x50, 0x36,
+	0x51, 0x36,
+	0x52, 0x36,
+	0x53, 0x36,
+	0x63, 0x0f,
+	0x64, 0x30,
+	0x65, 0x40,
+	0x68, 0x26,
+	0x69, 0x4c,
+	0x70, 0x20,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x40,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x60,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x80,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0xa0,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x1f,
+	0x76, 0x38,
+	0x77, 0xa6,
+	0x78, 0x0c,
+	0x79, 0x80,
+	0x7f, 0x14,
+	0x7c, 0x00,
+	0xae, 0x82,
+	0x80, 0x64,
+	0x81, 0x66,
+	0x82, 0x44,
+	0x85, 0x04,
+	0xcd, 0xf4,
+	0x90, 0x33,
+	0xa0, 0x44,
+	0xc0, 0x08,
+	0xc3, 0x10,
+	0xc4, 0x08,
+	0xc5, 0xf0,
+	0xc6, 0xff,
+	0xc7, 0x00,
+	0xc8, 0x1a,
+	0xc9, 0x80,
+	0xe0, 0xf8,
+	0xe6, 0x8b,
+	0xd0, 0x40,
+	0xf8, 0x20,
+	0xfa, 0x0f,
+	0x00, 0x00,
+	0xbd, 0x01,
+	0xb8, 0x00,
+};
+/* For M88DS3103 demod dvbs2 mode.*/
+static u8 ds3103_dvbs2_init_tab[] = {
+	0x23, 0x07,
+	0x08, 0x07,
+	0x0c, 0x02,
+	0x21, 0x54,
+	0x25, 0x82,
+	0x27, 0x31,
+	0x30, 0x08,
+	0x32, 0x32,
+	0x33, 0x35,
+	0x35, 0xff,
+	0x3a, 0x00,
+	0x37, 0x10,
+	0x38, 0x10,
+	0x39, 0x02,
+	0x42, 0x60,
+	0x4a, 0x80,
+	0x4b, 0x04,
+	0x4d, 0x91,
+	0x5d, 0xc8,
+	0x50, 0x36,
+	0x51, 0x36,
+	0x52, 0x36,
+	0x53, 0x36,
+	0x63, 0x0f,
+	0x64, 0x10,
+	0x65, 0x20,
+	0x68, 0x46,
+	0x69, 0xcd,
+	0x70, 0x20,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x40,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x60,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x80,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0xa0,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x1f,
+	0x76, 0x38,
+	0x77, 0xa6,
+	0x78, 0x0c,
+	0x79, 0x80,
+	0x7f, 0x14,
+	0x85, 0x08,
+	0xcd, 0xf4,
+	0x90, 0x33,
+	0x86, 0x00,
+	0x87, 0x0f,
+	0x89, 0x00,
+	0x8b, 0x44,
+	0x8c, 0x66,
+	0x9d, 0xc1,
+	0x8a, 0x10,
+	0xad, 0x40,
+	0xa0, 0x44,
+	0xc0, 0x08,
+	0xc1, 0x10,
+	0xc2, 0x08,
+	0xc3, 0x10,
+	0xc4, 0x08,
+	0xc5, 0xf0,
+	0xc6, 0xff,
+	0xc7, 0x00,
+	0xc8, 0x1a,
+	0xc9, 0x80,
+	0xca, 0x23,
+	0xcb, 0x24,
+	0xcc, 0xf4,
+	0xce, 0x74,
+	0x00, 0x00,
+	0xbd, 0x01,
+	0xb8, 0x00,
+};
+
+/* For M88DS3000 demod dvbs mode.*/
+static u8 ds3000_dvbs_init_tab[] = {
+	0x23, 0x05,
+	0x08, 0x03,
+	0x0c, 0x02,
+	0x21, 0x54,
+	0x25, 0x82,
+	0x27, 0x31,
+	0x30, 0x08,
+	0x31, 0x40,
+	0x32, 0x32,
+	0x33, 0x35,
+	0x35, 0xff,
+	0x3a, 0x00,
+	0x37, 0x10,
+	0x38, 0x10,
+	0x39, 0x02,
+	0x42, 0x60,
+	0x4a, 0x40,
+	0x4b, 0x04,
+	0x4d, 0x91,
+	0x5d, 0xc8,
+	0x50, 0x77,
+	0x51, 0x77,
+	0x52, 0x36,
+	0x53, 0x36,
+	0x56, 0x01,
+	0x63, 0x47,
+	0x64, 0x30,
+	0x65, 0x40,
+	0x68, 0x26,
+	0x69, 0x4c,
+	0x70, 0x20,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x40,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x60,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x80,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0xa0,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x1f,
+	0x76, 0x00,
+	0x77, 0xd1,
+	0x78, 0x0c,
+	0x79, 0x80,
+	0x7f, 0x04,
+	0x7c, 0x00,
+	0x80, 0x86,
+	0x81, 0xa6,
+	0x85, 0x04,
+	0xcd, 0xf4,
+	0x90, 0x33,
+	0xa0, 0x44,
+	0xc0, 0x18,
+	0xc3, 0x10,
+	0xc4, 0x08,
+	0xc5, 0x80,
+	0xc6, 0x80,
+	0xc7, 0x0a,
+	0xc8, 0x1a,
+	0xc9, 0x80,
+	0xfe, 0xb6,
+	0xe0, 0xf8,
+	0xe6, 0x8b,
+	0xd0, 0x40,
+	0xf8, 0x20,
+	0xfa, 0x0f,
+	0xad, 0x20,
+	0xae, 0x07,
+	0xb8, 0x00,
+};
+
+/* For M88DS3000 demod dvbs2 mode.*/
+static u8 ds3000_dvbs2_init_tab[] = {
+	0x23, 0x0f,
+	0x08, 0x07,
+	0x0c, 0x02,
+	0x21, 0x54,
+	0x25, 0x82,
+	0x27, 0x31,
+	0x30, 0x08,
+	0x31, 0x32,
+	0x32, 0x32,
+	0x33, 0x35,
+	0x35, 0xff,
+	0x3a, 0x00,
+	0x37, 0x10,
+	0x38, 0x10,
+	0x39, 0x02,
+	0x42, 0x60,
+	0x4a, 0x80,
+	0x4b, 0x04,
+	0x4d, 0x91,
+	0x5d, 0x88,
+	0x50, 0x36,
+	0x51, 0x36,
+	0x52, 0x36,
+	0x53, 0x36,
+	0x63, 0x60,
+	0x64, 0x10,
+	0x65, 0x10,
+	0x68, 0x04,
+	0x69, 0x29,
+	0x70, 0x20,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x40,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x60,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x80,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0xa0,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x1f,
+	0xa0, 0x44,
+	0xc0, 0x08,
+	0xc1, 0x10,
+	0xc2, 0x08,
+	0xc3, 0x10,
+	0xc4, 0x08,
+	0xc5, 0xf0,
+	0xc6, 0xf0,
+	0xc7, 0x0a,
+	0xc8, 0x1a,
+	0xc9, 0x80,
+	0xca, 0x23,
+	0xcb, 0x24,
+	0xce, 0x74,
+	0x56, 0x01,
+	0x90, 0x03,
+	0x76, 0x80,
+	0x77, 0x42,
+	0x78, 0x0a,
+	0x79, 0x80,
+	0xad, 0x40,
+	0xae, 0x07,
+	0x7f, 0xd4,
+	0x7c, 0x00,
+	0x80, 0xa8,
+	0x81, 0xda,
+	0x7c, 0x01,
+	0x80, 0xda,
+	0x81, 0xec,
+	0x7c, 0x02,
+	0x80, 0xca,
+	0x81, 0xeb,
+	0x7c, 0x03,
+	0x80, 0xba,
+	0x81, 0xdb,
+	0x85, 0x08,
+	0x86, 0x00,
+	0x87, 0x02,
+	0x89, 0x80,
+	0x8b, 0x44,
+	0x8c, 0xaa,
+	0x8a, 0x10,
+	0xba, 0x00,
+	0xf5, 0x04,
+	0xd2, 0x32,
+	0xb8, 0x00,
+};
+
+#endif /* M88DS3103_PRIV_H */
diff -urN a/drivers/media/dvb-frontends/Makefile b/drivers/media/dvb-frontends/Makefile
--- a/drivers/media/dvb-frontends/Makefile	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/dvb-frontends/Makefile	2013-05-06 21:24:13.000000000 +0800
@@ -103,4 +103,6 @@
 obj-$(CONFIG_DVB_RTL2832) += rtl2832.o
 obj-$(CONFIG_DVB_M88RS2000) += m88rs2000.o
 obj-$(CONFIG_DVB_AF9033) += af9033.o
-
+obj-$(CONFIG_DVB_M88DS3103) += m88ds3103.o
+obj-$(CONFIG_DVB_M88DC2800) += m88dc2800.o
+obj-$(CONFIG_DVB_SIT2) += sit2.o
diff -urN a/drivers/media/dvb-frontends/sit2.c b/drivers/media/dvb-frontends/sit2.c
--- a/drivers/media/dvb-frontends/sit2.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/sit2.c	2013-05-07 17:13:19.000000000 +0800
@@ -0,0 +1,1294 @@
+/*
+    SIT2  - DVB-T2/T/C demodulator and tuner
+
+    Copyright (C) 2013 Max Nibble <nibble.max@gmail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <asm/div64.h>
+#include "dvb_frontend.h"
+#include "sit2_priv.h"
+#include "sit2.h"
+
+int sit2_debug = 1;
+module_param(sit2_debug, int, 0644);
+MODULE_PARM_DESC(sit2_debug, "Activates frontend debugging (default:0)");
+#define dprintk(args...) \
+	do { \
+		if (sit2_debug) \
+			printk(KERN_INFO "sit2: " args); \
+	} while (0)
+
+/*global state*/
+struct sit2_state {
+	struct dvb_frontend frontend;
+	const struct sit2_config *config;
+	struct i2c_adapter *i2c;
+	
+	bool  isInited;
+	u8 demod_addr;
+	u8 tuner_addr;
+	u8 sndBuffer[64];
+	u8 revBuffer[64];
+	sit2_tuner_reply tuner_reply;
+	sit2_demod_reply demod_reply;
+
+	fe_delivery_system_t current_system;
+	int plp_id;
+	u32 stream;
+	u32 dvbc_symrate;	
+};
+
+static u32 sit2_writebytes(struct sit2_state *state, u32 len, u8 *data, bool isTuner)
+{
+	int ret;
+	u32 uret = 0;
+	struct i2c_msg w_msg = { .flags = 0 };
+	w_msg.addr = (isTuner) ? state->tuner_addr : state->demod_addr;;
+	w_msg.buf = data;
+	w_msg.len = len;
+	ret = i2c_transfer(state->i2c, &w_msg, 1);
+	if(ret != 1) {
+		printk(KERN_INFO
+	     	"%s: error! addr=%x len=%d, ret=%d\n",
+	     	__func__, w_msg.addr, len, ret);
+	}
+	else
+		uret = len;		
+	return uret;
+}
+
+static u32 sit2_readbytes(struct sit2_state *state, u32 len, u8 *data, bool isTuner)
+{
+	int ret;
+	u32 uret = 0;
+	struct i2c_msg r_msg = { .flags = I2C_M_RD };
+	r_msg.addr = (isTuner) ? state->tuner_addr : state->demod_addr;
+	r_msg.len = len;
+	r_msg.buf = data;
+	ret = i2c_transfer(state->i2c, &r_msg, 1);
+	if(ret != 1) {
+		printk(KERN_INFO
+	     	"%s: error! addr=%x len=%d, ret=%d\n",
+	     	__func__, r_msg.addr, len, ret);
+	}
+	else
+		uret = len;		
+	return uret;
+}
+
+static u8 sit2_tuner_ResponseStatus(struct sit2_state *state, u8 Data)
+{
+    	state->tuner_reply.tunint = (Data & 0x01) ? 1 : 0;
+    	state->tuner_reply.atvint = (Data & 0x02) ? 1 : 0;
+    	state->tuner_reply.dtvint = (Data & 0x04) ? 1 : 0;
+    	state->tuner_reply.err    = (Data & 0x40) ? 1 : 0;
+    	state->tuner_reply.cts    = (Data & 0x80) ? 1 : 0;
+  	return (state->tuner_reply.err ? SIT2_ERROR_ERR : SIT2_ERROR_OK);
+}
+
+static u8 sit2_demod_ResponseStatus(struct sit2_state *state, u8 Data)
+{
+	state->demod_reply.ddint   = (Data & 0x01) ? 1 : 0;
+	state->demod_reply.scanint = (Data & 0x02) ? 1 : 0;
+	state->demod_reply.err     = (Data & 0x40) ? 1 : 0;
+	state->demod_reply.cts     = (Data & 0x80) ? 1 : 0;
+	return (state->demod_reply.err ? SIT2_ERROR_ERR : SIT2_ERROR_OK);
+}
+
+static u8 sit2_pollForResponse(struct sit2_state *state, u32 nbBytes, u8 *pByteBuffer, bool isTuner)
+{
+	u32 ulCount, ulTick, ulDelay;
+	ulCount = 0;
+	ulTick = 50;
+	ulDelay = 1000/ulTick;
+	
+	while(ulCount <= ulTick) {
+		if (sit2_readbytes(state, nbBytes, pByteBuffer, isTuner) != nbBytes) {
+      			dprintk("%s: tuner[%d], readbytes[%d] error!\n", __func__, isTuner, nbBytes);
+      			return SIT2_ERROR_POLLING;
+    		}
+    		/* return response err flag if CTS set */
+    		if (pByteBuffer[0] & 0x80)  {
+    			if (isTuner)
+    				return sit2_tuner_ResponseStatus(state, pByteBuffer[0]);
+    			else
+      				return sit2_demod_ResponseStatus(state, pByteBuffer[0]);
+    		}
+    		msleep(ulDelay);
+    		ulCount++;
+  	}
+
+  	dprintk("%s: tuner[%d], time out error!\n", __func__, isTuner);
+  	return SIT2_ERROR_TIMEOUT;
+}
+
+static u8 sit2_sendCommand(struct sit2_state *state, u32 sndBytes, u32 revBytes, bool isTuner)
+{
+	u8 uret = SIT2_ERROR_OK;
+	if ((sndBytes > 64) || (revBytes > 64)) {
+		printk(KERN_INFO
+	     	"%s: error! sndBytes=%x revBytes=%d\n",
+	     	__func__, sndBytes, revBytes);
+	     	return SIT2_ERROR_PAREMETER;	
+	}
+	
+	if (sit2_writebytes(state, sndBytes, state->sndBuffer, isTuner) != sndBytes) {
+		
+		dprintk("%s: tuner[%d],writebytes[%d] error!\n", __func__, isTuner, sndBytes);
+		return SIT2_ERROR_ERR;
+	}
+	
+	if(revBytes > 0)
+		uret = sit2_pollForResponse(state, revBytes, state->revBuffer, isTuner);
+	return uret;	
+}
+
+static u8 sit2_sendProperty(struct sit2_state *state, u32 prop, u32 data, bool isTuner)
+{
+	state->sndBuffer[0] = 0x14;
+	state->sndBuffer[1] = 0;
+	state->sndBuffer[2] = (u8)(prop & 0xff);
+	state->sndBuffer[3] = (u8)((prop >> 8) & 0xff);
+	state->sndBuffer[4] = (u8)(data & 0xff);
+	state->sndBuffer[5] = (u8)((data >> 8) & 0xff);	
+	return sit2_sendCommand(state, 6, 4, isTuner);
+}
+
+static u8 sit2_startFirmware(struct sit2_state *state, bool isTuner)
+{
+	state->sndBuffer[0] = 0x01;
+	state->sndBuffer[1] = 1;
+	return sit2_sendCommand(state, 2, 1, isTuner);	
+}
+
+static u8 sit2_demod_tuner_i2c_enable(struct sit2_state *state, u8 onOff)
+{
+	dprintk("%s, on=%d\n", __func__, onOff);
+	state->sndBuffer[0] = 0xc0;
+	state->sndBuffer[1] = 13;
+	state->sndBuffer[2] = (onOff > 0) ? 1 : 0;
+	return sit2_sendCommand(state, 3, 0, false);	
+}
+
+static u8 sit2_tuner_xout_enable(struct sit2_state *state, u8 onOff)
+{
+	state->sndBuffer[0] = 0xc0;
+	state->sndBuffer[1] = 0;
+	state->sndBuffer[2] = (onOff > 0) ? (3 << 2) : 0;
+	return sit2_sendCommand(state, 3, 1, true);
+}
+
+static u8 sit2_tuner_enable_FEF(struct sit2_state *state, u8 fef)
+{
+	u8 uret = SIT2_ERROR_OK;
+	if(fef)
+		uret = sit2_sendProperty(state, 0x0711, 3, true);
+	else
+		uret = sit2_sendProperty(state, 0x0711, 1, true);
+	return uret;
+}
+
+static u8 sit2_tuner_setup_FEFMode(struct sit2_state *state, u8 fef)
+{
+	u8 uret = SIT2_ERROR_OK;
+	state->sndBuffer[0] = 0x12;
+	state->sndBuffer[1] = 1;
+	state->sndBuffer[2] = 1;
+	state->sndBuffer[3] = 1;
+	state->sndBuffer[4] = 1;
+	state->sndBuffer[5] = 1;	
+	uret = sit2_sendCommand(state, 6, 6, true);
+	
+	sit2_sendProperty(state, 0x070e, 0, true);	
+	sit2_sendProperty(state, 0x0708, 0, true);
+	
+	sit2_tuner_enable_FEF(state, fef);
+
+	return uret;
+}
+
+static u8 sit2_tuner_standby(struct sit2_state *state)
+{
+	state->sndBuffer[0] = 0x16;
+	state->sndBuffer[1] = 0;
+	return sit2_sendCommand(state, 2, 1, true);
+}
+
+static u8 sit2_tuner_powerUp(struct sit2_state *state)
+{
+	state->sndBuffer[0] = 0xc0;
+	state->sndBuffer[1] = 0;
+	state->sndBuffer[2] = 0;
+	state->sndBuffer[3] = 0;
+	state->sndBuffer[4] = 0;
+	state->sndBuffer[5] = 1;
+	state->sndBuffer[6] = 1;
+	state->sndBuffer[7] = 1;
+	state->sndBuffer[8] = 1;
+	state->sndBuffer[9] = 1;
+	state->sndBuffer[10] = 1;
+	state->sndBuffer[11] = 2; /* 24MHz */
+	state->sndBuffer[12] = 0;
+	state->sndBuffer[13] = 0;
+	state->sndBuffer[14] = 1;
+	
+	return sit2_sendCommand(state, 15, 1, true);
+}
+
+static u8 sit2_tuner_getStatus(struct sit2_state *state, u8 intack)
+{
+	state->sndBuffer[0] = 0x42;
+	state->sndBuffer[1] = intack & 0x01;
+	return sit2_sendCommand(state, 2, 12, true);
+}
+
+static u8 sit2_tuner_wakeUp(struct sit2_state *state)
+{
+	u8 uret, status = 0;
+	/* check CTS */
+	uret = sit2_pollForResponse(state, 1, &status, true);
+	if((uret == SIT2_ERROR_TIMEOUT) || (status & 0x80) != 0x80) {
+		printk(KERN_INFO
+	     	"%s: error! tuner is not ready.\n",
+	     	__func__);		
+		return SIT2_ERROR_ERR;
+	}
+	return SIT2_ERROR_OK;	
+}
+
+static u8 sit2_tuner_tuneFreq(struct sit2_state *state, u32 frequency)
+{
+	u8 uret, status;
+	int timeout = 150;
+	u32 ulCount, ulTick, ulDelay;
+	ulCount = 0;
+	ulTick = 3;
+	ulDelay = timeout/ulTick;
+	
+	state->sndBuffer[0] = 0x41;
+	state->sndBuffer[1] = 0;
+	state->sndBuffer[2] = 0;
+	state->sndBuffer[3] = 0;
+	
+	state->sndBuffer[4] = (u8)(frequency & 0xff);
+	state->sndBuffer[5] = (u8)((frequency >> 8) & 0xff);
+	state->sndBuffer[6] = (u8)((frequency >> 16) & 0xff);
+	state->sndBuffer[7] = (u8)((frequency >> 24) & 0xff);
+	
+	uret = sit2_sendCommand(state, 8, 1, true);
+	if(uret != SIT2_ERROR_OK)
+		return uret;
+    		
+	while(ulCount <= ulTick) {
+		uret = sit2_pollForResponse(state, 1, &status, true);
+		if(uret != SIT2_ERROR_OK)
+			return uret;
+		if(state->tuner_reply.tunint)
+			break;
+		msleep(ulDelay);
+		ulCount++;		
+	}
+	if(state->tuner_reply.tunint == 0)
+		return SIT2_ERROR_TIMEOUT;
+		
+	timeout = 20;
+	ulCount = 0;
+	ulTick = 2;
+	ulDelay = timeout/ulTick;
+	while ( ulCount <= ulTick ) {
+		uret = sit2_pollForResponse(state, 1, &status, true);
+		if(uret != SIT2_ERROR_OK)
+			return uret;
+		if(state->tuner_reply.dtvint)
+			break;
+		msleep(ulDelay);
+		ulCount++;					
+	}	
+	if(state->tuner_reply.dtvint == 0)
+		return SIT2_ERROR_TIMEOUT;
+	
+	return SIT2_ERROR_OK;
+}
+
+static u8 sit2_tuner_setFreq(struct sit2_state *state, u32 frequency, fe_delivery_system_t delsystem, u8 reqBW)
+{
+	u8 modulation, bandwidth;
+	u8 uret;
+	sit2_tuner_enable_FEF(state, 0);
+	if (delsystem == SYS_DVBC_ANNEX_A) {
+		modulation = 3;
+		bandwidth = 8;
+	} else {
+		modulation = 2;
+		bandwidth = (reqBW <= 6) ? 6 : reqBW;
+		if(bandwidth > 8)
+			bandwidth = 8;
+	}
+	uret = sit2_sendProperty(state, 0x0703, (modulation << 4) | bandwidth, true);
+	if(uret != SIT2_ERROR_OK)
+		return uret;
+	
+	uret = sit2_tuner_tuneFreq(state, frequency);
+	if(delsystem == SYS_DVBT2)
+		sit2_tuner_enable_FEF(state, 1);
+			
+	return uret;
+}
+
+static u8 sit2_tuner_init(struct sit2_state *state)
+{
+	u8 uret = SIT2_ERROR_OK;
+		
+	/* wake up */
+	uret = sit2_tuner_wakeUp(state);
+	if(uret != SIT2_ERROR_OK)
+		return uret;
+	/* power up */
+	uret = sit2_tuner_powerUp(state);
+	if(uret != SIT2_ERROR_OK)
+		return uret;
+	/* check part info */
+	/* load firmware */
+	/* start firmare */
+	uret = sit2_startFirmware(state, true);
+	if(uret != SIT2_ERROR_OK)
+		return uret;
+	
+	/* download default properties */
+	/* ATV property */
+	sit2_sendProperty(state, 0x0610, 1000, true); /* afc range*/
+	sit2_sendProperty(state, 0x0611, 0, true); /* agc speed */
+	sit2_sendProperty(state, 0x0623, (0x80 << 8) | 158, true); /* agc speed low rssi */
+	sit2_sendProperty(state, 0x0624, 0, true);
+	sit2_sendProperty(state, 0x0603, 8, true);
+	sit2_sendProperty(state, 0x0607, (200 << 8) | 50, true);
+	sit2_sendProperty(state, 0x0601, 1, true);
+	sit2_sendProperty(state, 0x0613, (1 << 9) | (1 << 8) | (0 << 1) | 0, true);
+	sit2_sendProperty(state, 0x060c, 5000, true);
+	sit2_sendProperty(state, 0x060d, (100 << 8) | 148, true);
+	sit2_sendProperty(state, 0x0617, 0, true);
+	sit2_sendProperty(state, 0x0612, 0, true);
+	sit2_sendProperty(state, 0x0605, 0xba, true);
+	sit2_sendProperty(state, 0x0604, (1 << 9), true);
+	sit2_sendProperty(state, 0x0616, 0, true);
+	/* common property */
+	sit2_sendProperty(state, 0x0402, 8, true);
+	sit2_sendProperty(state, 0x0401, 0, true);
+	/* DTV property */
+	sit2_sendProperty(state, 0x0711, 0, true); /* agc freeze pin */
+	sit2_sendProperty(state, 0x0708, 0, true);
+	sit2_sendProperty(state, 0x0702, 1, true);
+	sit2_sendProperty(state, 0x0705, (200 << 8) | 50, true);
+	sit2_sendProperty(state, 0x070c, 1, true);
+	sit2_sendProperty(state, 0x0701, 1, true);
+	sit2_sendProperty(state, 0x070d, 0, true);
+	sit2_sendProperty(state, 0x070e, 0, true);
+	sit2_sendProperty(state, 0x0710, 0, true);
+	sit2_sendProperty(state, 0x070a, (1 << 8), true);
+	sit2_sendProperty(state, 0x0706, 5000, true);
+	sit2_sendProperty(state, 0x0707, (27 << 8) | 148, true);
+	sit2_sendProperty(state, 0x0703, (2 << 4) | 8, true);
+	sit2_sendProperty(state, 0x0713, (0xff << 8) | 0xff, true);
+	sit2_sendProperty(state, 0x070f, 0, true);
+	sit2_sendProperty(state, 0x0709, 0, true);
+	sit2_sendProperty(state, 0x0704, 0xb0, true);
+	sit2_sendProperty(state, 0x0712, 16, true);
+	/* tuner property */
+	sit2_sendProperty(state, 0x0504, 0x8000, true);
+	sit2_sendProperty(state, 0x0501, 1, true);
+	sit2_sendProperty(state, 0x0505, (1 << 10) | (1 << 9) | (1 << 8), true);
+	sit2_sendProperty(state, 0x0506, 1, true);
+	sit2_sendProperty(state, 0x0507, 127, true);
+	
+	return uret;
+}
+
+static u8 sit2_demod_wakeUp(struct sit2_state *state, u8 resetCode, u8 funcCode)
+{
+	u8 uret = SIT2_ERROR_OK;
+	 dprintk("%s, resetCode=%d, funcCode=%d\n", __func__, resetCode, funcCode);
+	 /* start clock */
+	state->sndBuffer[0] = 0xc0;
+	state->sndBuffer[1] = 18;
+	state->sndBuffer[2] = 0;
+	state->sndBuffer[3] = 12;
+	state->sndBuffer[4] = 0;
+	state->sndBuffer[5] = 0x0d;
+	state->sndBuffer[6] = 22;
+	state->sndBuffer[7] = 0;
+	state->sndBuffer[8] = 0;
+	state->sndBuffer[9] = 0;
+	state->sndBuffer[10] = 0;
+	state->sndBuffer[11] = 0;
+	state->sndBuffer[12] = 0;	
+	uret = sit2_sendCommand(state, 13, 0, false);
+	if(uret != SIT2_ERROR_OK)
+		return uret;
+	/* power up */
+	dprintk("%s, power up\n", __func__);
+	state->sndBuffer[0] = 0xc0;
+	state->sndBuffer[1] = 6;
+	state->sndBuffer[2] = resetCode;
+	state->sndBuffer[3] = 15;
+	state->sndBuffer[4] = 0;
+	state->sndBuffer[5] = (1 << 5);
+	state->sndBuffer[6] = (2 << 4) | (funcCode & 0x0f);
+	state->sndBuffer[7] = 1;
+	uret = sit2_sendCommand(state, 8, 1, false);
+	dprintk("%s, power up[%d]\n", __func__, uret);
+	return uret;
+}
+
+static u8 sit2_demod_powerDown(struct sit2_state *state)
+{
+	u8 uret;
+	dprintk("%s\n", __func__);
+	state->sndBuffer[0] = 0x13;
+	uret = sit2_sendCommand(state, 1, 0, false);
+	return uret;
+}
+
+static u8 sit2_demod_reStart(struct sit2_state *state)
+{
+	u8 uret;
+	state->sndBuffer[0] = 0x85;
+	uret = sit2_sendCommand(state, 1, 1, false);
+	return uret;
+}
+
+static u8 sit2_demod_romId(struct sit2_state *state, u8 *id)
+{
+	u8 uret;
+	state->sndBuffer[0] = 0x02;
+	uret = sit2_sendCommand(state, 1, 13, false);
+	*id = state->revBuffer[12];
+	return uret;
+}
+
+static u8 sit2_demod_getStatus(struct sit2_state *state, u8 intack, SIT2_DD_STATUS *pStatus)
+{
+	u8 uret;
+	state->sndBuffer[0] = 0x87;
+	state->sndBuffer[1] = intack & 0x01;
+	uret = sit2_sendCommand(state, 2, 8, false);
+	
+	pStatus->pclint = (state->revBuffer[1] >> 1) & 0x01;
+	pStatus->dlint = (state->revBuffer[1] >> 2) & 0x01;
+	pStatus->berint = (state->revBuffer[1] >> 3) & 0x01;
+	pStatus->uncorint = (state->revBuffer[1] >> 4) & 0x01;
+	pStatus->rsqint_bit5 = (state->revBuffer[1] >> 5) & 0x01;
+	pStatus->rsqint_bit6 = (state->revBuffer[1] >> 6) & 0x01;
+	pStatus->rsqint_bit7 = (state->revBuffer[1] >> 7) & 0x01;
+	
+	pStatus->pcl = (state->revBuffer[2] >> 1) & 0x01;
+	pStatus->dl = (state->revBuffer[2] >> 2) & 0x01;
+	pStatus->ber = (state->revBuffer[2] >> 3) & 0x01;
+	pStatus->uncor = (state->revBuffer[2] >> 4) & 0x01;
+	pStatus->rsqstat_bit5 = (state->revBuffer[2] >> 5) & 0x01;
+	pStatus->rsqstat_bit6 = (state->revBuffer[2] >> 6) & 0x01;
+	pStatus->rsqstat_bit7 = (state->revBuffer[2] >> 7) & 0x01;
+	
+	pStatus->modulation = state->revBuffer[3] & 0x0f;
+	pStatus->ts_bit_rate = (state->revBuffer[5] << 8) | state->revBuffer[4];
+	pStatus->ts_clk_freq = (state->revBuffer[7] << 8) | state->revBuffer[6];
+		
+	return uret;
+}
+
+static u8 sit2_demod_getDVBTStatus(struct sit2_state *state, u8 intack)
+{
+	u8 uret;
+	state->sndBuffer[0] = 0xa0;
+	state->sndBuffer[1] = intack & 0x01;
+	uret = sit2_sendCommand(state, 2, 13, false);
+	return uret;
+}
+
+static u8 sit2_demod_getDVBT2Status(struct sit2_state *state, u8 intack)
+{
+	u8 uret;
+	state->sndBuffer[0] = 0x50;
+	state->sndBuffer[1] = intack & 0x01;
+	uret = sit2_sendCommand(state, 2, 14, false);
+	return uret;
+}
+
+static u8 sit2_demod_getDVBCStatus(struct sit2_state *state, u8 intack)
+{
+	u8 uret;
+	state->sndBuffer[0] = 0x90;
+	state->sndBuffer[1] = intack & 0x01;
+	uret = sit2_sendCommand(state, 2, 9, false);
+	return uret;
+}
+
+static u8 sit2_demod_getUncor(struct sit2_state *state, u8 rstcode)
+{
+	u8 uret;
+	state->sndBuffer[0] = 0x84;
+	state->sndBuffer[1] = rstcode & 0x01;
+	uret = sit2_sendCommand(state, 2, 3, false);
+	return uret;
+}
+
+static u8 sit2_demod_getBer(struct sit2_state *state, u8 rstcode)
+{
+	u8 uret;
+	state->sndBuffer[0] = 0x82;
+	state->sndBuffer[1] = rstcode & 0x01;
+	uret = sit2_sendCommand(state, 2, 3, false);
+	return uret;
+}
+
+static u8 sit2_demod_downloadFW(struct sit2_state *state, u8 fw[], u32 fwSize, u8 nbPerLine)
+{
+	u8 uret = SIT2_ERROR_OK;
+	u32 line, fw_lines, line_left;
+	fw_lines = fwSize / nbPerLine;
+	line_left = fwSize - fw_lines*nbPerLine;
+	if(fw_lines > 0) {
+		for(line = 0; line < fw_lines; line++) {
+			memcpy(state->sndBuffer, fw + nbPerLine*line, nbPerLine);
+			uret = sit2_sendCommand(state, nbPerLine, 1, false);
+			if(uret != SIT2_ERROR_OK)
+				break;
+		}
+	}
+	if(line_left) {
+		memcpy(state->sndBuffer, fw + nbPerLine*fw_lines, line_left);
+		uret = sit2_sendCommand(state, line_left, 1, false);
+	}	
+	return uret;
+}
+
+static u8 sit2_demod_setMP(struct sit2_state *state, u8 mp_a, u8 mp_b, u8 mp_c, u8 mp_d)
+{
+	state->sndBuffer[0] = 0x88;
+	state->sndBuffer[1] = mp_a;
+	state->sndBuffer[2] = mp_b;
+	state->sndBuffer[3] = mp_c;
+	state->sndBuffer[4] = mp_d;
+	return sit2_sendCommand(state, 5, 5, false);
+}
+
+static u8 sit2_demod_setGPIO(struct sit2_state *state, u8 gpMode_0, u8 gpRead_0, u8 gpMode_1, u8 gpRead_1)
+{
+	state->sndBuffer[0] = 0x12;
+	state->sndBuffer[1] = (gpRead_0 << 7) | gpMode_0;
+	state->sndBuffer[2] = (gpRead_1 << 7) | gpMode_1;
+	return sit2_sendCommand(state, 3, 3, false);
+}
+
+static u8 sit2_demod_setExtAGC(struct sit2_state *state, u8 agc1_mode, u8 agc1_inv, u8 agc1_kloop, u8 agc1_min,
+				u8 agc2_mode, u8 agc2_inv, u8 agc2_kloop, u8 agc2_min)
+{
+	state->sndBuffer[0] = 0x89;
+	state->sndBuffer[1] = (agc2_inv << 7) | (agc2_mode << 4) | (agc1_inv << 3) | agc1_mode;
+	state->sndBuffer[2] = agc1_kloop;
+	state->sndBuffer[3] = agc2_kloop;
+	state->sndBuffer[4] = agc1_min;
+	state->sndBuffer[5] = agc2_min;
+	return sit2_sendCommand(state, 6, 3, false);
+}
+
+static u8 sit2_demod_setDvbt2FEF(struct sit2_state *state, u8 fef_flag, u8 fef_inv)
+{
+	state->sndBuffer[0] = 0x51;
+	state->sndBuffer[1] = (fef_inv << 3) | fef_flag;
+	return sit2_sendCommand(state, 2, 12, false);
+}
+
+static u8 sit2_demod_selectPlp(struct sit2_state *state, u8 plp_id, u8 plp_mode)
+{
+	state->sndBuffer[0] = 0x52;
+	state->sndBuffer[1] = plp_id;
+	state->sndBuffer[1] = plp_mode;
+	return sit2_sendCommand(state, 3, 1, false);
+}
+
+static u8 sit2_demod_init(struct sit2_state *state)
+{
+	u8 uret = SIT2_ERROR_OK;
+	u8 ts_mode, ts_clock;
+	u8 romid;
+	uret = sit2_demod_wakeUp(state, 1, 0);
+	if(uret != SIT2_ERROR_OK)
+		return uret;
+
+	uret = sit2_demod_romId(state, &romid);
+	if(uret != SIT2_ERROR_OK)
+		return uret;
+
+	dprintk("%s: start to download ver[%d] patch!\n", __func__, romid);
+	if(romid == 2) { /* Ver20 */		
+		uret = sit2_demod_downloadFW(state, sit2_patch_2, SIT2_PATCH_2_SIZE, SIT2_PATCH_PER_LINE);
+		if(uret != SIT2_ERROR_OK)
+			return uret;
+		dprintk("%s: download ver[%d] patch sucessfully!\n", __func__, romid);
+	} else if (romid == 3) { /* Ver30 */
+		uret = sit2_demod_downloadFW(state, sit2_patch_3, SIT2_PATCH_3_SIZE, SIT2_PATCH_PER_LINE);
+		if(uret != SIT2_ERROR_OK)
+			return uret;
+		dprintk("%s: download ver[%d] patch sucessfully!\n", __func__, romid);		
+	}
+	
+	uret = sit2_startFirmware(state, false);
+	if(uret != SIT2_ERROR_OK)
+		return uret;
+		
+	/* download default properties */
+	sit2_demod_setMP(state, 1, 2, 1, 1);
+	sit2_demod_setExtAGC(state, 1, 0, 6, 0, 2, 0, 18, 0);
+	sit2_demod_setDvbt2FEF(state, 3, 0);
+	sit2_demod_setGPIO(state, 8, 0, 4, 0);
+	/* common */
+	sit2_sendProperty(state, 0x0401, 0, false);
+	/* DD */
+	sit2_sendProperty(state, 0x1003, (1 << 4) | 7, false);
+	sit2_sendProperty(state, 0x1002, (1 << 4) | 5, false);
+	sit2_sendProperty(state, 0x100c, (1 << 4) | 2, false);
+	sit2_sendProperty(state, 0x1006, 0x24, false);
+	sit2_sendProperty(state, 0x100b, 5000, false);
+	sit2_sendProperty(state, 0x1007, 0x2400, false);
+	sit2_sendProperty(state, 0x100a, (0 << 9) | (0 << 8) | (2 << 4) | 8, false); /* set modulation */
+	sit2_sendProperty(state, 0x1004, (1 << 4) | 5, false);
+	sit2_sendProperty(state, 0x1005, (10 << 4) | 1, false);
+	sit2_sendProperty(state, 0x100d, 720, false); /* ts clock frequency */
+	if (state->config->ts_bus_mode == 1)
+		ts_mode = 3;
+	else if (state->config->ts_bus_mode == 2)
+		ts_mode = 6;
+	else
+		ts_mode = 0;
+	if (state->config->ts_clock_mode == 1)
+		ts_clock = 2;
+	else
+		ts_clock = 1;	
+	sit2_sendProperty(state, 0x1001, (0 << 8) | (0 << 7) | (0 << 6) | (ts_clock << 4) | ts_mode, false);	
+	sit2_sendProperty(state, 0x1009, (0 << 13) | (1 << 12) | (3 << 10) | (15 << 6) | (3 << 4) | 15, false);
+	sit2_sendProperty(state, 0x1008, (0 << 14) | (1 << 13) | (1 << 12) | (3 << 10) | (15 << 6) | (3 << 4) | 15, false);
+	/* DVBC */
+	sit2_sendProperty(state, 0x1104, 112, false);
+	sit2_sendProperty(state, 0x1103, 100, false);
+	sit2_sendProperty(state, 0x1101, 0, false);
+	sit2_sendProperty(state, 0x1102, 6900, false);
+	/* DVBT */
+	sit2_sendProperty(state, 0x1203, 130, false);
+	sit2_sendProperty(state, 0x1202, 550, false);
+	sit2_sendProperty(state, 0x1201, 0, false);
+	/* DVBT2 */
+	sit2_sendProperty(state, 0x1303, 130, false);
+	sit2_sendProperty(state, 0x1301, 550, false);
+	sit2_sendProperty(state, 0x1302, (1 << 12) | (1 << 8) | 1, false);	
+	/* SCAN */
+	sit2_sendProperty(state, 0x0304, 0, false);
+	sit2_sendProperty(state, 0x0303, 0, false);
+	sit2_sendProperty(state, 0x0308, 0, false);
+	sit2_sendProperty(state, 0x0307, (1 << 9) | 1, false);
+	sit2_sendProperty(state, 0x0306, 0, false);
+	sit2_sendProperty(state, 0x0305, 0, false);
+	sit2_sendProperty(state, 0x0301, (3 << 2), false);
+	
+	return uret;
+}
+
+static int sit2_setStandard(struct sit2_state *state, fe_delivery_system_t toSystem)
+{
+	u8 bandwidth = 8, modulation = 2, spectrum = 0, auto_detect = 1;
+	
+	dprintk("%s, to=%d, current=%d\n", __func__, toSystem, state->current_system);
+	if (toSystem == state->current_system)
+		return 0;
+	
+	switch(toSystem) {
+	case SYS_DVBT:
+		bandwidth = 8;
+		modulation = 2;
+		spectrum = 0;
+		auto_detect = 1;
+		break;
+	case SYS_DVBT2:
+		bandwidth = 8;
+		modulation = 7;
+		spectrum = 0;
+		auto_detect = 1;
+		break;
+	case SYS_DVBC_ANNEX_A:
+		bandwidth = 8;
+		modulation = 3;
+		spectrum = 0;
+		auto_detect = 0;
+		break;
+	default:
+		printk(KERN_INFO
+	     	"%s: error! unsupported system=%d\n",
+	     	__func__, toSystem);
+	     	break;			
+	}
+	sit2_demod_tuner_i2c_enable(state, 1);
+	if(toSystem == SYS_DVBT2)
+		sit2_tuner_setup_FEFMode(state, 1);
+	else
+		sit2_tuner_setup_FEFMode(state, 0);
+	sit2_demod_tuner_i2c_enable(state, 0);
+	sit2_sendProperty(state, 0x100a, (auto_detect << 9) | (spectrum << 8) | (modulation << 4) | bandwidth, false);
+	sit2_demod_reStart(state);
+	state->current_system = toSystem;
+	
+	return 0;
+}
+
+int power_of_n (int n, int m)
+{
+	int i, p = 1;
+	for (i=1; i<= m; i++) {
+		p = p*n;
+	}
+	return p;
+}
+
+static int sit2_drv_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct sit2_state *state = fe->demodulator_priv;
+	sit2_demod_tuner_i2c_enable(state, 1);
+	sit2_tuner_getStatus(state, 0);
+	sit2_demod_tuner_i2c_enable(state, 0);
+	*strength = state->revBuffer[3] + 128;
+	/* scale value to 0x0000-0xffff from 0x0000-0x00ff */
+	*strength = *strength * 0xffff / 0x00ff;
+	return 0;
+}
+
+static int sit2_drv_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct sit2_state *state = fe->demodulator_priv;
+	
+	sit2_demod_getUncor(state, 0);
+	*ucblocks = (state->revBuffer[2] << 16) |  state->revBuffer[1];;
+	
+	return 0;
+}
+
+static int sit2_drv_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct sit2_state *state = fe->demodulator_priv;
+	
+	sit2_demod_getBer(state, 0);
+	if(state->revBuffer[1] != 0) { /* to do scale. */
+		*ber = state->revBuffer[2]/10/power_of_n(10, state->revBuffer[1]);
+	}
+	return 0;
+}
+
+static int sit2_drv_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct sit2_state *state = fe->demodulator_priv;
+	SIT2_DD_STATUS dd_status;
+	
+	sit2_demod_getStatus(state, 0, &dd_status);
+	switch(dd_status.modulation) {
+	case 2: /*DVB-T*/
+		sit2_demod_getDVBTStatus(state, 0);
+		break;
+	case 7: /*DVB-T2*/
+		sit2_demod_getDVBT2Status(state, 0);
+		break;
+	case 3: /*DVB-C*/
+		sit2_demod_getDVBCStatus(state, 0);		
+		break;
+	}
+	/* report SNR in dB * 10 */
+	*snr = state->revBuffer[3]/40;
+	return 0;
+}
+
+static int sit2_drv_read_status(struct dvb_frontend *fe, fe_status_t *status)
+{
+	struct sit2_state *state = fe->demodulator_priv;
+	SIT2_DD_STATUS dd_status;	
+	*status = 0;
+	sit2_demod_getStatus(state, 0, &dd_status);
+	if(dd_status.pcl)
+		*status = FE_HAS_SIGNAL | FE_HAS_CARRIER
+		    | FE_HAS_SYNC | FE_HAS_VITERBI;
+	if (dd_status.dl)
+		*status = FE_HAS_SIGNAL | FE_HAS_CARRIER
+		    | FE_HAS_SYNC | FE_HAS_VITERBI | FE_HAS_LOCK;
+	return 0;
+}
+
+static int sit2_drv_get_frontend_algo(struct dvb_frontend *fe)
+{
+	return DVBFE_ALGO_HW;
+}
+
+static fe_modulation_t sit2_convert_modulation(u8 constellation)
+{
+	fe_modulation_t ret;
+	switch (constellation) {
+	case 7:
+		ret = QAM_16;
+		break;
+	case 8:
+		ret = QAM_32;
+		break;
+	case 9:
+		ret = QAM_64;
+		break;
+	case 10:
+		ret = QAM_128;
+		break;
+	case 11:
+		ret = QAM_256;
+		break;
+	case 3:
+		ret = QPSK;
+		break;
+	default:
+		ret = QAM_AUTO;
+		break;		
+	}
+	return ret;				
+}
+
+static fe_transmit_mode_t sit2_convert_fftcode(u8 fftcode)
+{
+	fe_transmit_mode_t ret;
+	switch (fftcode) {	
+	case 10:
+		ret = TRANSMISSION_MODE_1K;
+		break;
+	case 11:
+		ret = TRANSMISSION_MODE_2K;
+		break;
+	case 12:
+		ret = TRANSMISSION_MODE_4K;
+		break;
+	case 13:
+		ret = TRANSMISSION_MODE_8K;
+		break;
+	case 14:
+		ret = TRANSMISSION_MODE_16K;
+		break;
+	case 15:
+		ret = TRANSMISSION_MODE_32K;
+		break;
+	default:
+		ret = TRANSMISSION_MODE_AUTO;
+	}
+	return ret;
+}
+
+static fe_guard_interval_t sit2_convert_gicode(int gicode)
+{
+	fe_guard_interval_t ret;
+	switch (gicode) {
+	case 1:
+		ret = GUARD_INTERVAL_1_32;
+		break;
+	case 2:
+		ret = GUARD_INTERVAL_1_16;
+		break;
+	case 3:
+		ret = GUARD_INTERVAL_1_8;
+		break;
+	case 4:
+		ret = GUARD_INTERVAL_1_4;
+		break;
+	case 5:
+		ret = GUARD_INTERVAL_1_128;
+		break;
+	case 6:
+		ret = GUARD_INTERVAL_19_128;
+		break;
+	case 7:
+		ret = GUARD_INTERVAL_19_256;
+		break;		
+	default:
+		ret = GUARD_INTERVAL_AUTO;
+	}
+	return ret;
+}
+
+static fe_hierarchy_t sit2_convert_hierarchycode(int hierarchycode)
+{
+	fe_hierarchy_t ret;
+	switch (hierarchycode) {
+	case 1:
+		ret = HIERARCHY_NONE;
+		break;
+	case 2:
+		ret = HIERARCHY_1;
+		break;
+	case 3:
+		ret = HIERARCHY_2;
+		break;
+	case 5:
+		ret = HIERARCHY_4;
+		break;
+	default:
+		ret = HIERARCHY_AUTO;
+	}
+	return ret;
+}
+
+static fe_code_rate_t sit2_convert_coderate(int coderate)
+{
+	fe_code_rate_t ret;
+	switch (coderate) {
+	case 1:
+		ret = FEC_1_2;
+		break;
+	case 2:
+		ret = FEC_2_3;
+		break;
+	case 3:
+		ret = FEC_3_4;
+		break;
+	case 4:
+		ret = FEC_4_5;
+		break;
+	case 5:
+		ret = FEC_5_6;
+		break;
+	case 7:
+		ret = FEC_7_8;
+		break;
+	case 13:
+		ret = FEC_3_5;
+		break;		
+	default:
+		ret = FEC_AUTO;
+	}
+	return ret;
+}
+
+static int sit2_drv_get_frontend(struct dvb_frontend *fe)
+{
+	struct sit2_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret = 0;
+	SIT2_DD_STATUS dd_status;
+	sit2_demod_getStatus(state, 0, &dd_status);
+	switch(dd_status.modulation) {
+	case 2: /*DVB-T*/
+		sit2_demod_getDVBTStatus(state, 0);
+		c->modulation = sit2_convert_modulation(state->revBuffer[8] & 0x3f);
+		c->transmission_mode = sit2_convert_fftcode(state->revBuffer[10] & 0x0f);
+		c->guard_interval = sit2_convert_gicode((state->revBuffer[10] >> 4) & 0x07);
+		c->hierarchy = sit2_convert_hierarchycode(state->revBuffer[11] & 0x07);
+		c->code_rate_HP = sit2_convert_coderate(state->revBuffer[9] & 0x0f);
+		c->code_rate_LP = sit2_convert_coderate((state->revBuffer[9] >> 4) & 0x0f);
+		c->inversion = ((state->revBuffer[8] >> 6) & 0x01) ? INVERSION_ON : INVERSION_OFF;
+		break;
+	case 7: /*DVB-T2*/
+		sit2_demod_getDVBT2Status(state, 0);
+		c->modulation = sit2_convert_modulation(state->revBuffer[8] & 0x3f);
+		c->transmission_mode = sit2_convert_fftcode(state->revBuffer[9] & 0x0f);
+		c->guard_interval = sit2_convert_gicode((state->revBuffer[9] >> 4) & 0x07);
+		c->fec_inner = sit2_convert_coderate(state->revBuffer[12] & 0x0f);
+		c->inversion = ((state->revBuffer[8] >> 6) & 0x01) ? INVERSION_ON : INVERSION_OFF;
+		break;
+	case 3: /*DVB-C*/
+		sit2_demod_getDVBCStatus(state, 0);
+		c->symbol_rate = state->dvbc_symrate;
+		c->modulation = sit2_convert_modulation(state->revBuffer[8] & 0x3f);
+		c->inversion = ((state->revBuffer[8] >> 6) & 0x01) ? INVERSION_ON : INVERSION_OFF;
+		break;
+	}	
+	return ret;
+}
+
+static int sit2_drv_set_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct sit2_state *state = fe->demodulator_priv;
+	int req_plp_id = 0;
+	u8 uret, req_qam, req_bandwidth = 0;
+	u32 max_lock_time = 5000, min_lock_time = 100;
+	u32 ulCount, ulTick, ulDelay;
+	SIT2_DD_STATUS dd_status;
+	bool bLock = false, bSearch = true;
+	
+	dprintk(
+	     "%s: system=%d frequency=%d bandwidth=%d symrate=%d qam=%d stream_id=%d\n",
+	     __func__, c->delivery_system, c->frequency, c->bandwidth_hz, c->symbol_rate, c->modulation, c->stream_id);
+	     	
+	sit2_setStandard(state, c->delivery_system);
+	switch (c->modulation) {
+	case QAM_16:
+		req_qam = 7;
+		break;
+	case QAM_32:
+		req_qam = 8;
+		break;
+	case QAM_64:
+		req_qam = 9;
+		break;
+	case QAM_128:
+		req_qam = 10;
+		break;	
+	case QAM_256:
+		req_qam = 11;
+		break;	
+	default: /* QAM_AUTO */
+		req_qam = 0;
+		break;
+	}
+	if (c->stream_id == NO_STREAM_ID_FILTER)
+		req_plp_id = state->plp_id;
+	else if ((c->stream_id >= 0) && (c->stream_id <= 255)) {
+		req_plp_id = c->stream_id;
+		state->plp_id = req_plp_id;
+	}
+	switch(c->delivery_system) {
+	case SYS_DVBT:
+	case SYS_DVBT2:
+		max_lock_time = 5000;
+		min_lock_time = 100;
+		sit2_sendProperty(state, 0x1201, state->stream, false);
+		if(req_plp_id != -1)
+			sit2_demod_selectPlp(state, req_plp_id, 1);
+		else
+			sit2_demod_selectPlp(state, 0, 0);
+		if(c->bandwidth_hz == 1700000)
+			req_bandwidth = 2;
+		else
+			req_bandwidth = (u8)(c->bandwidth_hz/1000000);
+		sit2_sendProperty(state, 0x100a, (1 << 9) | (0 << 8) | (15 << 4) | req_bandwidth, false);
+		break;
+	case SYS_DVBC_ANNEX_A:
+		max_lock_time = 2000;
+		min_lock_time = 80;
+		req_bandwidth = 8;
+		state->dvbc_symrate = c->symbol_rate;
+		sit2_sendProperty(state, 0x100a, (3 << 4) | req_bandwidth, false);
+		sit2_sendProperty(state, 0x1102, c->symbol_rate/1000, false);
+		sit2_sendProperty(state, 0x1101, req_qam, false);
+		break;
+	default:
+		dprintk("%s, error! unsupport delivery system - %d!", __func__, c->delivery_system);
+		break;
+	}
+	
+	/* tune tuner frequency */
+	sit2_demod_tuner_i2c_enable(state, 1);
+	sit2_tuner_setFreq(state, c->frequency, c->delivery_system, req_bandwidth);
+	sit2_demod_tuner_i2c_enable(state, 0);
+	
+	sit2_demod_reStart(state);
+	
+	/* check status */
+  	ulCount = 0;
+  	ulDelay = 10;
+  	ulTick = max_lock_time/ulDelay;
+  	msleep(min_lock_time);
+  	
+  	while(bSearch) {
+  		ulCount++;
+  		
+  		uret = sit2_demod_getStatus(state, 1, &dd_status);
+  		switch(c->delivery_system) {
+  		case SYS_DVBT:
+  		case SYS_DVBT2:
+  			if(dd_status.dl) {
+  				if((dd_status.modulation == 7) && (c->delivery_system == SYS_DVBT)) {
+  					if(req_plp_id != -1)
+						sit2_demod_selectPlp(state, req_plp_id, 1);
+					else
+						sit2_demod_selectPlp(state, 0, 0);
+  					msleep(340);
+  				}
+  				bLock = true;
+  				bSearch = false;
+  			} else if(dd_status.rsqint_bit5)
+  				bSearch = false;
+  			break;
+  		case SYS_DVBC_ANNEX_A:
+  			if(dd_status.dl) {
+  				bLock = true;
+  				bSearch = false;
+  			}
+  			break;
+  		default:
+			dprintk("%s, error! unsupport delivery system - %d!", __func__, c->delivery_system);
+			bSearch = false;
+			break;
+  		}
+  		
+  		if(bSearch)
+  			msleep(10);
+  		if (ulCount >= ulTick)
+  			bSearch = false;
+  	}	
+
+	if (bLock && state->config->start_ctrl)
+		state->config->start_ctrl(fe);
+	return 0;
+}
+
+static int sit2_drv_tune(struct dvb_frontend *fe,
+			bool re_tune,
+			unsigned int mode_flags,
+			unsigned int *delay,
+			fe_status_t *status)
+{	
+	*delay = HZ / 5;	
+	if (re_tune) {
+		int ret = sit2_drv_set_frontend(fe);
+		if (ret)
+			return ret;
+	}	
+	return sit2_drv_read_status(fe, status);
+}
+
+static int sit2_drv_init(struct dvb_frontend *fe)
+{
+	struct sit2_state *state = fe->demodulator_priv;
+
+	dprintk("%s: init=%d\n", __func__, state->isInited);
+	
+	sit2_demod_tuner_i2c_enable(state, 1);
+	
+	if(state->isInited) {
+		sit2_tuner_wakeUp(state);		
+	} else {
+		sit2_tuner_init(state);
+	}
+	sit2_tuner_xout_enable(state, 1);
+	
+	if(state->isInited) {		
+		sit2_demod_wakeUp(state, 8, 1);
+	} else {
+		sit2_demod_init(state);
+		state->isInited = true;
+	}	
+	
+	sit2_demod_tuner_i2c_enable(state, 0);
+	return 0;
+}
+
+static int sit2_drv_sleep(struct dvb_frontend *fe)
+{
+	struct sit2_state *state = fe->demodulator_priv;
+	
+	dprintk("%s: init=%d\n", __func__, state->isInited);
+	
+	sit2_demod_powerDown(state);
+	
+	sit2_demod_tuner_i2c_enable(state, 1);
+	sit2_tuner_xout_enable(state, 0);
+	sit2_tuner_standby(state);
+	sit2_demod_tuner_i2c_enable(state, 0);
+	
+	state->current_system = SYS_UNDEFINED;
+	return 0;
+}
+
+static void sit2_drv_release(struct dvb_frontend *fe)
+{
+	struct sit2_state *state = fe->demodulator_priv;
+	kfree(state);
+}
+
+static const struct dvb_frontend_ops sit2_ops = {
+	.delsys = { SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A },
+	/*.delsys = { SYS_DVBC_ANNEX_A },*/
+	/* default: DVB-T/T2 */
+	.info = {
+		.name = "Sit2 DVB-T2/C",
+		.frequency_stepsize = 62500,
+		.frequency_min = 48000000,
+		.frequency_max = 870000000,
+		.symbol_rate_min = 870000,
+		.symbol_rate_max = 7500000,
+		.caps =	FE_CAN_FEC_1_2			|
+			FE_CAN_FEC_2_3			|
+			FE_CAN_FEC_3_4			|
+			FE_CAN_FEC_5_6			|
+			FE_CAN_FEC_7_8			|
+			FE_CAN_FEC_AUTO			|
+			FE_CAN_QPSK			|
+			FE_CAN_QAM_16			|
+			FE_CAN_QAM_32			|
+			FE_CAN_QAM_64			|
+			FE_CAN_QAM_128			|
+			FE_CAN_QAM_256			|
+			FE_CAN_QAM_AUTO			|
+			FE_CAN_TRANSMISSION_MODE_AUTO	|
+			FE_CAN_GUARD_INTERVAL_AUTO	|
+			FE_CAN_HIERARCHY_AUTO		|
+			FE_CAN_MUTE_TS			|
+			FE_CAN_2G_MODULATION		|
+			FE_CAN_MULTISTREAM
+		},
+
+	.release		= sit2_drv_release,
+	.init			= sit2_drv_init,
+	.sleep			= sit2_drv_sleep,
+
+	.tune			= sit2_drv_tune,
+	.set_frontend		= sit2_drv_set_frontend,
+	.get_frontend		= sit2_drv_get_frontend,
+	.get_frontend_algo	= sit2_drv_get_frontend_algo,
+
+	.read_status		= sit2_drv_read_status,
+	.read_snr		= sit2_drv_read_snr,
+	.read_ber		= sit2_drv_read_ber,
+	.read_ucblocks		= sit2_drv_read_ucblocks,
+	.read_signal_strength	= sit2_drv_read_signal_strength,
+};
+
+struct dvb_frontend *sit2_attach(const struct sit2_config *config,
+		struct i2c_adapter *i2c)
+{
+	struct sit2_state *state = NULL;
+	state = kzalloc(sizeof(struct sit2_state), GFP_KERNEL);
+	if (!state) {
+		dev_err(&i2c->dev, "%s: kzalloc() failed\n",
+				KBUILD_MODNAME);
+		goto error;
+	}	
+	state->config = config;
+	state->i2c = i2c;
+	state->isInited = false;
+	state->demod_addr = SIT2_DEMOD_ADDRESS;
+	state->tuner_addr = SIT2_TUNER_ADDRESS;
+	state->plp_id = 0;
+	state->current_system = SYS_UNDEFINED;
+	state->stream = 0;
+	
+	memcpy(&state->frontend.ops, &sit2_ops,
+	       sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+	return &state->frontend;
+error:
+	kfree(state);
+	return NULL;
+}
+EXPORT_SYMBOL(sit2_attach);
+
+MODULE_DESCRIPTION("sit2 demodulator driver");
+MODULE_AUTHOR("Max Nibble <nibble.max@gmail.com>");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.00");
diff -urN a/drivers/media/dvb-frontends/sit2.h b/drivers/media/dvb-frontends/sit2.h
--- a/drivers/media/dvb-frontends/sit2.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/sit2.h	2013-05-05 22:17:20.000000000 +0800
@@ -0,0 +1,45 @@
+/*
+    SIT2  - DVB-T2/T/C demodulator and tuner
+
+    Copyright (C) 2013 Max Nibble <nibble.max@gmail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef SIT2_H
+#define SIT2_H
+
+#include <linux/dvb/frontend.h>
+
+struct sit2_config {
+	u8 ts_bus_mode; /*1-serial, 2-parallel.*/
+	u8 ts_clock_mode; /*0-auto, 1-manual.*/
+	
+	int (*start_ctrl)(struct dvb_frontend *fe);
+};
+
+#if defined(CONFIG_DVB_SIT2) || (defined(CONFIG_DVB_SIT2_MODULE) && defined(MODULE))
+extern struct dvb_frontend *sit2_attach(const struct sit2_config *config,
+					    struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *sit2_attach(const struct sit2_config *config,
+					    struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif /* CONFIG_DVB_SIT2 */
+
+#endif /* SIT2_H */
diff -urN a/drivers/media/dvb-frontends/sit2_priv.h b/drivers/media/dvb-frontends/sit2_priv.h
--- a/drivers/media/dvb-frontends/sit2_priv.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/sit2_priv.h	2013-05-05 22:17:25.000000000 +0800
@@ -0,0 +1,2208 @@
+/*
+    SIT2  - DVB-T2/T/C demodulator and tuner
+*/
+
+#ifndef SIT2_PRIV_H
+#define SIT2_PRIV_H
+
+#define SIT2_DEMOD_ADDRESS  0x64 /*0xc8*/
+#define SIT2_TUNER_ADDRESS  0x60 /*0xc0*/
+    
+#define SIT2_ERROR_OK		0x00
+#define SIT2_ERROR_TIMEOUT	0x01
+#define SIT2_ERROR_POLLING	0x02
+#define SIT2_ERROR_PAREMETER	0x03
+#define SIT2_ERROR_ERR		0xfe
+#define SIT2_ERROR_UNKNOWN	0xff
+
+/*structure definition */
+typedef struct {
+	u8 tunint;
+	u8 atvint;
+	u8 dtvint;
+	u8 err;
+	u8 cts;
+}sit2_tuner_reply;
+ 
+typedef struct {
+	u8 ddint;
+	u8 scanint;
+	u8 err;
+	u8 cts;
+}sit2_demod_reply;;
+
+typedef struct {
+	u8 ddint;
+	u8 scanint;
+	u8 err;
+	u8 cts;
+	u8 pclint;
+	u8 dlint;
+	u8 berint;
+	u8 uncorint;
+	u8 rsqint_bit5;
+	u8 rsqint_bit6;
+	u8 rsqint_bit7;
+	u8 pcl;
+	u8 dl;
+	u8 ber;
+	u8 uncor;
+	u8 rsqstat_bit5;
+	u8 rsqstat_bit6;
+	u8 rsqstat_bit7;
+	u8 modulation;
+	u32 ts_bit_rate;
+	u32 ts_clk_freq;
+}SIT2_DD_STATUS;
+
+unsigned char sit2_patch_2[] = {
+0x04,0x01,0x00,0x00,0x00,0x00,0x6E,0x22,
+0x05,0x8A,0xC7,0x3F,0x6A,0x43,0x27,0x94,
+0x2A,0xA1,0x65,0x0E,0xAD,0x67,0x7B,0x0D,
+0x05,0x68,0x6B,0xE7,0xC3,0xAD,0xF0,0xDC,
+0x22,0xD7,0xDD,0x95,0x46,0x13,0xD0,0xF8,
+0x05,0x02,0x93,0x0D,0x17,0x9C,0x87,0x95,
+0x2A,0xBB,0xAB,0xDD,0x99,0xD4,0x4A,0x43,
+0x05,0x56,0x55,0x15,0x28,0xD5,0x94,0xD3,
+0x22,0x6B,0x94,0x09,0x42,0xE6,0x53,0xDE,
+0x05,0xD2,0xEA,0xAF,0x7F,0xF7,0x2A,0xC0,
+0x22,0xC9,0x77,0xE4,0x73,0x56,0x8C,0xF3,
+0x05,0x69,0xF9,0xE7,0x8B,0x9B,0xFF,0x89,
+0x27,0x96,0x91,0x8E,0x83,0x82,0xD5,0x5F,
+0x27,0x1E,0x9A,0x0A,0x10,0x48,0x01,0x85,
+0x2F,0xB4,0x9F,0xD3,0x54,0xEE,0x7E,0xEB,
+0x2F,0x08,0x68,0xC9,0x51,0xCA,0x35,0x14,
+0x27,0x83,0x90,0xA8,0xC1,0x7C,0xDE,0xD2,
+0x27,0x0D,0x5C,0xBF,0xCD,0xA0,0xCC,0x56,
+0x27,0xF8,0xBF,0x57,0x09,0x9E,0xCC,0x1B,
+0x27,0x67,0x1C,0x92,0x39,0xB0,0xD3,0x77,
+0x2F,0xEB,0x40,0xFF,0xFC,0x5D,0xC9,0x46,
+0x2F,0x81,0x3B,0x65,0x96,0xC1,0xC9,0x72,
+0x27,0x0D,0x5F,0x5B,0xD9,0xC1,0x1C,0xB4,
+0x27,0x6B,0xCA,0xF6,0x84,0xFC,0xEE,0xCE,
+0x2F,0xE8,0x3C,0x26,0xCF,0x1C,0xF6,0xBF,
+0x27,0x9F,0x7C,0x60,0xF8,0xF6,0x1F,0x6F,
+0x27,0xFB,0x6C,0xE2,0xF9,0xC7,0xA5,0x30,
+0x2F,0x31,0x78,0xFB,0xAD,0xFF,0xD1,0x7C,
+0x27,0x2C,0x79,0x51,0x3A,0x9E,0x70,0xB9,
+0x27,0x9C,0x91,0xBD,0xE7,0x23,0x1F,0x5E,
+0x27,0x0F,0x7D,0x82,0x09,0xD1,0xEF,0x48,
+0x2F,0x48,0x0B,0x3E,0x5B,0x58,0x4A,0xA3,
+0x27,0x1E,0xB3,0x41,0x81,0x59,0xDD,0x0F,
+0x2F,0xEC,0xA8,0x54,0x44,0x49,0x9C,0xF9,
+0x27,0xE4,0xAE,0x01,0xD1,0xDD,0x22,0x14,
+0x2F,0x3F,0xA9,0x3A,0x88,0xA8,0x7D,0xC5,
+0x27,0x04,0x3B,0x2A,0xD8,0x30,0x66,0xE9,
+0x27,0x58,0x6F,0x93,0xB2,0x4F,0x59,0x19,
+0x27,0x58,0xCC,0xDF,0x44,0xD0,0x58,0x89,
+0x2F,0x67,0x72,0xC0,0x15,0x4C,0x54,0x16,
+0x2F,0x5A,0xFE,0x0F,0x15,0x6C,0x27,0xC9,
+0x2F,0x23,0xC6,0x71,0xA7,0x70,0x24,0xE2,
+0x2F,0xDD,0xB0,0x33,0x71,0x6E,0x50,0x46,
+0x2F,0x32,0x95,0x38,0xD7,0x1E,0xD8,0x0B,
+0x2F,0x74,0x49,0x1B,0x1A,0x90,0x28,0x29,
+0x2F,0xC2,0x8C,0x74,0xA6,0xDB,0x54,0x33,
+0x2F,0x3A,0xE0,0x31,0x10,0x3F,0xC2,0x67,
+0x2F,0x86,0x34,0x8A,0x11,0x2D,0xD7,0x92,
+0x27,0xA7,0xF7,0x3D,0xE3,0x79,0x39,0x0F,
+0x2F,0xA0,0xAF,0xC6,0xD2,0xC7,0xD2,0x6D,
+0x2F,0xBD,0x30,0x5F,0x7B,0x54,0x94,0xB8,
+0x2F,0x0B,0x37,0x94,0xDB,0x7F,0x43,0x07,
+0x27,0xA5,0x7F,0xC4,0xC8,0x91,0xF3,0xC7,
+0x2F,0x5B,0xE5,0x75,0xA4,0x40,0x53,0x47,
+0x2F,0x5E,0x83,0xD0,0x22,0x99,0xB7,0xA6,
+0x2F,0xA5,0x2B,0x44,0x02,0x40,0x3C,0xF4,
+0x27,0x05,0xE0,0x90,0x42,0x6D,0xB6,0x2E,
+0x27,0xA8,0x6F,0x27,0x1B,0xAF,0xEA,0xB1,
+0x2F,0x56,0x9A,0x85,0xB5,0xFE,0x29,0x57,
+0x27,0x9B,0x53,0x9F,0x41,0x62,0x52,0x25,
+0x2F,0x2E,0xB2,0x16,0x14,0x95,0xE5,0xD9,
+0x27,0xD5,0x6C,0xB7,0xA7,0x21,0xE2,0xBB,
+0x27,0x9B,0x07,0x42,0xB7,0xFC,0xF5,0xC6,
+0x2F,0x77,0x36,0x47,0x57,0xF3,0x71,0x06,
+0x27,0xF4,0x25,0x41,0x87,0x5C,0xB6,0x70,
+0x27,0xC9,0x81,0xD3,0x7E,0xF2,0x6B,0x5E,
+0x2F,0xE8,0xD1,0x50,0x1F,0x94,0x4E,0xD0,
+0x27,0xCB,0x2F,0xE2,0x04,0x89,0x4E,0x4F,
+0x27,0xC5,0x09,0x09,0x0D,0x62,0x40,0x84,
+0x2F,0x24,0x4E,0xDA,0xBF,0x65,0x84,0x45,
+0x27,0x70,0x45,0x3B,0x16,0xA0,0xA4,0x92,
+0x2F,0xC6,0xB6,0x61,0x92,0x27,0x50,0x30,
+0x2F,0x79,0x9C,0x38,0xFE,0x72,0xD9,0x17,
+0x27,0x05,0xB5,0x57,0x86,0x73,0x31,0x8B,
+0x2F,0xA0,0x72,0xD1,0xD1,0x0F,0x71,0xAE,
+0x2F,0x58,0xE1,0x15,0x8C,0x41,0xE4,0x14,
+0x2F,0x79,0xE1,0x2F,0x04,0xD6,0xF7,0xE6,
+0x2F,0xDA,0xF1,0x99,0x1A,0x2A,0xFC,0x74,
+0x2F,0x4F,0x0F,0x4A,0xF8,0xDF,0x7E,0x31,
+0x27,0xB7,0x84,0x0E,0xE9,0x83,0xD3,0x1C,
+0x2F,0xC7,0x8B,0x37,0xCA,0xA4,0x99,0x2B,
+0x27,0x55,0xD9,0x0D,0xFC,0xE8,0xB2,0x45,
+0x2F,0xDC,0x96,0xE2,0x33,0xD7,0xD2,0x5A,
+0x27,0x44,0xEF,0xAF,0x34,0x75,0xF1,0xF0,
+0x2F,0x84,0x84,0x91,0x4B,0x0A,0x7B,0xD0,
+0x2F,0xDC,0x67,0x6F,0x5D,0x59,0xC2,0x9F,
+0x27,0xAC,0xF5,0xDB,0x23,0x46,0xFB,0xAF,
+0x27,0x17,0x3F,0x27,0x0C,0x34,0x6B,0x2F,
+0x27,0xCC,0x2F,0xD1,0xCB,0x8C,0xBE,0xD2,
+0x2F,0x2E,0x79,0x26,0xA5,0xEA,0x05,0x49,
+0x27,0x12,0x88,0x17,0x3A,0xD3,0x41,0x7E,
+0x27,0xCE,0xBC,0xFD,0x24,0x72,0xCE,0x77,
+0x27,0x91,0xF9,0x72,0x68,0x83,0xF7,0x5C,
+0x2F,0xFD,0xAC,0xE3,0x8B,0x59,0x4E,0x5D,
+0x2F,0x13,0xB3,0xA0,0xE9,0xDE,0x58,0xBD,
+0x27,0xF7,0x6A,0x2E,0x84,0xA7,0x14,0x48,
+0x27,0x08,0xE6,0xBC,0x96,0xDF,0xF9,0xE3,
+0x27,0x55,0xFF,0x97,0x69,0x40,0x12,0x9B,
+0x27,0x6E,0x73,0x46,0xA7,0xFD,0x24,0x0B,
+0x2F,0xC0,0x34,0x12,0xB9,0x86,0x80,0x99,
+0x2F,0x35,0x88,0xB7,0xE3,0x37,0xF6,0xB9,
+0x2F,0x0A,0x6E,0x26,0x63,0xA2,0x7F,0x73,
+0x27,0xC0,0x93,0x01,0x5A,0xB3,0x76,0x6F,
+0x2F,0x1A,0x12,0x1E,0xA5,0x2F,0x63,0x79,
+0x2F,0xF4,0x0E,0xCF,0xCC,0x5D,0x32,0x73,
+0x2F,0x74,0x3D,0xBC,0x18,0x30,0x6A,0xB0,
+0x27,0x3C,0xB7,0xAC,0xCC,0xB3,0x20,0x56,
+0x2F,0x76,0xAD,0x00,0x52,0xC9,0xA0,0xE1,
+0x27,0x15,0x3B,0xE4,0x7B,0xF6,0x0F,0xE2,
+0x2F,0x5D,0x70,0x35,0xDE,0x4B,0x3E,0x3B,
+0x2F,0x8D,0xE3,0x7B,0xBA,0xF0,0x7D,0xBF,
+0x27,0x35,0xFD,0xD3,0x2B,0x35,0x3B,0x9C,
+0x2F,0x6A,0x9C,0xD5,0x95,0x2C,0x86,0x1C,
+0x27,0x42,0x0C,0x1F,0xEA,0xCD,0xF5,0x97,
+0x27,0x65,0xB1,0x36,0x1D,0xDC,0x55,0x83,
+0x2F,0x88,0x89,0x23,0x65,0x4C,0x98,0xAA,
+0x2F,0x26,0x4F,0x6F,0x74,0xD3,0x93,0xBA,
+0x2F,0x94,0xA1,0x7D,0x61,0x84,0x1B,0xF9,
+0x27,0x8D,0xD3,0x85,0x70,0xE0,0xFC,0xF7,
+0x27,0x58,0xE6,0xAA,0x6C,0x2C,0x8E,0x13,
+0x2F,0x95,0xC3,0x8D,0xC0,0x8D,0x14,0x5E,
+0x2F,0xE2,0x71,0x93,0x92,0xF0,0xE7,0x4C,
+0x2F,0x2E,0x2D,0x14,0x4B,0x64,0x90,0x66,
+0x2F,0x9A,0x34,0x47,0xFA,0x2F,0x95,0xE9,
+0x2F,0xEE,0x30,0x62,0xE2,0x6C,0xED,0x87,
+0x2F,0xBC,0x86,0xDB,0xD5,0xB6,0x3F,0x24,
+0x27,0xC7,0x6B,0x9A,0xAB,0x63,0x7F,0x17,
+0x2F,0x1E,0xD2,0x78,0x27,0xE1,0x69,0x2A,
+0x27,0x64,0x69,0x37,0x1C,0x8D,0xBD,0x13,
+0x27,0x92,0x1B,0x30,0x48,0x10,0xC7,0x86,
+0x2F,0x29,0x03,0x95,0x97,0x23,0x1E,0x1C,
+0x27,0xD5,0x24,0x62,0x80,0xDC,0xE9,0x40,
+0x27,0xF1,0xAA,0x89,0x7A,0xFF,0xD4,0x85,
+0x2F,0x15,0x9B,0x5D,0x89,0xC8,0x9E,0x7A,
+0x2F,0x7A,0xA5,0xDD,0x4C,0xFC,0x33,0x98,
+0x2F,0x5D,0x3E,0xD4,0x38,0x49,0xB5,0x09,
+0x2F,0x8E,0xD6,0x1C,0x1B,0x9C,0x20,0x75,
+0x27,0x04,0x27,0x8B,0x02,0x5E,0x0F,0x83,
+0x27,0x4A,0xDB,0xDC,0xFF,0x1F,0xA8,0x7C,
+0x2F,0xEC,0x32,0x5B,0x7B,0xEB,0xBB,0xA4,
+0x27,0x04,0x64,0x47,0x68,0x0D,0x07,0xFC,
+0x27,0x62,0x0F,0x73,0xF0,0xF5,0x28,0x6C,
+0x27,0x19,0xCD,0x24,0x9B,0x4F,0x6C,0x38,
+0x27,0x06,0x42,0x9F,0xE3,0x8A,0xE8,0xE9,
+0x27,0xD8,0xC8,0xE4,0x90,0x15,0x8A,0xD6,
+0x27,0x1B,0xB3,0xE4,0x21,0x6F,0x56,0xEE,
+0x27,0xCF,0x92,0x4A,0x30,0x12,0x52,0xFE,
+0x27,0x11,0x3B,0x9B,0x78,0x43,0x76,0xF3,
+0x2F,0x11,0x06,0x5B,0xA4,0xCB,0xCD,0x06,
+0x2F,0x5D,0x07,0x26,0xEF,0xCF,0x8F,0x4E,
+0x2F,0xFA,0x47,0xA6,0x98,0x51,0x49,0x24,
+0x27,0x71,0x79,0x55,0x75,0x86,0x8C,0x08,
+0x27,0xE6,0x3F,0xD5,0x2B,0x73,0xE8,0xB4,
+0x2F,0x35,0xE7,0xE5,0xAB,0x21,0xBD,0x4F,
+0x2F,0xF7,0x12,0x32,0x50,0x55,0x17,0x69,
+0x27,0xF8,0x9F,0xF8,0x6F,0x16,0x66,0x76,
+0x27,0x0A,0x27,0x82,0xA0,0xF9,0x32,0xB7,
+0x2F,0x44,0x4B,0x76,0x26,0xD4,0x37,0x89,
+0x27,0x63,0x30,0xE8,0xBF,0x26,0x4E,0xAF,
+0x27,0x38,0xF9,0xFB,0xB8,0x2E,0x3B,0x23,
+0x27,0x4F,0x21,0x3E,0x7C,0x69,0x4D,0x6D,
+0x27,0x22,0xCB,0x6D,0x2B,0xF6,0xF1,0x0B,
+0x2F,0x75,0xCC,0xDD,0xA7,0x2A,0x3A,0x80,
+0x2F,0x6A,0x39,0x70,0x31,0xCC,0xEA,0x93,
+0x27,0x88,0xF1,0x1E,0x87,0x92,0x4A,0xAC,
+0x2F,0x14,0xAD,0x2F,0x55,0x46,0x60,0xAA,
+0x27,0xB0,0x01,0x00,0x2B,0x1C,0x3A,0x41,
+0x27,0xD5,0x6D,0x7C,0x2B,0xD7,0xDD,0xD8,
+0x27,0xFE,0x23,0x37,0xB3,0x10,0xAE,0x31,
+0x27,0xBC,0xAB,0x1A,0xCC,0x7F,0x14,0xE5,
+0x27,0x91,0x77,0x0C,0xDD,0xAB,0x3A,0x50,
+0x27,0x23,0x07,0x2F,0x00,0xC1,0x25,0x10,
+0x27,0xD7,0xFB,0x2D,0xE7,0xFB,0xFC,0x74,
+0x2F,0x82,0xB5,0x2A,0xEA,0x5D,0xD9,0x1A,
+0x27,0x83,0xEA,0xB7,0x9B,0x9C,0x4C,0xAB,
+0x2F,0x33,0x8D,0xD4,0xCA,0x4E,0xBF,0x9A,
+0x2F,0x3A,0x76,0xD6,0xC3,0xB8,0x99,0xA6,
+0x2F,0x13,0x48,0x1B,0x5F,0x2E,0xAC,0x01,
+0x27,0x1C,0xEE,0x4F,0xC3,0x57,0x13,0xFF,
+0x2F,0x47,0xD9,0xD3,0x05,0x19,0x47,0x81,
+0x27,0x4F,0x0C,0x06,0x4D,0x08,0x70,0x2A,
+0x2F,0xB9,0x54,0x46,0xFE,0x6B,0x72,0x90,
+0x27,0x69,0xDA,0xFC,0x92,0x94,0xA8,0x2F,
+0x27,0xB5,0x8A,0xC0,0x20,0xBD,0x70,0xA7,
+0x2F,0x0D,0x52,0xDC,0xFF,0x5A,0x32,0xCC,
+0x27,0x44,0xB1,0x2C,0x10,0x39,0x49,0x38,
+0x27,0x41,0xE7,0x37,0x7A,0x0C,0x30,0x89,
+0x2F,0x1C,0x7F,0x40,0xEA,0xE3,0xA0,0xDE,
+0x27,0xB6,0x5D,0xA1,0x1B,0x7E,0x1A,0xDD,
+0x2F,0x0B,0xC7,0xAF,0xA5,0xDA,0xFE,0xDA,
+0x27,0x33,0x32,0xFF,0x01,0x7D,0x29,0x22,
+0x2F,0x01,0x34,0xE2,0xD2,0x0A,0xAA,0x3F,
+0x27,0x87,0x24,0x77,0x6C,0xE9,0x1E,0xCB,
+0x27,0x92,0x62,0x8D,0x76,0xC2,0x8D,0x44,
+0x2F,0xFA,0xEE,0x3C,0xA9,0x62,0xCC,0x12,
+0x27,0x50,0xBE,0x4C,0xBC,0x8F,0xD4,0x2D,
+0x27,0xCF,0x8A,0x22,0xDD,0x31,0xC2,0x7C,
+0x2F,0xE4,0x95,0x2D,0xB7,0x97,0xEE,0x6B,
+0x2F,0xC5,0x00,0x8E,0xF8,0x31,0x22,0xC3,
+0x27,0x8F,0xD7,0x29,0x24,0xB3,0x25,0x39,
+0x27,0x45,0xD4,0x58,0x2A,0x98,0xA4,0x43,
+0x27,0xEC,0x9B,0xDF,0xBC,0x4F,0x6E,0xD9,
+0x2F,0xBD,0xCB,0xC2,0xCF,0x41,0x70,0xCF,
+0x27,0x43,0x2B,0x1A,0xDB,0x8D,0x63,0x26,
+0x2F,0xD5,0x9B,0xAB,0xC7,0x77,0x75,0x7E,
+0x27,0x1F,0x63,0xBC,0xF3,0x9B,0x9D,0xBE,
+0x2F,0xF4,0x65,0x69,0xA4,0x72,0x23,0xCA,
+0x21,0xFB,0x21,0x43,0x02,0xCB,0x99,0x36,
+0x05,0x00,0x47,0x01,0xF1,0x03,0x5F,0x8D,
+0x22,0x1E,0xC2,0x9B,0x4A,0x01,0xD1,0xCF,
+0x05,0x90,0x38,0xFC,0x96,0xC0,0x98,0x96,
+0x2C,0x24,0x41,0x26,0x01,0xA4,0x24,0x12,
+0x05,0xE0,0xED,0x23,0xAE,0x82,0xA9,0xE6,
+0x22,0xE5,0xB8,0xB5,0x95,0xAD,0x92,0xC6,
+0x05,0xCD,0xF6,0x39,0xB9,0x0B,0x09,0x76,
+0x22,0x1C,0x35,0x18,0x64,0xBB,0xC6,0x25,
+0x05,0x96,0xE2,0x75,0x4B,0x49,0x53,0x10,
+0x29,0x01,0x91,0x8E,0xCD,0x99,0x6B,0xAA,
+0x05,0x5F,0x76,0x90,0x4A,0x0F,0x04,0xEC,
+0x2B,0xF6,0x1E,0x90,0x2E,0xD8,0xD2,0x31,
+0x05,0xEE,0x77,0xFB,0x8B,0xA0,0x3D,0x9A,
+0x2C,0x85,0x2D,0xEF,0xDF,0x9E,0x35,0x69,
+0x05,0x57,0x62,0x2B,0x64,0x4A,0x23,0xC4,
+0x2F,0xAF,0x1B,0xB9,0x10,0x36,0x14,0xA2,
+0x29,0x38,0xE6,0x6C,0x1D,0x93,0x97,0xE7,
+0x05,0xEA,0xBC,0x84,0x3E,0x33,0x11,0xF3,
+0x2C,0x28,0x56,0x10,0x64,0x06,0x09,0x44,
+0x05,0xC9,0x29,0xB7,0x15,0xB0,0x97,0xD2,
+0x2C,0x8A,0xD4,0xE3,0x63,0x40,0xB3,0xAE,
+0x05,0xE3,0x86,0x83,0xD1,0xCE,0xA1,0xBE,
+0x2C,0x25,0x70,0x82,0x31,0x67,0x72,0x81,
+0x05,0xBC,0x44,0xFD,0xBF,0x1A,0xBC,0x26,
+0x2C,0x68,0x88,0x8F,0xDB,0xAE,0xF3,0xA4,
+0x05,0x31,0x20,0xF3,0x9A,0x08,0x16,0x96,
+0x2C,0xF4,0x7C,0xF2,0xF6,0xB2,0xAB,0xA3,
+0x05,0x1D,0xF8,0x32,0x13,0xF2,0xF2,0xBF,
+0x24,0xEE,0x67,0xEB,0xFF,0x9A,0x2D,0x76,
+0x05,0x20,0xB2,0x8A,0xE8,0x43,0x18,0x95,
+0x2F,0x3B,0x24,0xC3,0x10,0xB4,0x36,0x1C,
+0x25,0xE4,0xC4,0x15,0xFA,0x0F,0x0F,0x78,
+0x05,0x38,0x26,0x57,0x52,0xAF,0xD6,0xEE,
+0x24,0x5B,0x5E,0xC1,0xB3,0x2C,0x2F,0x76,
+0x05,0xEA,0x00,0x49,0xE7,0x46,0x05,0xAC,
+0x2F,0xBD,0x30,0x0D,0xB2,0x01,0x83,0x5E,
+0x21,0x94,0xA4,0xBD,0x13,0x18,0x3F,0xC0,
+0x05,0x1B,0x1A,0xE7,0xAB,0x7F,0xC3,0xFC,
+0x2C,0x88,0x2C,0xDF,0x7F,0xEE,0xCB,0x35,
+0x05,0xE7,0x50,0x23,0x65,0x4C,0x0F,0x54,
+0x27,0x1B,0x2A,0x66,0x07,0x17,0x03,0x3F,
+0x27,0xF6,0x0E,0x86,0x49,0xAB,0x49,0xA3,
+0x2A,0x0A,0x7D,0x1C,0x45,0x6E,0xD4,0xE4,
+0x05,0x1B,0x74,0xC9,0x7E,0x31,0xA7,0x0D,
+0x2C,0x8B,0xCD,0xC2,0x2F,0x3C,0x83,0x07,
+0x05,0x7A,0xB6,0x63,0xDB,0x9C,0xDB,0x43,
+0x2C,0x2C,0xE4,0x9B,0x16,0xF4,0x60,0xCE,
+0x05,0x5D,0x30,0x03,0x36,0x17,0x0E,0x09,
+0x2F,0x65,0x10,0xCD,0x8D,0xD9,0xDD,0x57,
+0x2F,0x0C,0x68,0x12,0x88,0x55,0xF0,0xE3,
+0x27,0xC5,0x28,0xF7,0xD8,0x4A,0x67,0x57,
+0x27,0x90,0x5B,0x0C,0x58,0xBE,0x9A,0x96,
+0x2F,0x3A,0x6C,0x51,0x6B,0x3B,0xC8,0xBA,
+0x2F,0x41,0xAB,0x98,0x0E,0x66,0x9D,0xC8,
+0x27,0x67,0x3B,0x7A,0xFD,0xF6,0xA5,0x02,
+0x2F,0xBF,0xB7,0x7E,0xEE,0xD6,0x18,0x5F,
+0x2F,0x3E,0x2A,0x8C,0xEC,0x38,0x54,0xF6,
+0x27,0x6C,0xAE,0x30,0x7E,0xF7,0x41,0x13,
+0x27,0x73,0x87,0x9B,0xD8,0x9F,0x1C,0xF8,
+0x2F,0xDB,0x2F,0xEE,0xDD,0x80,0x84,0xF7,
+0x2F,0x32,0xC1,0x02,0xCC,0xF4,0x96,0x41,
+0x27,0x26,0x88,0xD2,0xA3,0x41,0x29,0x4A,
+0x2F,0xDA,0x87,0xE5,0x99,0x02,0xE2,0x21,
+0x27,0xED,0xBA,0x64,0x4D,0xEF,0xFD,0xE6,
+0x2F,0xD4,0x60,0x17,0xC8,0x04,0xAF,0xCE,
+0x2F,0xF9,0xDB,0x5A,0xEC,0xFB,0x6D,0x73,
+0x2F,0xE5,0x20,0x60,0x25,0x5D,0x0A,0x90,
+0x2F,0xDF,0x7A,0xD8,0x74,0x51,0x63,0x20,
+0x27,0x9D,0x71,0xF5,0x77,0xA7,0xE2,0x6E,
+0x2F,0x28,0x11,0xD7,0x1C,0x7B,0x7E,0xDF,
+0x27,0xA0,0x54,0x05,0x46,0xB0,0x3D,0x01,
+0x27,0x90,0xD0,0x52,0xB5,0x7D,0xF1,0x11,
+0x27,0x9B,0x7C,0x31,0x2F,0xC7,0x45,0x75,
+0x2F,0xFB,0xCD,0x19,0x27,0x36,0xB0,0xFD,
+0x2F,0x9C,0xB2,0x3D,0x03,0x70,0xC5,0x8C,
+0x2F,0xEB,0x5A,0xB4,0xAA,0x2E,0x35,0xBF,
+0x27,0x0C,0x95,0x4D,0x2D,0xA6,0x1D,0x3C,
+0x27,0xC2,0xD4,0x96,0x87,0x93,0xDC,0x23,
+0x2F,0x4B,0x9F,0xEB,0x76,0xDE,0x30,0x5B,
+0x2F,0x41,0xCF,0x94,0x5E,0x42,0xA4,0x17,
+0x27,0xF8,0xF8,0x9F,0x37,0xA4,0x3E,0x4B,
+0x27,0x70,0xDC,0xB0,0x6F,0x82,0x67,0xFB,
+0x2F,0xA1,0x83,0xDB,0xB5,0x58,0x74,0x59,
+0x2F,0xA8,0x58,0xF7,0x19,0xCA,0x3B,0x48,
+0x2F,0x45,0x4E,0x36,0x74,0x58,0x8A,0x24,
+0x27,0x1F,0x50,0x3B,0xD1,0xBC,0x78,0xA4,
+0x2F,0xDB,0xFC,0x10,0x68,0x60,0x8B,0xA1,
+0x2F,0x63,0xB7,0xE7,0x72,0xED,0x3A,0xE0,
+0x27,0x6A,0x9E,0x2E,0x85,0x82,0x8F,0x31,
+0x27,0x6B,0x68,0x70,0x37,0xEA,0xD6,0xFA,
+0x27,0x2C,0x7F,0x43,0x4C,0x7C,0x8F,0x15,
+0x27,0xB6,0x35,0x88,0xB2,0x37,0xDF,0x38,
+0x27,0x85,0x44,0xA7,0x21,0xBC,0xE6,0x48,
+0x27,0x17,0x1D,0xD8,0xBE,0x7A,0x2D,0xE6,
+0x27,0x29,0x30,0x91,0x52,0x5B,0xBF,0x3D,
+0x2F,0xB0,0x8E,0xC4,0xE5,0xA5,0xA6,0x58,
+0x27,0xB3,0x55,0x7F,0x22,0xE2,0xEB,0xC8,
+0x27,0x7C,0xD6,0x09,0x3D,0x3F,0xED,0x55,
+0x2F,0x06,0xA9,0x47,0x47,0x9B,0xF7,0x86,
+0x2F,0x29,0x14,0xAB,0x3D,0x85,0x44,0x96,
+0x27,0x95,0x45,0x65,0x1B,0xAA,0xA9,0x8B,
+0x2F,0x2C,0x2C,0xF9,0xC6,0xFB,0xDB,0x97,
+0x27,0xB4,0x0E,0x69,0xDB,0xE7,0x43,0x22,
+0x27,0xF7,0x92,0x23,0x72,0x58,0xF1,0x53,
+0x27,0xD3,0x07,0xB0,0x2A,0xCD,0x94,0xA5,
+0x2F,0x05,0xE7,0xFA,0xC3,0xCC,0xC1,0x8B,
+0x2F,0x27,0x4B,0x0B,0xD2,0xAF,0x27,0x78,
+0x27,0x1B,0x7A,0x0C,0xED,0x82,0xB6,0xE0,
+0x2F,0x26,0xC1,0x71,0xA4,0xB4,0xE4,0x15,
+0x27,0x04,0xE1,0x94,0xBF,0xDA,0xB9,0xCF,
+0x27,0xF2,0x34,0x48,0x65,0x1D,0x67,0x5C,
+0x27,0x53,0x51,0xBF,0xFD,0x64,0x91,0xE8,
+0x27,0xB8,0x90,0xB6,0xCC,0xA1,0x50,0x9D,
+0x27,0x1B,0xEE,0xCA,0x15,0x33,0x36,0x6D,
+0x27,0x21,0x42,0xBB,0xAC,0x74,0x2C,0x82,
+0x27,0xAF,0xC2,0xBB,0x5B,0xE3,0x08,0xC4,
+0x27,0x5F,0xC5,0x1D,0x63,0xDC,0xF4,0x71,
+0x2F,0x70,0x43,0x4D,0x1E,0x6F,0xBA,0x87,
+0x2F,0x6E,0x07,0x53,0xAF,0xFF,0x72,0x0F,
+0x27,0x37,0x88,0x55,0x0F,0x90,0xD6,0xCA,
+0x2F,0xFE,0xF6,0xC6,0x5E,0xD5,0x99,0xC2,
+0x2F,0x48,0x03,0x89,0xBF,0xE3,0xE9,0x3D,
+0x2F,0xD0,0x29,0x0E,0x98,0xCB,0x9E,0x6C,
+0x2F,0x8A,0xBE,0x61,0x43,0x90,0x3A,0xB3,
+0x27,0x10,0x72,0xBD,0xA5,0xD9,0x52,0xDD,
+0x2F,0xF5,0x02,0x29,0x1A,0x3E,0x44,0x46,
+0x2F,0x64,0x6B,0xA4,0x87,0xED,0x76,0xBF,
+0x27,0x32,0xB0,0xC0,0xFD,0xE7,0x51,0xD9,
+0x27,0x64,0x46,0x90,0x4C,0xF2,0xAE,0x0A,
+0x27,0xE2,0x12,0x21,0x0D,0x5A,0xDD,0x86,
+0x27,0x9E,0x3B,0x96,0xF9,0xC9,0xCC,0xBC,
+0x27,0xFF,0x93,0x7C,0x2A,0x18,0xAB,0xAE,
+0x27,0xD2,0xA5,0x9E,0x97,0x0B,0xC6,0x8F,
+0x27,0xFB,0x44,0xF1,0x18,0x19,0x6B,0xD9,
+0x2F,0xC9,0xB0,0x3A,0x5E,0xE5,0xAB,0x8B,
+0x27,0x50,0x47,0x73,0xD2,0xE8,0x4E,0xD1,
+0x27,0x59,0xE9,0x8A,0xF0,0xAE,0x40,0xA8,
+0x2F,0xC0,0x6C,0x9A,0x0B,0x0C,0x40,0x68,
+0x27,0xB3,0x32,0x2D,0x0C,0x02,0x62,0x43,
+0x27,0x27,0x22,0x08,0x96,0x8A,0x72,0x19,
+0x27,0x91,0xA9,0x39,0x8E,0x2D,0x4E,0x61,
+0x2F,0xCD,0x85,0x01,0x22,0x5B,0x48,0x00,
+0x27,0xF8,0x4B,0x4F,0x3A,0xD5,0x08,0x09,
+0x27,0x85,0x83,0x53,0x21,0xB5,0x46,0xCF,
+0x2F,0xF7,0x4C,0xC7,0x73,0x41,0xDF,0x33,
+0x27,0x87,0x3B,0x21,0x76,0xA0,0x09,0x85,
+0x27,0x7F,0xD4,0xCB,0xA7,0x34,0xFD,0xF8,
+0x2F,0x0D,0x3A,0x59,0xB1,0xAF,0xA2,0x4E,
+0x27,0xAF,0x8F,0xE1,0xC6,0x64,0xCB,0x55,
+0x27,0x60,0x05,0x04,0xBB,0xAC,0x0D,0xAD,
+0x27,0xEA,0x05,0x76,0xC9,0x3B,0xD8,0x9C,
+0x27,0xF9,0x88,0x23,0x54,0x32,0x54,0x31,
+0x2F,0x94,0xE8,0xA9,0x69,0x06,0x83,0x7C,
+0x2F,0xC7,0x5C,0xAD,0xD8,0x8E,0x36,0xE3,
+0x27,0xF1,0x73,0x1C,0x3F,0x60,0x85,0x39,
+0x2F,0xFB,0x52,0xB5,0xFC,0xBC,0x34,0xA7,
+0x27,0x5F,0xDC,0x64,0x1A,0x8C,0xB8,0x33,
+0x27,0xF2,0x62,0x65,0x41,0xBB,0x1D,0x63,
+0x27,0x92,0x48,0x82,0x63,0xF8,0x54,0xE1,
+0x2F,0x29,0x16,0x18,0xF7,0x3B,0x7D,0x49,
+0x2F,0x68,0xD9,0x9B,0x3D,0x94,0xFC,0xA2,
+0x27,0xD5,0x46,0xDB,0x5B,0xAA,0x0B,0xC1,
+0x2F,0x6A,0x2A,0xF3,0xE9,0x15,0x59,0x4D,
+0x2F,0xC2,0xE7,0x42,0x01,0xE9,0x8E,0x7B,
+0x27,0x1C,0xDA,0x3F,0x17,0x22,0xC5,0x52,
+0x27,0xBF,0x51,0xA8,0xCE,0x7E,0xD7,0xBC,
+0x27,0x4B,0x17,0xFB,0x3E,0x7B,0x39,0x00,
+0x27,0x83,0xED,0xD1,0x40,0x8F,0x70,0xA3,
+0x27,0xEF,0xAF,0xB9,0x7F,0xDB,0x0F,0x7A,
+0x2F,0x25,0x2F,0x05,0x66,0xAE,0x2D,0x06,
+0x27,0x11,0xEE,0xC4,0x3E,0xD4,0x52,0x73,
+0x2F,0xE5,0xC9,0x0E,0xF2,0x72,0xD6,0xFE,
+0x2F,0x47,0x48,0x18,0x15,0x49,0x2D,0xC3,
+0x27,0xD7,0xF5,0x6E,0xA6,0x5F,0x5E,0xD9,
+0x2F,0x29,0x96,0x2A,0x30,0x27,0xE6,0x42,
+0x2F,0x22,0x8E,0xAD,0x79,0x66,0x87,0x96,
+0x2F,0xF2,0x99,0xEA,0x6B,0x01,0x99,0x8E,
+0x2F,0xAB,0xBC,0x18,0xE3,0x20,0xBD,0xC6,
+0x27,0xBB,0x24,0x79,0x72,0x20,0xA1,0xF6,
+0x2F,0xFE,0x07,0xF4,0x26,0x36,0x89,0x5F,
+0x2F,0x81,0x5A,0xB8,0xE8,0x27,0x54,0xDF,
+0x2F,0xDE,0x90,0xAF,0xCC,0xBE,0x3F,0x5B,
+0x2F,0x43,0x7F,0x3B,0x27,0x04,0x5C,0xD1,
+0x2F,0xE2,0x0F,0xA9,0x80,0xB9,0x68,0xC5,
+0x27,0xF4,0x77,0x69,0x74,0x68,0x35,0x36,
+0x2F,0x6B,0x30,0x2E,0xDD,0x1D,0xC7,0x1E,
+0x27,0xD9,0x82,0x48,0x32,0xB7,0xE3,0x5D,
+0x2F,0xD6,0xF8,0xA2,0x8C,0xC5,0x07,0x8F,
+0x2F,0x5B,0xB2,0xB2,0xAC,0x29,0x98,0x21,
+0x2F,0x8F,0x8C,0x75,0xEB,0x4B,0x88,0xE6,
+0x2F,0x28,0x61,0x8F,0x69,0x49,0xB5,0xCA,
+0x2F,0xCF,0xA0,0x81,0xFB,0xBB,0x46,0x7F,
+0x27,0x55,0x09,0x20,0x20,0x95,0x87,0x8B,
+0x27,0xE7,0x4F,0x59,0x55,0x6E,0xD3,0x98,
+0x2F,0x35,0x4B,0x2D,0x77,0xE3,0xFF,0xA0,
+0x27,0x5B,0x3E,0x3D,0xF5,0x24,0x33,0x56,
+0x27,0xF1,0xBF,0xDC,0x50,0x06,0x98,0x8C,
+0x2F,0x02,0x44,0x8A,0x82,0x53,0x09,0x80,
+0x2F,0xA7,0xEA,0x80,0x4D,0x2D,0x8F,0xE5,
+0x2F,0xD0,0x7A,0xCA,0xE6,0xAD,0xF0,0x7A,
+0x2F,0x96,0xBE,0xD8,0xF8,0x6E,0x77,0x59,
+0x2F,0x60,0xFD,0x93,0x86,0x36,0xD0,0x09,
+0x27,0x4C,0xFC,0xF6,0x96,0xC5,0xA4,0x2B,
+0x2F,0xDC,0x16,0xBE,0x99,0x7B,0xB2,0xAA,
+0x2F,0xC4,0x6D,0xD8,0x5F,0xC8,0xC7,0x98,
+0x2F,0x11,0x1F,0x0E,0x83,0x55,0x48,0x7D,
+0x27,0x43,0x9D,0xB6,0x86,0x33,0xBC,0xC9,
+0x2F,0x02,0xFF,0x83,0x0F,0xC3,0xE5,0xD3,
+0x27,0x29,0x2E,0xE3,0xCD,0xB5,0xD5,0xDC,
+0x2F,0xF9,0x02,0xE6,0xE6,0xEF,0x25,0x3E,
+0x27,0x57,0xDF,0xD7,0xE6,0x33,0xC5,0x7A,
+0x2F,0xB3,0x08,0x1C,0x71,0x55,0xA4,0xB7,
+0x2F,0xBB,0xC7,0x62,0x6D,0x6C,0x22,0x43,
+0x27,0xD5,0xD6,0xF5,0x72,0x87,0x59,0x2B,
+0x27,0xB9,0xD9,0x0D,0x75,0x60,0x56,0x65,
+0x27,0x49,0x1B,0x3A,0x5B,0xE3,0x9A,0x2A,
+0x27,0x87,0xDA,0xC8,0xB7,0x09,0x1F,0xCD,
+0x2F,0x18,0x67,0x96,0x32,0xCC,0x50,0x24,
+0x27,0x00,0x6B,0x09,0x31,0x52,0x7F,0xB1,
+0x2F,0x87,0x39,0x40,0xA1,0x5E,0xB7,0xE1,
+0x27,0xD3,0x6C,0x79,0xCC,0x17,0xC5,0x92,
+0x27,0xAE,0xE2,0xC7,0xAA,0xAF,0x45,0x81,
+0x2F,0xEA,0x4E,0xA6,0x4A,0x3B,0xC3,0x30,
+0x2F,0x07,0x44,0x02,0xFB,0xD4,0x84,0xA7,
+0x27,0xA4,0x47,0xC8,0x5C,0x71,0x7E,0x03,
+0x27,0xA6,0x46,0x52,0xA2,0x1C,0xC1,0x6A,
+0x2F,0x76,0xB2,0xC6,0x8E,0xA5,0x5E,0xEE,
+0x2F,0x22,0x87,0x42,0x3D,0x8B,0x75,0x5F,
+0x2F,0x82,0x23,0x4C,0xC2,0x2E,0x4A,0x53,
+0x27,0xB8,0x31,0x37,0x88,0x5D,0xFD,0xFF,
+0x27,0x00,0x19,0x13,0x34,0x78,0xFD,0xD5,
+0x2F,0xCE,0xD5,0xB1,0x21,0x15,0xE0,0xC4,
+0x2F,0xB6,0x80,0x3A,0x99,0x00,0x7E,0x73,
+0x27,0xC1,0x15,0x90,0x40,0xDA,0xB6,0x28,
+0x2F,0x1C,0x1B,0x6A,0x64,0x0B,0x14,0x39,
+0x2F,0xC6,0x86,0x8D,0x1E,0xBA,0x2E,0x1E,
+0x2F,0xFC,0xC2,0x4C,0x8D,0x34,0x18,0x84,
+0x27,0xEF,0xC4,0xF3,0xDE,0x04,0x51,0xD1,
+0x27,0x56,0xAA,0x3A,0xB5,0x13,0x6C,0x0F,
+0x27,0x01,0x04,0xA6,0xF3,0x29,0xF6,0x66,
+0x2F,0x7F,0x20,0xEE,0x87,0xAB,0x72,0x93,
+0x2F,0x3C,0xD1,0x9E,0x36,0x89,0xCC,0xAD,
+0x2F,0x84,0x31,0xEB,0x29,0x48,0x32,0x35,
+0x27,0xC8,0x02,0x2E,0xE6,0x67,0xD2,0x60,
+0x2F,0x0C,0x50,0x05,0x25,0x3F,0x19,0x65,
+0x27,0xF6,0xEE,0x88,0x9F,0xCF,0x32,0x9B,
+0x2F,0xE1,0x80,0x8D,0xB4,0xF3,0x83,0x6C,
+0x27,0x5F,0x7E,0xBF,0x7B,0x15,0x97,0xD8,
+0x27,0xFD,0x24,0xB0,0xC4,0xDE,0x16,0xBF,
+0x2F,0x78,0x2E,0x9C,0x9A,0xC3,0xF5,0x18,
+0x27,0x99,0x52,0x62,0x0C,0x7B,0x8D,0x37,
+0x2F,0x6B,0x7C,0x7F,0x5C,0x95,0x30,0x44,
+0x2F,0xAC,0xF8,0xBE,0xB3,0x6D,0x86,0x49,
+0x27,0x37,0x27,0xED,0xB1,0x90,0xD1,0x99,
+0x2F,0xFD,0xC5,0xB6,0xC7,0x7A,0x7C,0x54,
+0x27,0xD9,0xAB,0x8D,0x01,0xE7,0xD0,0x3F,
+0x27,0x1D,0x86,0x1E,0x11,0x09,0xEF,0x28,
+0x27,0x9F,0x63,0x69,0x6E,0xF0,0x5E,0x2B,
+0x2F,0xE3,0x93,0x6A,0xF3,0x25,0x6B,0xDC,
+0x2F,0x4F,0xE2,0x80,0xE7,0xB6,0x43,0x5D,
+0x27,0x00,0x86,0x12,0x17,0x66,0x5D,0x19,
+0x2F,0xAE,0xD5,0x79,0xC0,0x0A,0xB0,0xC5,
+0x27,0x0F,0x0D,0x3C,0x3D,0x49,0x9D,0xDD,
+0x2F,0x55,0x19,0x8A,0x50,0x9B,0x22,0x1B,
+0x2F,0x26,0xE8,0xFA,0xDE,0x56,0x39,0x98,
+0x27,0x70,0xAB,0x61,0x60,0xA4,0x9C,0x01,
+0x2F,0x2B,0x11,0x62,0x10,0xE9,0xEC,0x37,
+0x2F,0x4E,0x84,0x47,0x7D,0x0D,0x41,0x69,
+0x2F,0xF0,0x89,0x8F,0x01,0x46,0xBD,0x2D,
+0x2F,0x68,0xD0,0xA7,0x11,0x67,0x9B,0xB2,
+0x27,0x43,0xC7,0x2C,0xB2,0x11,0x50,0x6D,
+0x2F,0x3F,0x7B,0x81,0xA1,0xF3,0xEA,0x57,
+0x2F,0xF2,0x18,0xF2,0x0B,0x88,0x8A,0x14,
+0x2F,0x42,0x61,0xC6,0xDC,0x42,0x38,0x1D,
+0x2F,0xA8,0x51,0x25,0x14,0xF3,0x34,0x65,
+0x2F,0x1C,0x0C,0xE4,0x92,0x2F,0x23,0x9A,
+0x27,0x43,0x8E,0xBD,0xDA,0x0A,0xB4,0x06,
+0x2F,0xAF,0xC7,0x39,0x9E,0x41,0xD2,0x38,
+0x2F,0x30,0xA1,0x61,0xA5,0xAC,0xDC,0x0F,
+0x2F,0xCB,0xDB,0x55,0x31,0xAD,0xE0,0xAB,
+0x27,0x82,0x2C,0x7F,0x5E,0x4B,0x2E,0xB5,
+0x2F,0x8E,0xD3,0x65,0x63,0x14,0x8D,0x83,
+0x27,0x1B,0x59,0x08,0x1E,0xBE,0x74,0xA2,
+0x2F,0x16,0x24,0x28,0x4F,0x6B,0x4C,0x68,
+0x27,0x7A,0xFB,0x7E,0xE2,0x66,0x9B,0x26,
+0x27,0x22,0x27,0x25,0xA0,0x06,0x2C,0x0F,
+0x27,0x21,0xFC,0xED,0x20,0xC6,0x95,0xE1,
+0x27,0x5B,0x38,0x17,0x21,0x1F,0x64,0x3F,
+0x2F,0x35,0xE6,0x01,0xA9,0x7C,0x83,0x9E,
+0x2F,0xBF,0xF6,0x62,0xEC,0xB1,0xE1,0x9B,
+0x27,0x56,0x7E,0xF8,0x1C,0xF6,0xCD,0x51,
+0x27,0xDA,0x0C,0xFE,0x6A,0x8E,0xAF,0xB5,
+0x2F,0x76,0xAE,0x67,0x18,0x40,0xAF,0xAA,
+0x27,0xF3,0xAE,0xFF,0x4B,0x9B,0x16,0xDC,
+0x2F,0x6A,0x3D,0x75,0x25,0x12,0x8A,0x08,
+0x2F,0x6D,0x9D,0xCD,0x34,0x85,0x2C,0x6F,
+0x27,0x7C,0x10,0x02,0x63,0xD0,0xF6,0x1A,
+0x27,0xAC,0x42,0xC2,0x44,0x05,0xB1,0xE5,
+0x2F,0xC8,0xFF,0x44,0xE9,0x3F,0xE6,0x29,
+0x27,0x0C,0xE0,0x32,0x28,0xC9,0x54,0x8C,
+0x2F,0xB3,0xF5,0x8C,0x27,0x19,0xAF,0x65,
+0x2F,0x3A,0xD2,0x3E,0x22,0x33,0x1D,0x0B,
+0x27,0xD1,0x64,0x74,0xE1,0xD5,0xF3,0x88,
+0x27,0xBD,0x15,0xDE,0xE9,0xC3,0x14,0xAB,
+0x27,0xAA,0xB5,0xEF,0xE3,0x37,0xFD,0xE5,
+0x2F,0xDB,0x09,0xF8,0x4F,0x2E,0x30,0xB4,
+0x27,0x90,0x8E,0x40,0xC1,0xB5,0x4D,0x65,
+0x2F,0xA9,0x41,0x15,0x18,0xE5,0xD0,0xB7,
+0x27,0x36,0x11,0xD8,0x9C,0x84,0x5B,0x69,
+0x2F,0x3F,0x1E,0x2F,0xB1,0xFC,0x8C,0x07,
+0x2F,0x51,0xA9,0x92,0x9E,0xC9,0xA1,0x61,
+0x2F,0x4C,0xED,0xE0,0x62,0x6A,0x58,0xBA,
+0x2F,0x21,0x2E,0x5C,0xD8,0xAD,0xFC,0x4B,
+0x27,0x26,0x4D,0xB9,0x8A,0xC4,0xFD,0xA7,
+0x27,0x7B,0x51,0x77,0xB7,0x23,0x4E,0xE1,
+0x2F,0xD8,0x7A,0x9A,0x50,0x28,0xCC,0xC6,
+0x27,0x1A,0x0B,0xBC,0x18,0x37,0xC7,0xBE,
+0x27,0xC2,0x83,0xAA,0xDF,0x79,0xA7,0x5E,
+0x27,0xDA,0x6D,0xD4,0x8B,0xAA,0xF7,0xBE,
+0x2F,0xAF,0x27,0xEB,0x2C,0x25,0xE0,0xA6,
+0x27,0x62,0xC1,0x0F,0x6E,0xFF,0xA0,0x7A,
+0x27,0x72,0xCD,0x65,0xF3,0x6D,0x80,0x9C,
+0x27,0x4F,0x77,0xF5,0x4F,0xCF,0xEE,0x12,
+0x27,0x35,0xA0,0xE5,0xF8,0x21,0x15,0x53,
+0x2F,0x12,0x5B,0x45,0x13,0x55,0x2D,0xAB,
+0x2F,0xE0,0xE7,0xB1,0x21,0x85,0x4E,0xAA,
+0x2F,0xEB,0x6A,0x09,0xB5,0xED,0xAE,0xC1,
+0x2F,0x54,0x98,0xEF,0x44,0xED,0x0F,0xA6,
+0x2F,0x4C,0x6D,0x58,0x06,0x3F,0x3D,0xF3,
+0x27,0xF3,0x57,0x67,0x5B,0x89,0x41,0x44,
+0x2F,0xBE,0x84,0x2A,0x5A,0xAB,0x31,0xA2,
+0x2F,0x5E,0xE6,0x0D,0x03,0xDB,0x74,0xFC,
+0x27,0xDA,0x1C,0x4F,0x52,0x84,0x87,0xD6,
+0x2F,0x00,0xB5,0xB9,0x9C,0x44,0xB5,0xB9,
+0x2F,0xCD,0x34,0x41,0x25,0x85,0xA4,0x2F,
+0x27,0x00,0x20,0x72,0xB2,0x94,0xE5,0xB1,
+0x27,0xC3,0x04,0x82,0x9C,0x47,0x0C,0x02,
+0x27,0xCA,0x9E,0xDF,0x9D,0x3B,0x9D,0x97,
+0x2F,0x01,0x60,0xF6,0x11,0x2C,0xE3,0x8E,
+0x2F,0x14,0xE4,0x52,0xA4,0x26,0x81,0xA7,
+0x2F,0x70,0x30,0x9E,0x2F,0xDC,0xAA,0xEC,
+0x27,0x79,0xC0,0x86,0xB0,0x15,0xF3,0x94,
+0x2F,0x14,0xC7,0x59,0x4D,0x2B,0xD7,0xCF,
+0x2F,0x77,0x50,0x71,0x88,0xF6,0x03,0xAD,
+0x27,0x56,0x52,0x66,0x67,0x5C,0x08,0xB2,
+0x27,0x4C,0xB1,0x49,0x3F,0xC1,0xFF,0x9C,
+0x27,0x6E,0xAB,0xF8,0x72,0xD6,0x14,0x08,
+0x2F,0xED,0xD2,0x84,0x84,0x9A,0x73,0x9B,
+0x27,0x98,0x86,0x52,0xF1,0x33,0x2C,0xC8,
+0x2F,0x07,0x14,0xB5,0x17,0x48,0x90,0xB8,
+0x27,0x59,0x98,0x9D,0x8D,0x8A,0x62,0x40,
+0x27,0xDD,0xC1,0x4E,0x41,0x9C,0xE4,0x8B,
+0x2F,0xAC,0x4D,0x24,0x9C,0xCF,0x6A,0xF4,
+0x2F,0x03,0x0D,0x81,0x6E,0x7F,0x4D,0xFF,
+0x27,0xFF,0x40,0x0C,0xF7,0x82,0x33,0xB0,
+0x27,0x1B,0x8D,0xB7,0xCC,0xF7,0x76,0xE6,
+0x27,0xCD,0x54,0xEF,0x7C,0xDF,0x4D,0x3F,
+0x2F,0xE5,0x53,0xA3,0x04,0xF3,0x13,0x86,
+0x2F,0xCC,0xF6,0x8B,0xA3,0x8F,0x7A,0x4D,
+0x27,0x27,0xBA,0xB3,0x7E,0xD9,0x58,0x26,
+0x27,0x22,0x30,0x8A,0x97,0xAC,0x62,0x9C,
+0x27,0x77,0x7F,0xD3,0xDC,0x8C,0xB1,0x8F,
+0x27,0x69,0xE7,0xD8,0xAD,0xE4,0x71,0xB0,
+0x27,0xA6,0x8F,0x68,0xAB,0xBF,0xC8,0xED,
+0x2F,0xC6,0xDC,0x05,0xB1,0xC0,0x56,0x40,
+0x2F,0x32,0x5E,0x76,0x59,0x01,0xDE,0xFA,
+0x2F,0x96,0xD7,0x48,0xA2,0x39,0xB2,0xA2,
+0x2F,0xE1,0xA2,0x27,0x97,0xC3,0xB9,0x4C,
+0x2F,0x36,0x42,0x51,0xA4,0xF3,0xAF,0xC2,
+0x27,0x27,0x5B,0x5C,0xA4,0xAB,0xEE,0x23,
+0x27,0x6F,0xAB,0x76,0xFF,0x32,0x1D,0x1D,
+0x2F,0x61,0xF2,0x31,0xE7,0xAF,0x2D,0x28,
+0x27,0x5E,0xF6,0x2E,0x07,0xDE,0x7D,0xE1,
+0x27,0x63,0xE3,0x5B,0x91,0xF2,0x3A,0x5D,
+0x2F,0x25,0xA5,0xA9,0xAF,0x90,0x4D,0xC9,
+0x2F,0x08,0xD5,0x96,0xB8,0x31,0x87,0x01,
+0x2F,0xDD,0x90,0x5C,0x99,0x75,0x34,0x7A,
+0x2F,0x4D,0x82,0x22,0x1C,0x28,0x7D,0x71,
+0x2F,0xA2,0xF2,0x56,0xD8,0xB7,0xAC,0x93,
+0x2F,0x1E,0xAA,0x27,0xDA,0x47,0x78,0xA7,
+0x2F,0xE0,0x46,0x14,0x79,0xE4,0xE2,0x15,
+0x2F,0xC2,0xD0,0xE1,0xEE,0x1A,0xD7,0x8C,
+0x27,0x6B,0xDC,0x37,0xCA,0xD1,0xFE,0xF5,
+0x27,0x10,0x37,0x8F,0xC4,0x50,0x08,0xF7,
+0x27,0x16,0x52,0x3A,0xD2,0xB7,0x15,0xF0,
+0x27,0x32,0xA1,0xC7,0xB5,0x4B,0xE0,0x59,
+0x2F,0xB3,0xA2,0x98,0xCE,0x32,0x52,0x19,
+0x2F,0x9D,0x32,0x0D,0xFA,0x0D,0xCB,0xA1,
+0x27,0x6D,0xA4,0x96,0xAC,0x7E,0x79,0xF4,
+0x2F,0xCD,0x5D,0x82,0x45,0xD3,0xE2,0xB4,
+0x27,0xA0,0x8D,0x7B,0xA7,0xC8,0x3D,0x8D,
+0x27,0x23,0x32,0x30,0xC5,0x53,0x61,0xE2,
+0x2F,0xD8,0xF5,0xFE,0x22,0xD9,0xBE,0xA6,
+0x27,0xF3,0xD2,0xAA,0x31,0x14,0x0B,0x28,
+0x2F,0xF6,0x6D,0xD5,0xBA,0xE6,0x1A,0x5F,
+0x2F,0x74,0xA5,0x53,0x26,0x4D,0x7B,0xF6,
+0x27,0x39,0xC9,0xBB,0x85,0x98,0x1B,0xEA,
+0x27,0x29,0xA7,0x91,0x62,0xC4,0x02,0x18,
+0x27,0xCD,0x84,0x91,0xC4,0xC0,0x64,0x14,
+0x2F,0xDF,0x11,0x8C,0xCF,0xD3,0x63,0x6C,
+0x27,0x4A,0x86,0xE2,0xB5,0xD0,0x09,0xF1,
+0x27,0x88,0xFC,0x58,0x07,0x00,0x37,0x3D,
+0x2F,0x54,0xAA,0xED,0x73,0x5B,0x0B,0xBA,
+0x2F,0x48,0x97,0x68,0xC2,0x97,0xA4,0x69,
+0x2F,0xA1,0xE1,0xC2,0x0D,0x35,0x80,0xA8,
+0x27,0x89,0xC3,0xBD,0x8D,0x93,0x69,0x05,
+0x2F,0xF1,0x89,0x5E,0x19,0xB0,0xF7,0xFD,
+0x2F,0x9D,0x6D,0xBA,0xB6,0x0B,0x8D,0x59,
+0x27,0x78,0x80,0x55,0x1C,0xA3,0x16,0x2C,
+0x2F,0x7F,0x8B,0x0D,0x0A,0x4D,0x7C,0x86,
+0x27,0x9F,0x67,0x15,0x1C,0xAB,0x5B,0x58,
+0x2F,0x4B,0x26,0x58,0x7C,0xEE,0xF2,0x1C,
+0x27,0x93,0x3E,0xB9,0xFE,0x74,0xE1,0x12,
+0x27,0x21,0x1F,0x62,0x74,0x57,0x25,0x85,
+0x2F,0x77,0x8D,0x47,0x18,0x11,0xB4,0x65,
+0x27,0xDA,0xED,0x99,0x8A,0x5E,0xF3,0x95,
+0x27,0x09,0x03,0xE2,0x9A,0xF3,0x5F,0xE6,
+0x27,0x32,0xA3,0xB2,0xFB,0x5D,0x8F,0xA2,
+0x27,0xB2,0xB1,0x29,0xFE,0x32,0x3D,0x53,
+0x27,0x10,0xA8,0xB2,0x6A,0xED,0xC6,0xB7,
+0x2F,0xBA,0x14,0x8E,0x56,0x46,0xE5,0xA2,
+0x2F,0x91,0x4A,0xD9,0xD8,0xD1,0xEB,0x01,
+0x2F,0x95,0x8D,0x7D,0xDE,0xAC,0xD4,0x34,
+0x2F,0x09,0x3B,0xB1,0x4D,0xF0,0x93,0xA7,
+0x27,0xC4,0x95,0x54,0xF8,0xB6,0x4F,0xAB,
+0x27,0x7C,0xE2,0x27,0x33,0xB2,0x6B,0x7E,
+0x27,0x40,0x96,0x47,0x2C,0xDB,0xB3,0xBB,
+0x27,0x69,0xB0,0x44,0xD1,0x85,0x10,0x05,
+0x27,0x0A,0xF4,0x3E,0x0B,0x45,0xE6,0xBA,
+0x27,0xFD,0xA8,0x9A,0x00,0x02,0xED,0x46,
+0x27,0x4C,0xBB,0x7D,0x08,0x2F,0x28,0x5E,
+0x2F,0x2D,0x39,0xAA,0x6C,0x49,0x76,0x40,
+0x27,0xA4,0x3A,0x2B,0xEC,0x17,0x6E,0x0D,
+0x2F,0xB0,0xE3,0xDF,0x5B,0x49,0xE5,0x0B,
+0x2F,0x0F,0x1F,0x17,0x4E,0x1A,0xC1,0xD5,
+0x2F,0x8E,0x19,0x62,0xAF,0xC7,0xB2,0xB0,
+0x2F,0xA4,0x5E,0x37,0xAC,0x58,0xBD,0xA7,
+0x2F,0xDB,0x67,0x0E,0xAB,0xAB,0x27,0x83,
+0x2F,0x09,0xCE,0xF9,0x58,0x7A,0xCD,0x1C,
+0x27,0xE6,0xFA,0x28,0xE4,0x4D,0x21,0xBA,
+0x27,0xF7,0x6B,0x4A,0x20,0xDF,0xC4,0xA9,
+0x27,0x8A,0xF6,0x00,0x96,0x84,0x66,0x60,
+0x27,0x2B,0x75,0xB7,0x19,0xBA,0x17,0x00,
+0x2F,0xA7,0x02,0x99,0xB7,0xE3,0x57,0xAA,
+0x27,0xED,0x4F,0x43,0xF2,0x0B,0xC4,0xC9,
+0x27,0x49,0xC1,0xE9,0x2E,0x1D,0x07,0x10,
+0x2F,0x8F,0xFA,0x64,0x87,0x02,0xDB,0x74,
+0x2F,0x5D,0x6D,0x92,0x10,0xA6,0x87,0x64,
+0x2F,0xFD,0x36,0x25,0xC4,0xD6,0xE5,0x57,
+0x2F,0x27,0x2C,0x18,0x75,0xAF,0x76,0x2A,
+0x2F,0x9B,0x34,0xB9,0xB2,0x77,0x4D,0xD6,
+0x27,0x4D,0x09,0xC3,0xFD,0x1A,0xEB,0xF0,
+0x27,0xBC,0xF6,0x05,0xC6,0x34,0x37,0x6A,
+0x2F,0x83,0x66,0x8B,0x2B,0x9D,0x57,0x71,
+0x2F,0x2C,0xC0,0x89,0x45,0xB5,0xCD,0x4B,
+0x27,0x46,0xDC,0x28,0x47,0x89,0x2B,0x3E,
+0x27,0xA2,0xBB,0xAF,0xA7,0x1A,0xED,0x4D,
+0x2F,0x3A,0xB2,0xFC,0x1B,0xDC,0x6D,0x17,
+0x27,0x2A,0xAC,0x61,0x03,0x83,0x87,0x84,
+0x27,0x3D,0x12,0xA9,0xDD,0x18,0x6B,0x65,
+0x2F,0x2F,0x61,0x59,0xA1,0x7C,0x1A,0x40,
+0x2F,0xEB,0xEE,0x69,0xB2,0x55,0x77,0x85,
+0x2F,0x6C,0x9C,0x2E,0xBF,0xEA,0xBE,0x58,
+0x27,0x46,0xAC,0x4B,0x77,0xB7,0xDD,0xAA,
+0x2F,0xE9,0x23,0x10,0x76,0xF0,0x33,0x0B,
+0x27,0xCA,0x31,0xDF,0x11,0xCB,0x9A,0xC0,
+0x27,0xCE,0xB1,0xB1,0xEE,0xD3,0xAA,0x1C,
+0x27,0x34,0xC9,0xC7,0xFF,0x79,0x48,0x35,
+0x2F,0x85,0xA7,0x79,0x50,0x83,0x5A,0x40,
+0x27,0x74,0x72,0x9A,0x07,0x3C,0x12,0x80,
+0x27,0xD8,0x02,0x15,0x79,0xFE,0x55,0xCF,
+0x2F,0x97,0x94,0xE7,0x3F,0x0F,0xFA,0xA0,
+0x2F,0x2F,0x44,0xDF,0xC1,0x2C,0x84,0xCB,
+0x27,0x3D,0x54,0x59,0x5D,0x7A,0x05,0x8C,
+0x2F,0x31,0xAA,0xE6,0xE7,0xFB,0xA6,0x93,
+0x27,0xB5,0xAE,0x86,0xB5,0xC0,0xAA,0x10,
+0x27,0x0C,0x61,0xAA,0x25,0x17,0x90,0x3D,
+0x27,0x5F,0x59,0xDD,0x86,0x96,0x82,0x14,
+0x27,0x18,0x71,0xBE,0x78,0x38,0x27,0x6C,
+0x2F,0x64,0x1B,0x50,0x93,0xA9,0x6D,0xE7,
+0x2F,0x53,0xC1,0x70,0xD2,0x25,0xFB,0x8B,
+0x2F,0x1E,0xF5,0x5B,0x4E,0xF7,0x8F,0xC7,
+0x27,0x00,0x83,0x07,0x05,0xCE,0x43,0xFF,
+0x27,0x2F,0x5B,0x19,0xC9,0x44,0xDF,0x5E,
+0x27,0x18,0x84,0x8A,0xED,0xD0,0x7A,0xE3,
+0x2F,0xE7,0x89,0x84,0xA9,0x83,0x39,0x1E,
+0x2F,0xE3,0x29,0xE2,0x11,0xBE,0xBE,0x4C,
+0x2F,0xC4,0x2E,0x81,0xC6,0xAA,0x93,0x37,
+0x2F,0x73,0x3B,0x90,0x82,0xF3,0x7D,0x02,
+0x27,0x9E,0xE0,0x9E,0xB4,0x05,0xC0,0x61,
+0x2F,0x55,0xEE,0xB3,0x9F,0xE3,0x4C,0x60,
+0x27,0x3D,0xC6,0xCF,0x92,0x5B,0xA3,0xD9,
+0x27,0x47,0xA0,0xE9,0xB2,0xFD,0xED,0x5A,
+0x27,0x3D,0xF0,0x14,0x95,0x62,0x13,0x6A,
+0x2F,0x5E,0xDD,0xE7,0xB8,0x25,0xB3,0x78,
+0x27,0x29,0x47,0x48,0x82,0x22,0xE3,0xCD,
+0x2F,0xB8,0x0A,0x08,0x20,0xEF,0xA1,0xDB,
+0x2F,0xE4,0x35,0x52,0xEA,0xD7,0xC7,0x88,
+0x27,0xFC,0xBB,0xE1,0x0F,0x23,0x68,0xAA,
+0x27,0xE6,0xD3,0xF6,0x11,0xBE,0x59,0x90,
+0x2F,0x73,0x06,0xE9,0x2E,0xD4,0x1F,0xA3,
+0x27,0xDF,0x49,0x0B,0x31,0xE7,0x76,0x59,
+0x27,0x8D,0x0A,0xFB,0xB0,0x15,0x84,0x18,
+0x27,0x18,0x5F,0xCD,0x21,0xF4,0xF4,0x58,
+0x27,0x41,0x42,0xD5,0xA3,0x83,0x57,0xB8,
+0x2F,0x91,0xDF,0x32,0x9F,0x8B,0xCC,0xE0,
+0x27,0xE7,0xE6,0x5F,0xA4,0x62,0xB6,0xC4,
+0x27,0xFF,0x40,0x32,0x12,0xFF,0x69,0x5B,
+0x27,0x0B,0x1B,0x0C,0xB4,0x05,0xD5,0x98,
+0x27,0x9B,0xA5,0x7C,0xCC,0x97,0x50,0x17,
+0x2F,0x62,0xA0,0x04,0x7C,0xCF,0x90,0x12,
+0x27,0x26,0x8E,0xC7,0xFF,0x2B,0x4E,0x19,
+0x27,0x76,0x7B,0xCD,0xAE,0x18,0xF6,0xCC,
+0x27,0x2B,0x11,0x32,0xF1,0x9B,0xEA,0xB1,
+0x27,0x1D,0x8A,0x02,0xDE,0x1F,0x79,0x76,
+0x2F,0x65,0x5A,0x94,0xCB,0xED,0x3C,0x0D,
+0x27,0xD6,0xE2,0xFA,0x3D,0x76,0x0F,0xAE,
+0x27,0x6A,0xC5,0x93,0xD2,0x92,0x6A,0xE2,
+0x27,0x93,0x9A,0xF3,0x2B,0xEF,0x50,0xF8,
+0x27,0x02,0xF9,0x9B,0xB6,0xDD,0x21,0xAB,
+0x2F,0xE3,0xCB,0xFA,0x5C,0xC3,0x35,0x28,
+0x27,0x22,0xC1,0x4F,0xDF,0x21,0xF5,0x4E,
+0x27,0xDC,0xD4,0xEC,0xDE,0x37,0xB4,0xDD,
+0x27,0xF2,0x88,0xD5,0x5B,0x7C,0xFA,0x7D,
+0x27,0x2B,0x2C,0x5D,0xFD,0x6C,0x77,0xAD,
+0x2F,0x97,0x4F,0xFA,0xA8,0x6E,0xAD,0x4D,
+0x2F,0x62,0xDF,0x4A,0x76,0xE6,0x96,0x85,
+0x27,0x4B,0xC5,0x0B,0x9E,0x24,0xFA,0x6C,
+0x27,0x06,0xCA,0x8F,0x13,0xD1,0x8F,0x3A,
+0x2F,0x5F,0x8A,0x37,0xD2,0x84,0x32,0x71,
+0x2F,0xB2,0x75,0xF1,0x4B,0x69,0xAC,0x56,
+0x27,0xFB,0xC0,0x16,0x4C,0x7F,0xC4,0x6B,
+0x27,0x53,0x0B,0x18,0x0D,0x5B,0xE9,0x29,
+0x27,0x7A,0xB0,0xE2,0xAB,0xDB,0x37,0x9F,
+0x2F,0xCC,0x15,0x32,0x71,0x4B,0xAB,0x49,
+0x2F,0x03,0xC3,0x76,0xD7,0x70,0xDE,0x5A,
+0x27,0x30,0x11,0x82,0x54,0x80,0x26,0x88,
+0x27,0xCF,0x83,0xA8,0xFC,0x9C,0x20,0x9E,
+0x27,0x54,0xF4,0x3F,0xE9,0x00,0x82,0x2A,
+0x27,0xAA,0xF0,0x36,0xF6,0x46,0xC2,0x94,
+0x2F,0xAF,0xB1,0x02,0x03,0x57,0xF2,0x51,
+0x2F,0xC7,0x75,0x15,0x2E,0x16,0x73,0x3E,
+0x2F,0x02,0x2A,0xFC,0x8F,0x72,0xE4,0x34,
+0x2F,0xA3,0x03,0x27,0xFC,0x8E,0xE4,0xD2,
+0x2F,0xC5,0xBB,0x35,0x3C,0xC3,0xEB,0x48,
+0x2F,0x1B,0x2F,0x2D,0x1A,0x3D,0xF2,0xC9,
+0x2F,0xC7,0xDD,0x2F,0x0D,0x5D,0xEE,0xC2,
+0x2F,0x6E,0xD8,0x17,0x1F,0x51,0x40,0x57,
+0x27,0xFB,0xDE,0x2B,0xBD,0x61,0xCF,0xBB,
+0x2F,0x26,0x39,0x4B,0x18,0xC4,0x8D,0xC7,
+0x27,0x59,0xC1,0x25,0x63,0x99,0xC2,0x24,
+0x27,0x81,0xC5,0x33,0xE0,0x9E,0xD6,0xB0,
+0x27,0x86,0xA8,0xC1,0x73,0x79,0x3C,0x31,
+0x27,0xF1,0x48,0x78,0x4F,0x33,0x4B,0x4B,
+0x2F,0x66,0xF7,0x93,0x2A,0xB0,0xE2,0x72,
+0x27,0x53,0x6C,0xE5,0xEE,0xE0,0x9A,0xB8,
+0x2F,0x47,0x85,0x42,0x90,0x6A,0xDD,0xDE,
+0x2F,0x6B,0xF8,0x12,0x91,0xB9,0x42,0xDA,
+0x27,0x35,0x19,0x36,0x2F,0xB2,0xBB,0x0C,
+0x27,0x85,0x76,0xAE,0xDE,0x87,0xF5,0xC2,
+0x27,0xD0,0xE8,0x04,0x45,0x67,0x58,0xA0,
+0x2F,0x57,0x11,0xEC,0xC5,0x77,0x66,0xDB,
+0x27,0x00,0x13,0xF1,0xE5,0x26,0xCA,0x54,
+0x27,0x47,0x1C,0x62,0x4A,0xE5,0xE0,0xA8,
+0x27,0xD0,0x7B,0x59,0xFE,0x3D,0xEE,0x8D,
+0x2F,0xF9,0xC8,0x6F,0xEB,0x6F,0xB1,0x68,
+0x2F,0x0A,0x6B,0x08,0xBA,0x9C,0x56,0xA5,
+0x2F,0x29,0x51,0xBA,0x7D,0xBC,0xE0,0xEE,
+0x2F,0x65,0x13,0x87,0x5E,0xAE,0xBF,0x7F,
+0x27,0xC0,0x1F,0xAB,0x02,0xD4,0x03,0x0A,
+0x27,0xFF,0x6A,0x33,0xCF,0xA7,0x05,0xF2,
+0x2F,0x56,0x23,0x18,0x43,0xA8,0x22,0xC7,
+0x2F,0x44,0x92,0x17,0xE0,0x72,0x20,0xFB,
+0x2F,0x08,0x59,0x3E,0xB0,0xD7,0x78,0x53,
+0x27,0x2B,0x8D,0x75,0x48,0xD5,0x45,0xC9,
+0x2F,0x0B,0x01,0x27,0xBD,0x0A,0xAA,0x81,
+0x2F,0x56,0x1E,0x5C,0x48,0xE7,0x66,0x1E,
+0x2F,0x3C,0x21,0x90,0xF4,0xFE,0xF7,0x50,
+0x2F,0x2A,0x9A,0x64,0xF5,0x4E,0x56,0x66,
+0x2F,0x05,0x0C,0x39,0xDE,0x13,0x0B,0xC3,
+0x27,0xAF,0xC9,0x39,0x33,0x62,0xAE,0x50,
+0x2F,0xBB,0x6E,0xBF,0x2E,0x44,0x5C,0xAF,
+0x2F,0xB2,0xBA,0x9F,0xCA,0x34,0x3D,0x32,
+0x27,0x0B,0xF7,0xFE,0x54,0xBA,0x20,0x92,
+0x2F,0xAF,0xFD,0x3D,0xD9,0x96,0x64,0x54,
+0x27,0x79,0xA1,0xE0,0x95,0xE4,0x13,0x03,
+0x27,0xE7,0x7C,0x59,0xBB,0x9D,0xBE,0xDB,
+0x27,0x3E,0x68,0xEA,0xA5,0x19,0x13,0xD5,
+0x2F,0xDD,0x0D,0xD7,0xD0,0xDC,0xB2,0x28,
+0x2F,0x22,0x9E,0xA3,0xC1,0x79,0x63,0xBD,
+0x22,0xA5,0xBA,0xE9,0xC2,0x9D,0x5C,0x05,
+0x05,0x75,0xA7,0x65,0xAC,0xFA,0x4B,0xB5,
+0x2F,0xDA,0xC9,0x84,0x35,0xBB,0x41,0xD4,
+0x21,0x25,0xF3,0x5B,0x42,0xE7,0x79,0xCB,
+0x05,0x2B,0xF7,0x69,0x44,0xAD,0xBB,0x66
+};
+
+unsigned char sit2_patch_3[] = {
+0x04,0x01,0x00,0x00,0x73,0xDF,0xBE,0xCB,
+0x05,0x2D,0xE5,0x87,0xAA,0x9C,0x1F,0xA6,
+0x22,0x48,0x24,0x06,0xAA,0x81,0x46,0x76,
+0x05,0xCD,0xFA,0x19,0x86,0x2B,0xA5,0x4F,
+0x22,0x66,0x74,0xD1,0xDE,0x1E,0xBC,0x87,
+0x05,0xBF,0xAC,0x24,0x87,0x43,0xAC,0x43,
+0x22,0xD5,0x78,0x2C,0x1B,0xAA,0x35,0x8C,
+0x05,0x12,0xD5,0xCE,0x99,0xED,0x8C,0xBE,
+0x22,0xCC,0xE5,0xA4,0xF0,0x17,0x0B,0x9F,
+0x05,0xED,0xC9,0x48,0xFF,0x41,0x36,0xE8,
+0x2A,0x68,0x35,0x7D,0xA2,0x95,0x06,0xD4,
+0x05,0xDA,0x98,0xE5,0x27,0xE6,0x1B,0x81,
+0x2A,0xF6,0xB2,0x60,0x90,0xCD,0x97,0x00,
+0x05,0x3B,0xBC,0x97,0xC7,0x49,0xE8,0xAC,
+0x27,0xBD,0x69,0x5E,0x76,0x24,0xCA,0xC0,
+0x29,0x82,0x82,0xC3,0xA6,0x88,0xEA,0x31,
+0x05,0xB8,0x75,0x97,0xD5,0x8F,0x7B,0xCF,
+0x2F,0xC3,0x42,0x5D,0x29,0xE3,0x85,0xCA,
+0x2F,0xC0,0xB0,0x46,0x70,0x15,0xF1,0xE4,
+0x25,0x7F,0x15,0x13,0x51,0x2C,0x08,0x0A,
+0x07,0x92,0xBA,0x41,0xA8,0x28,0xB7,0x49,
+0x2F,0x0F,0xA1,0x43,0x80,0x05,0xCF,0xDD,
+0x2F,0xB5,0x33,0xA5,0xCA,0x43,0x2C,0x49,
+0x2F,0x08,0x6C,0x23,0xB1,0x9B,0x55,0xD3,
+0x2F,0x7A,0xB1,0xA2,0x63,0x58,0xAB,0x1E,
+0x2F,0x16,0x34,0xC5,0x66,0x1D,0x11,0x69,
+0x2F,0xBA,0x9A,0xA0,0xF4,0x3D,0xE0,0x1A,
+0x27,0xB3,0x75,0x34,0xBC,0x7F,0x72,0xE8,
+0x27,0xFE,0xB1,0x39,0xDB,0x47,0x5B,0xCE,
+0x27,0x3B,0x83,0x41,0x83,0x93,0x9A,0xC1,
+0x2F,0x79,0x08,0xE1,0x98,0xFF,0x9A,0xD0,
+0x27,0xA3,0xAA,0x24,0x31,0x44,0xFE,0x5C,
+0x24,0x49,0x0C,0x8B,0x7B,0x81,0xBF,0xA9,
+0x07,0x36,0xDB,0x1E,0x49,0x77,0x6A,0x87,
+0x2F,0x3F,0x30,0x2C,0x74,0xA0,0xE2,0x48,
+0x2F,0x18,0x97,0xA5,0xD8,0x50,0x75,0x55,
+0x2F,0xED,0x06,0x48,0xB0,0xB4,0x90,0xD7,
+0x24,0x93,0x71,0x62,0x5B,0xDB,0x72,0x4B,
+0x0F,0x07,0x35,0x0F,0xBD,0xD5,0xB7,0x55,
+0x27,0x56,0x25,0x14,0x19,0x09,0xEB,0x15,
+0x27,0xF3,0xB3,0x0E,0x0B,0x91,0xD7,0xF7,
+0x21,0x0D,0x70,0x9A,0xC1,0xCE,0x8D,0x8A,
+0x0F,0x2A,0xEC,0x95,0x8F,0x36,0xE7,0x60,
+0x2F,0xCF,0x34,0x5D,0x0D,0x21,0x2F,0x7A,
+0x23,0xA3,0xD5,0x35,0xF7,0xE8,0xD9,0xBA,
+0x0F,0xC6,0x53,0x17,0x41,0x02,0x85,0xB3,
+0x27,0x6B,0xFB,0xE7,0xC9,0x4B,0x1F,0x70,
+0x2B,0x90,0x26,0xA9,0x0A,0xCA,0x2E,0x6C,
+0x05,0xA9,0x8A,0x8D,0x5A,0x0B,0xEA,0x61,
+0x22,0x8B,0x44,0x61,0x54,0xC8,0x72,0x66,
+0x07,0x3E,0x49,0x1A,0x43,0x87,0x7E,0xA8,
+0x0F,0xA3,0x30,0xE1,0x42,0xFD,0x03,0x70,
+0x05,0x81,0xE4,0x44,0x56,0x8E,0xB5,0xD1,
+0x24,0x39,0xF1,0xAD,0x89,0xE3,0xF3,0x66,
+0x05,0x81,0x6F,0x18,0x90,0x9B,0x62,0xE8,
+0x2C,0xDA,0x08,0xF1,0x7C,0xE0,0x26,0x83,
+0x05,0x61,0x99,0x5C,0xBE,0x19,0xD1,0x50,
+0x2C,0x68,0x9F,0xE7,0x3F,0x72,0x90,0x35,
+0x05,0xC6,0xBC,0xA2,0x42,0x87,0x6B,0x7C,
+0x2C,0x8E,0x59,0xBB,0x81,0x67,0xF9,0xEF,
+0x05,0xC5,0xD5,0x42,0x75,0xD9,0x29,0x74,
+0x2F,0x6D,0x29,0xD0,0xAD,0x7F,0xDE,0xE0,
+0x21,0xCD,0xC7,0xE5,0x57,0xD2,0x28,0xD9,
+0x05,0x66,0x7B,0x9A,0xE3,0x8B,0x08,0x7F,
+0x2C,0xFF,0xC9,0xCA,0xBB,0x74,0x2C,0x09,
+0x05,0x0D,0x97,0xFA,0xE4,0xEF,0xD6,0x9B,
+0x24,0xBF,0x6E,0xE2,0x2A,0xCE,0x22,0x2A,
+0x05,0x85,0xB3,0x69,0xE5,0xBD,0xBE,0xAB,
+0x2C,0x0B,0x00,0x09,0xEE,0x20,0x3F,0x31,
+0x05,0x50,0xF3,0x81,0x50,0x6C,0xA4,0x88,
+0x24,0x79,0xD9,0xC3,0xA7,0x15,0x5F,0xB2,
+0x05,0x3E,0x95,0x28,0xDF,0x55,0x63,0x78,
+0x24,0x56,0x59,0xC3,0x28,0xD7,0x0F,0x69,
+0x05,0x71,0xE2,0xE8,0x15,0x4E,0x6E,0xD4,
+0x24,0xAB,0x2E,0x42,0x83,0x95,0x22,0x2D,
+0x05,0x72,0x6D,0x0A,0x44,0x91,0xBA,0xBF,
+0x2C,0x40,0xD7,0x8C,0x55,0x4B,0x38,0xE8,
+0x05,0xC5,0xAF,0x1F,0xE7,0x1D,0x2F,0x61,
+0x24,0xC0,0xF7,0xC0,0xAB,0x73,0x63,0x39,
+0x05,0x0D,0xD7,0x34,0xA1,0xEC,0x63,0x11,
+0x24,0x1C,0xAA,0x42,0x8D,0x47,0xF0,0x64,
+0x05,0xD0,0x95,0xBF,0x7A,0x52,0x24,0xEA,
+0x2C,0x4F,0x81,0xAF,0xC7,0x0A,0x91,0x01,
+0x05,0x64,0xF4,0x46,0x5E,0x29,0x1C,0x9E,
+0x24,0x7B,0x53,0xB7,0x47,0x15,0xCF,0x4D,
+0x05,0x7D,0xD8,0x29,0x38,0x0E,0x38,0x0D,
+0x27,0x07,0x40,0x89,0x10,0x0C,0xE7,0x94,
+0x29,0x48,0xA2,0x64,0xDA,0xE0,0xA0,0x87,
+0x05,0x83,0xC6,0x56,0x97,0xF1,0x48,0xA8,
+0x24,0xD9,0x97,0xCA,0xFB,0xA6,0x38,0x45,
+0x05,0x92,0x4F,0x8D,0x51,0x34,0xB7,0xEE,
+0x2C,0x47,0xDD,0x32,0xB4,0x8B,0x30,0x26,
+0x05,0xA5,0xFB,0x99,0x7D,0x31,0x80,0x85,
+0x24,0x27,0x12,0x90,0xE7,0x0C,0x8D,0x38,
+0x05,0xC8,0xFA,0x1D,0x88,0x44,0xEE,0x34,
+0x2F,0x51,0x80,0x51,0x70,0x25,0xE3,0xB6,
+0x29,0x58,0xDD,0xC7,0x09,0x58,0x27,0x4E,
+0x05,0xE8,0x3A,0x83,0x56,0x93,0x38,0x17,
+0x2C,0x40,0x01,0xB4,0x92,0x61,0xFE,0x93,
+0x05,0x06,0xC5,0xA1,0x6D,0x1D,0xAC,0x39,
+0x27,0x07,0x3F,0x24,0xE3,0x5D,0xA4,0x4C,
+0x2D,0x3A,0x68,0x75,0xD5,0x55,0x36,0x5D,
+0x05,0x81,0x10,0xF2,0x20,0xC0,0x54,0xC0,
+0x27,0xA2,0x9C,0xEB,0xB0,0x45,0x31,0xDE,
+0x2D,0x2E,0x09,0x0C,0x99,0x86,0x50,0x82,
+0x05,0xDF,0xE8,0x87,0x21,0xF6,0x5C,0x97,
+0x2C,0xEC,0x88,0xB4,0xF2,0xC4,0x6D,0x6C,
+0x05,0x50,0x19,0xB6,0xEB,0x6A,0x83,0x39,
+0x27,0x7D,0x6C,0xA6,0xDE,0x0F,0x81,0xEB,
+0x25,0xA5,0x3C,0x30,0xA6,0x73,0xE1,0x50,
+0x05,0x72,0x9C,0x58,0x57,0x3F,0x2C,0xAF,
+0x27,0xEE,0xA4,0xB1,0x0B,0x96,0x78,0xCE,
+0x29,0x82,0xD0,0xEE,0x50,0xBE,0xE9,0x32,
+0x05,0xCF,0x49,0x01,0x4D,0xD7,0x84,0x2F,
+0x27,0x8E,0xE6,0x08,0x79,0x80,0xF4,0x3D,
+0x29,0x7D,0x70,0x89,0xBD,0xA0,0x8A,0xE4,
+0x05,0x57,0x60,0xD8,0x47,0xFC,0x7F,0x2D,
+0x2C,0x56,0x39,0x21,0x72,0x26,0x26,0x13,
+0x05,0x7B,0xF2,0x48,0x62,0x6A,0x22,0xC1,
+0x27,0x4D,0x0A,0x88,0xC5,0xE2,0xB4,0x61,
+0x25,0x3E,0x64,0x40,0xEB,0x55,0x8A,0x19,
+0x05,0xEC,0xB4,0xD3,0x8D,0xA9,0xCA,0x79,
+0x2C,0x92,0xE3,0xBB,0x9F,0xC3,0x77,0x3E,
+0x05,0xD4,0x8F,0x24,0xD4,0x74,0x2E,0x77,
+0x2C,0x9B,0x2B,0x23,0x25,0x4D,0x13,0x64,
+0x05,0x4A,0x1B,0xC6,0xBC,0x0D,0x27,0xEA,
+0x24,0x16,0xFF,0x65,0xEC,0xCB,0xCF,0x91,
+0x05,0x2C,0x4E,0x34,0xD9,0x11,0x71,0xA7,
+0x24,0x82,0x66,0x4C,0x0E,0x8B,0x85,0x68,
+0x05,0x99,0x50,0x54,0x06,0xC2,0xC7,0x15,
+0x2C,0x91,0x26,0xC4,0x58,0x35,0x27,0x36,
+0x05,0xE1,0xD5,0x56,0x81,0x03,0x00,0x96,
+0x2F,0x7B,0xBF,0x14,0x17,0xE0,0xE2,0x23,
+0x29,0x43,0x44,0x6A,0xB6,0x55,0x2B,0x56,
+0x07,0x88,0x83,0x31,0x07,0x54,0xC8,0x8C,
+0x2F,0x98,0xDF,0x9D,0x3D,0xD0,0x1D,0x7B,
+0x2F,0x05,0xE2,0x77,0x77,0x92,0x54,0x04,
+0x27,0x0B,0x02,0xE4,0x32,0x01,0xEB,0xD0,
+0x27,0xD7,0x61,0x5A,0xDB,0x94,0x31,0x68,
+0x27,0x29,0xEA,0xF4,0xFF,0x83,0xB6,0x93,
+0x2F,0xA0,0xBB,0x7D,0x14,0x98,0x04,0x72,
+0x2A,0x21,0xC3,0x95,0xD6,0x1F,0x37,0x95,
+0x0F,0xF7,0x18,0xA7,0x61,0xA8,0x6E,0xAD,
+0x27,0x03,0xC5,0x38,0x37,0xF8,0x0E,0x1C,
+0x2D,0x74,0x24,0xFC,0xAC,0xC0,0x6F,0xB7,
+0x07,0x64,0xE2,0x80,0xFE,0x95,0x87,0xF9,
+0x24,0x7C,0x99,0x04,0xF3,0x0E,0x2A,0x47,
+0x0F,0x02,0x9F,0x5D,0x42,0x72,0x73,0x9A,
+0x2F,0x2C,0x27,0xA3,0xD6,0x7F,0xE0,0x97,
+0x21,0xD9,0x34,0x78,0x08,0x44,0x9D,0xEA,
+0x07,0x55,0x07,0x4D,0xEE,0x23,0xF7,0x05,
+0x2C,0x20,0xC4,0xE9,0x2D,0x42,0x63,0x74,
+0x07,0x23,0xDB,0xBD,0x08,0xDD,0x11,0xD3,
+0x2F,0xBC,0x76,0xD1,0x68,0x32,0xFE,0xB5,
+0x2F,0x55,0xDE,0x20,0x1E,0x9B,0x6B,0x2B,
+0x27,0x58,0x0E,0xF0,0x90,0x77,0x66,0x92,
+0x27,0xA1,0x45,0xA5,0xBF,0xB1,0x59,0x41,
+0x2F,0xCA,0x44,0x6C,0xCC,0x03,0xF8,0x45,
+0x27,0x1C,0xA5,0x42,0xFD,0x85,0x88,0xC5,
+0x27,0xA0,0x3B,0x87,0x7A,0x4D,0xA0,0x34,
+0x27,0x9E,0x6F,0x33,0xAE,0x02,0xA5,0x89,
+0x2F,0x36,0x10,0x2E,0x64,0x16,0x5F,0x8A,
+0x2F,0x19,0x43,0x27,0xCD,0x7A,0x15,0xC4,
+0x2A,0xBE,0x36,0x67,0x46,0x6C,0x62,0x8E,
+0x0F,0xB8,0xED,0xD6,0x4D,0xA2,0x9C,0xD6,
+0x27,0xE4,0x1C,0x60,0xE4,0x1B,0x1B,0x2A,
+0x29,0xF7,0x85,0x45,0xB8,0xE3,0x71,0x02,
+0x0F,0x44,0xA2,0x89,0xAF,0x06,0x1E,0xCE,
+0x27,0xBF,0xFE,0x2E,0xED,0x3C,0x43,0x03,
+0x2F,0xFD,0x83,0x08,0x7F,0x13,0x6B,0x76,
+0x22,0xCC,0x18,0x8C,0x8B,0x22,0x81,0xEF,
+0x0F,0x33,0xB5,0x7B,0xA8,0xC6,0xB0,0xCB,
+0x2F,0xBA,0x7F,0xEA,0xF3,0x8F,0x55,0xE2,
+0x27,0xD6,0x6B,0x1B,0xDB,0x91,0x81,0x72,
+0x2F,0x50,0x48,0x5D,0xCC,0x1A,0x5F,0x71,
+0x23,0x4E,0x1D,0x69,0x8B,0x59,0xFA,0x2C,
+0x0F,0x27,0x60,0x54,0x62,0x13,0x86,0x24,
+0x2F,0x96,0x07,0xA8,0x3E,0x24,0xE6,0xD4,
+0x27,0x87,0x84,0xCF,0x06,0x78,0x6F,0x69,
+0x27,0x90,0xBB,0x5B,0x54,0x4F,0xBA,0x19,
+0x27,0x92,0x88,0x58,0x3C,0xF6,0xF1,0xAD,
+0x07,0x0A,0xE2,0xCB,0x24,0xE6,0xE4,0x8C,
+0x27,0xB6,0xC8,0x95,0x39,0xD7,0xA5,0xC0,
+0x27,0x14,0x53,0xDD,0xA0,0x55,0x9F,0xAB,
+0x27,0xE9,0x2A,0x46,0xC5,0xD1,0x4F,0x24,
+0x2F,0x29,0x3E,0x2E,0xB7,0xDD,0x1D,0xF4,
+0x2F,0x34,0xEC,0x49,0x5F,0x57,0x43,0xEC,
+0x2F,0x8F,0x7A,0x92,0x2F,0x8E,0xBE,0x9A,
+0x2A,0x9D,0xAB,0x06,0x8C,0x8E,0x85,0x63,
+0x07,0x9A,0x31,0x23,0xAC,0x63,0x14,0x6A,
+0x2F,0x43,0x96,0x0D,0x18,0x2A,0xA5,0x88,
+0x2F,0x75,0xA8,0x3D,0x3F,0x93,0xB0,0x67,
+0x27,0xAC,0x57,0xCD,0x8A,0xE7,0x4E,0x19,
+0x27,0x08,0x07,0x68,0xD2,0x93,0x84,0xBE,
+0x24,0xBB,0x25,0x18,0xD5,0x9E,0xB6,0x05,
+0x07,0xCE,0xAA,0xD5,0x61,0x4A,0x61,0xF8,
+0x27,0x47,0x78,0xAD,0xD3,0x3F,0xD5,0x94,
+0x2F,0xDD,0x26,0xDF,0x14,0xCF,0xB6,0x28,
+0x2F,0x46,0x47,0x8A,0xF9,0x92,0x8B,0x9E,
+0x27,0x75,0x58,0x02,0x92,0xEA,0xC2,0x70,
+0x2F,0xF6,0x89,0x64,0x70,0x88,0xAE,0xA5,
+0x27,0x56,0x6B,0xEF,0xE3,0x34,0x06,0x5C,
+0x27,0xD0,0x06,0xD4,0x8A,0x62,0x66,0x24,
+0x2F,0x18,0x98,0xCF,0x5B,0x7C,0xEC,0x7F,
+0x2F,0x44,0x3D,0x02,0xF7,0x30,0x57,0xBB,
+0x2F,0x96,0x43,0xA4,0xB4,0x53,0xEC,0xAA,
+0x27,0x1A,0x5E,0x7E,0xEE,0xA2,0xE2,0xF9,
+0x27,0x7F,0x77,0x05,0x06,0x15,0x88,0xB6,
+0x2F,0x55,0x8A,0xD7,0xC6,0x06,0xBE,0x4F,
+0x2F,0x82,0x9C,0xF6,0x26,0x22,0x26,0x56,
+0x2A,0x15,0xD1,0x2E,0x5E,0x01,0x35,0x21,
+0x0F,0xC4,0x71,0x88,0xAC,0x80,0xFB,0x9E,
+0x2F,0xAD,0x72,0x03,0x44,0xD9,0xFB,0x77,
+0x27,0x4B,0x72,0x40,0x28,0x6F,0xEC,0xAB,
+0x2F,0x43,0xF6,0xD0,0x98,0x69,0xA6,0x59,
+0x2F,0x26,0x33,0x1A,0x02,0x84,0xA7,0x79,
+0x27,0x7E,0x41,0x42,0x91,0x1A,0x2D,0xCE,
+0x2F,0x1B,0xE0,0x33,0x0E,0x97,0xF5,0x47,
+0x27,0x46,0xF7,0x3A,0xDD,0x34,0xD9,0x34,
+0x2F,0x5B,0x7F,0x80,0x87,0xFC,0xE4,0x6E,
+0x2C,0xE5,0xC8,0x66,0x0A,0x90,0x59,0x55,
+0x07,0x8F,0x48,0xA2,0xB4,0xE8,0x9C,0xD8,
+0x27,0x75,0x31,0x93,0x6C,0xE0,0x08,0xDB,
+0x27,0x50,0xB7,0x4E,0xE4,0x77,0xEA,0x64,
+0x2F,0xB5,0x67,0x2F,0x43,0x6F,0xDC,0x20,
+0x2F,0x4D,0x58,0x0E,0x50,0x7B,0x6E,0x87,
+0x27,0x68,0xE9,0x3A,0x05,0xE3,0x11,0x3E,
+0x27,0x85,0x2F,0xD5,0xD2,0xD4,0xDD,0xFD,
+0x2F,0x71,0xBC,0x15,0x42,0xFB,0x33,0xFD,
+0x27,0x90,0xE3,0xCB,0x1E,0x9E,0xAB,0xCE,
+0x27,0x27,0xE5,0xD7,0xB1,0xEE,0x78,0xC8,
+0x21,0x8D,0xA0,0x94,0x42,0x81,0x2F,0xFD,
+0x0F,0x61,0x14,0xFC,0x72,0x93,0xCC,0x72,
+0x2F,0xA3,0xD5,0xDC,0x28,0x3E,0x80,0xFF,
+0x27,0x47,0x9E,0xF0,0x07,0x4F,0x91,0x7C,
+0x2F,0x5D,0x31,0xB4,0xA7,0x62,0xE3,0xD8,
+0x2B,0xA9,0xB3,0x60,0x76,0x51,0xDA,0xDA,
+0x0F,0x4A,0xBC,0xD2,0xF1,0x44,0xCF,0xA0,
+0x2F,0x76,0x3A,0x50,0xD4,0x6D,0xAB,0xAE,
+0x21,0x75,0x7A,0x27,0x8C,0x1B,0x6B,0xFC,
+0x0F,0x38,0xBE,0x8F,0x1E,0xB2,0x4E,0x91,
+0x27,0x06,0x4A,0x7A,0xA2,0xF3,0x4F,0x69,
+0x29,0x0E,0x2F,0x5B,0x00,0x5F,0xCB,0x08,
+0x0F,0x12,0xCC,0xF7,0x99,0x02,0x46,0x6A,
+0x27,0xAA,0x14,0x94,0x13,0x51,0x1F,0x49,
+0x2F,0x19,0x68,0x25,0x33,0xA3,0x89,0xA8,
+0x27,0xB1,0x5E,0x67,0x96,0x89,0x4B,0x8F,
+0x2F,0x8D,0x1A,0x0B,0x75,0x3A,0x98,0x0D,
+0x27,0x2F,0x10,0x0C,0xAE,0x67,0xAC,0xAE,
+0x27,0xAE,0x17,0x2C,0xBC,0x8B,0xF3,0x09,
+0x2F,0xBF,0x2D,0xCF,0x04,0x74,0x47,0x20,
+0x23,0x70,0xAE,0x38,0x6A,0x43,0xE0,0x11,
+0x07,0xE1,0xCC,0xC9,0x92,0xDA,0x9C,0x17,
+0x2F,0x62,0x67,0x6A,0xB2,0x6E,0x11,0xC7,
+0x2F,0xDF,0x0D,0x46,0x61,0x84,0x34,0xFB,
+0x27,0x4F,0x40,0xBA,0x9F,0x96,0x41,0x88,
+0x2F,0x05,0x3C,0x37,0x80,0x95,0xCA,0xDE,
+0x2F,0x6F,0x3A,0x11,0x87,0xB1,0xF9,0x76,
+0x2F,0x6D,0x12,0x07,0x09,0x6C,0x1D,0xC0,
+0x2F,0xDA,0x7E,0x67,0xF2,0x1D,0xA1,0xB3,
+0x2F,0xAD,0x9E,0x57,0xCC,0xFF,0x53,0x1E,
+0x0F,0x8D,0x55,0xBE,0x6D,0x09,0x97,0x20,
+0x2F,0xEA,0x9B,0x56,0x39,0x1F,0x14,0x2B,
+0x27,0x6A,0xF3,0xD4,0xA8,0x9A,0x2F,0x86,
+0x2F,0x9F,0x46,0xC2,0x76,0x92,0xB5,0x2C,
+0x27,0xA3,0x3F,0x01,0x79,0xA8,0xC6,0x2D,
+0x2F,0x3C,0x41,0xA9,0x51,0xEE,0xD7,0xE2,
+0x2F,0x7A,0xDE,0x1A,0x73,0xD2,0x7C,0x2F,
+0x2F,0x79,0x26,0x05,0x02,0x45,0x0F,0xD3,
+0x2F,0x81,0x6B,0x0A,0x8B,0x7D,0xF2,0xE9,
+0x2F,0xED,0x77,0xD8,0x16,0xF2,0x4E,0xB1,
+0x2F,0x95,0xC6,0x9F,0x09,0x2A,0x6D,0x8D,
+0x26,0x7D,0x04,0xB5,0x52,0x6C,0xFE,0x5D,
+0x07,0x56,0x98,0xAD,0xCE,0x28,0x4D,0x87,
+0x0F,0x49,0x6A,0x02,0x17,0xAD,0xCE,0x71,
+0x27,0x07,0x64,0xFB,0x9C,0xA1,0x38,0xE2,
+0x27,0x60,0x1B,0xAB,0x38,0xC3,0xC1,0x12,
+0x2F,0x03,0xAA,0xD2,0x69,0x51,0x2F,0xD4,
+0x2F,0x1D,0x6D,0xD2,0x94,0x67,0xF3,0xFC,
+0x27,0xC8,0x2F,0x84,0x7D,0x5F,0xFD,0x68,
+0x29,0xA0,0x06,0x87,0xD0,0x25,0xA4,0x59,
+0x0F,0xF5,0xED,0x30,0xD1,0xE9,0xD6,0x4B,
+0x0F,0xE5,0x8A,0xBF,0x10,0x35,0x80,0x77,
+0x0F,0x7D,0x8F,0xEF,0x2C,0xE5,0x81,0x83,
+0x27,0xA1,0x9A,0x30,0xF7,0x8E,0x27,0xCC,
+0x2F,0x42,0xED,0x53,0xE0,0x8D,0x9F,0xF5,
+0x2A,0x2E,0x7C,0x97,0x78,0x36,0xCD,0x29,
+0x07,0x79,0xF0,0x30,0x04,0x3F,0xC4,0xF6,
+0x2F,0x18,0xC1,0x6E,0xAB,0xE4,0x5C,0xB4,
+0x2D,0x22,0x52,0x40,0xE8,0x61,0xDA,0x5E,
+0x07,0x23,0xF9,0x71,0xD5,0x86,0x37,0xFC,
+0x27,0xFE,0x24,0xD9,0xC4,0xEE,0x4E,0xE3,
+0x2F,0xAF,0x62,0xFE,0xC3,0x8F,0x1F,0xA3,
+0x26,0xBE,0x7A,0x18,0x6B,0xAA,0xAA,0xA1,
+0x0F,0x4D,0xCB,0x70,0x8F,0xC8,0xCF,0xE2,
+0x07,0x25,0xD2,0x4D,0x71,0x2E,0xAD,0x78,
+0x07,0x02,0x3E,0xD8,0x94,0xE4,0x32,0x92,
+0x0F,0xAB,0x15,0xC4,0x6C,0x19,0x31,0x41,
+0x07,0xC9,0x27,0xB8,0x16,0x66,0x11,0xE7,
+0x2F,0x0B,0x48,0x33,0x27,0x06,0x55,0xE1,
+0x29,0xD6,0xFA,0x40,0x03,0xE9,0x4A,0x56,
+0x07,0x99,0xEC,0x62,0x14,0x20,0x67,0xBA,
+0x27,0xEE,0x16,0x96,0x61,0xF7,0x3A,0x2A,
+0x25,0x08,0xEE,0x64,0x03,0x9C,0x00,0xF1,
+0x0F,0x88,0xEA,0x73,0x1D,0xF2,0x52,0x01,
+0x2F,0xE0,0x29,0x04,0x55,0x59,0x30,0x72,
+0x29,0xF3,0x72,0x71,0xB9,0x4F,0xEA,0xD3,
+0x07,0xE1,0xEC,0x66,0xC8,0x90,0xF3,0x1C,
+0x2F,0xB7,0x56,0xC8,0xA1,0x62,0xEA,0x70,
+0x2D,0x98,0x8B,0xF5,0xB2,0x9B,0x59,0x54,
+0x0F,0x5E,0x1B,0xA4,0x7F,0xF9,0xB6,0xA7,
+0x2F,0xDE,0x98,0x7C,0x0C,0xAF,0xC5,0xBD,
+0x2F,0x42,0xD8,0x9A,0xD1,0xD0,0x65,0xD6,
+0x2A,0xE5,0xED,0x9B,0x08,0xFD,0xC8,0xA3,
+0x07,0xBB,0x50,0xFA,0x31,0xF6,0x7C,0x05,
+0x0F,0x4F,0x56,0xAC,0xAA,0xFA,0xDF,0x94,
+0x2F,0x7E,0x56,0x98,0x43,0xA2,0xC4,0x7C,
+0x2F,0xF0,0x1A,0xF9,0xF8,0x18,0xA1,0x48,
+0x2F,0x17,0x65,0x31,0xC0,0xAC,0x64,0x86,
+0x2F,0x9C,0xBC,0x7A,0xFD,0xE2,0xF9,0xE3,
+0x2F,0x86,0x4D,0x80,0x9A,0x36,0x8F,0xBB,
+0x27,0x79,0x86,0x58,0x78,0xE6,0xD4,0x24,
+0x2F,0xF9,0x77,0x61,0x69,0x3F,0x40,0x4F,
+0x27,0x15,0xD5,0xE2,0x4A,0x1B,0x55,0x34,
+0x0F,0x78,0x21,0x4E,0x5B,0xC8,0x54,0x0E,
+0x2F,0xDA,0xE6,0x86,0x8D,0xCB,0x40,0xC2,
+0x29,0x59,0x39,0x4D,0xF0,0xAC,0xD7,0x45,
+0x0F,0xE3,0x33,0x15,0xAA,0x49,0xFD,0x4F,
+0x2C,0xF2,0x1B,0x8D,0xB8,0x96,0x6E,0xD6,
+0x07,0xA5,0x83,0xDA,0x9A,0x87,0xBD,0x01,
+0x2F,0xF3,0x76,0xEB,0xA0,0xC9,0xE6,0x84,
+0x21,0xF6,0x10,0xFC,0x76,0xD3,0xFB,0xD1,
+0x07,0x6C,0x31,0x0D,0x28,0x58,0x76,0xB6,
+0x27,0x6E,0x5B,0x13,0x6D,0x68,0xBF,0x2F,
+0x27,0x26,0x6A,0xC2,0x77,0x09,0xD2,0x3D,
+0x2F,0xC3,0x2C,0xCF,0x08,0xF1,0x9A,0x11,
+0x2F,0x7A,0x0F,0x2E,0x41,0xAA,0x0A,0x67,
+0x2F,0x42,0xBB,0x07,0x5E,0x35,0xF1,0x3F,
+0x2F,0x9A,0x2F,0x12,0xA8,0xC3,0x92,0x24,
+0x2F,0xCC,0x11,0xC5,0x2C,0x6D,0xA9,0x4F,
+0x2B,0x83,0x86,0x83,0x2D,0xC8,0x4E,0xF0,
+0x07,0x64,0x5A,0x5E,0x13,0x46,0xA9,0xA4,
+0x2F,0x8E,0xFB,0x93,0x69,0xC6,0x99,0x2B,
+0x27,0x5A,0x8E,0x6F,0xC9,0x7E,0x2B,0xC5,
+0x27,0x60,0x02,0x25,0xB3,0x77,0xC3,0x38,
+0x2B,0x9A,0x62,0x3D,0x1A,0x3D,0x39,0x31,
+0x0F,0x68,0x36,0x28,0x85,0xEB,0xBE,0xD8,
+0x2F,0x30,0xF7,0xD6,0x6E,0xC0,0xA5,0xB5,
+0x21,0x38,0x21,0xF2,0x1A,0x04,0xBF,0x24,
+0x07,0xBA,0x0D,0x57,0xBB,0x56,0x65,0x1E,
+0x27,0xE3,0x44,0x89,0xD4,0x07,0x8D,0x10,
+0x2F,0xB0,0xCC,0x1F,0x63,0x38,0x18,0x2A,
+0x27,0x19,0x5A,0x64,0x8C,0xAD,0xA5,0xDD,
+0x2F,0xF2,0x32,0xB9,0x71,0x24,0x51,0x21,
+0x27,0x7E,0x57,0x81,0xFF,0x26,0xE1,0xA0,
+0x27,0xC3,0x3A,0xC5,0xCC,0x3A,0x23,0x73,
+0x2F,0xEA,0x77,0xBC,0x34,0x44,0x80,0x69,
+0x27,0xC9,0xD6,0xC8,0xC7,0x32,0x38,0xE0,
+0x2C,0xD4,0xE0,0x4A,0xA7,0x9B,0x9D,0x24,
+0x0F,0x23,0x3E,0xD2,0x4C,0x00,0x1B,0xCD,
+0x27,0x10,0x4B,0x4E,0x75,0x77,0xBF,0xF7,
+0x2F,0x29,0x6E,0x5A,0x01,0xAB,0xC3,0x8D,
+0x2E,0xBD,0x37,0x4A,0xE1,0x27,0xBF,0xD2,
+0x0F,0x3D,0x7A,0x29,0x0A,0x57,0xDB,0x92,
+0x2F,0xFF,0xDF,0x07,0xDC,0x75,0x00,0x55,
+0x2D,0x0E,0x6E,0x17,0x41,0x21,0xE9,0x43,
+0x07,0xC4,0xE8,0x45,0x70,0xA3,0x7B,0x09,
+0x07,0x6B,0x91,0xF5,0x0E,0xBB,0xBC,0xDA,
+0x0F,0x22,0xC8,0x51,0xA7,0xCE,0x22,0x4C,
+0x24,0x94,0xB6,0x5F,0xBB,0x18,0xC3,0xDA,
+0x07,0xA8,0x71,0xCC,0xD1,0x21,0x6B,0x20,
+0x07,0x2C,0xD1,0xDE,0xEB,0x0E,0x61,0xB8,
+0x0F,0xAC,0x6E,0x27,0x63,0xEA,0xEA,0xD5,
+0x27,0xDB,0x0B,0xE1,0xD7,0x5B,0xD3,0x1C,
+0x2F,0x4D,0x02,0x4A,0x5A,0x61,0xEE,0xCF,
+0x2F,0x8F,0x2D,0x95,0x85,0xB1,0x29,0xE1,
+0x27,0xF1,0x29,0x42,0x67,0x1D,0x71,0x67,
+0x2F,0x0F,0x41,0x75,0xAC,0x90,0xCB,0x1B,
+0x2F,0x82,0x66,0x46,0x31,0x04,0xCE,0xAC,
+0x2F,0x86,0x2B,0xF2,0x20,0xCD,0x87,0xA7,
+0x27,0x0C,0x79,0xA7,0xE9,0xD4,0x23,0xDD,
+0x2F,0xAC,0xDA,0x86,0xAF,0x3E,0xF3,0x4B,
+0x27,0x07,0x86,0xF2,0xB2,0x00,0x26,0xCE,
+0x27,0x1C,0x04,0xE7,0xD6,0xBA,0xB7,0x25,
+0x2F,0x96,0x75,0x2B,0xE9,0xFD,0x35,0xE6,
+0x27,0x1A,0xEA,0xCA,0xDD,0xC6,0x96,0xF9,
+0x2F,0x97,0xA2,0x2A,0x04,0xEC,0x36,0x30,
+0x2F,0xDD,0x9B,0xDE,0x43,0xCD,0xDF,0xF8,
+0x2F,0xE0,0xD5,0xC0,0x0F,0xBB,0xD8,0x69,
+0x27,0xC3,0x0F,0x04,0x4E,0x95,0x8B,0x04,
+0x27,0x63,0x15,0x72,0x64,0x9E,0xC7,0x00,
+0x27,0x6F,0xED,0x6E,0x64,0xE0,0xC2,0xF4,
+0x27,0xA8,0x0E,0x7E,0xB0,0x96,0x7B,0xA9,
+0x0F,0xB0,0x1B,0xEC,0xCF,0xA8,0x17,0xB0,
+0x07,0x82,0xAB,0xC0,0x01,0x58,0xEC,0x2D,
+0x2F,0xE1,0xF7,0x50,0x24,0x3E,0xE0,0xF9,
+0x2F,0x09,0x82,0xD9,0x5D,0x19,0x2E,0xB9,
+0x27,0x1F,0x79,0x97,0xBF,0x7B,0x27,0xDE,
+0x27,0x65,0xE1,0xFE,0x4C,0x0B,0xD5,0xD3,
+0x27,0xFA,0xEC,0xB1,0x34,0x4B,0x4D,0x33,
+0x2F,0x98,0xB8,0x9F,0xA5,0xCD,0xB2,0xE9,
+0x2F,0xFD,0x5B,0xC5,0xDE,0xFC,0x6A,0xD9,
+0x2F,0x58,0x54,0x25,0x73,0x13,0x23,0x15,
+0x27,0x3D,0x50,0xE0,0xAB,0xD9,0xC6,0x77,
+0x2F,0x74,0x69,0xE1,0xBE,0xA1,0x53,0xC4,
+0x2F,0x69,0x5A,0xCD,0x5C,0x3F,0xCA,0xC1,
+0x2B,0x72,0xDF,0xC7,0xDC,0x16,0x3C,0xCC,
+0x07,0xCF,0xA7,0x8F,0x53,0x93,0xF1,0x73,
+0x27,0x02,0x57,0x2C,0x22,0xCA,0x6A,0x65,
+0x27,0x79,0xBC,0x8D,0xF2,0xA6,0xE2,0x39,
+0x2F,0xAC,0xF4,0x97,0x1F,0x72,0xCE,0x4C,
+0x27,0x2E,0xF2,0x45,0x7B,0x2A,0x16,0xE5,
+0x24,0x2A,0x49,0x15,0xE5,0x74,0x54,0xFF,
+0x07,0x58,0xD9,0xDC,0xAA,0x8A,0xA8,0x90,
+0x27,0x93,0x6E,0xFF,0x3F,0xA7,0x95,0x82,
+0x27,0x1E,0x41,0xF8,0x07,0x10,0x1A,0x50,
+0x27,0x3C,0x99,0x18,0x6A,0x83,0xCE,0x60,
+0x27,0x6D,0x1F,0x15,0x94,0x16,0xE7,0x03,
+0x27,0x4C,0xE8,0xC2,0x40,0x8F,0xB3,0x4A,
+0x21,0xD0,0xA6,0xE7,0x4C,0xBC,0xD8,0x44,
+0x07,0x17,0x9D,0x09,0x5E,0x78,0x7C,0x41,
+0x07,0xD3,0x64,0x09,0x92,0xCC,0x86,0x40,
+0x2C,0x84,0x36,0x98,0x1B,0x08,0xFB,0xB8,
+0x07,0x37,0x67,0xCF,0x47,0x99,0x30,0x0F,
+0x27,0x07,0xCA,0xA2,0xE6,0x95,0xF9,0x6B,
+0x2F,0xF1,0x38,0x2C,0x88,0x45,0x91,0x4A,
+0x2F,0xDA,0x9E,0xF9,0xEB,0x4F,0x73,0x72,
+0x2F,0x6D,0x80,0x83,0x0C,0xBE,0x66,0x2F,
+0x27,0x2C,0xFB,0xF9,0xAA,0x82,0xE2,0x7B,
+0x21,0x37,0x6C,0x53,0xFD,0x04,0xBC,0x3A,
+0x07,0x28,0x53,0xE0,0x32,0x3A,0x69,0x07,
+0x0F,0xC2,0x3B,0x26,0x9F,0xE4,0x83,0x74,
+0x2F,0x83,0x9A,0xB9,0x64,0xC3,0x82,0xBA,
+0x27,0x3B,0xF1,0x1A,0x50,0xB0,0x6B,0x3C,
+0x27,0x39,0x6E,0xD9,0x52,0x12,0xA6,0x68,
+0x2F,0x02,0xD3,0xDF,0x53,0x5F,0x9A,0x31,
+0x2F,0x26,0xA3,0x97,0xE1,0xF5,0x7F,0x0C,
+0x2F,0xCE,0xFE,0xFA,0xD9,0x69,0xAA,0xC6,
+0x27,0xB1,0xC4,0xF6,0xD0,0x41,0x6A,0xAD,
+0x2F,0x3F,0xA2,0x96,0x9A,0x98,0x57,0x1E,
+0x2F,0x7C,0x99,0x5E,0x2D,0x09,0xF3,0x0C,
+0x2F,0x63,0x29,0x7C,0x84,0x46,0x77,0x3D,
+0x2F,0xA3,0x19,0x60,0xB7,0x36,0x81,0x83,
+0x27,0xEF,0xD5,0xB2,0xD6,0x17,0x78,0x81,
+0x0F,0x0B,0x74,0x99,0x82,0x05,0xA1,0x93,
+0x0F,0x69,0x5A,0x5E,0x13,0xCE,0x77,0xB6,
+0x27,0x12,0xFF,0x0E,0x05,0xCC,0xBC,0xF3,
+0x2D,0x6D,0xCD,0xE3,0x39,0x4D,0x4A,0xB3,
+0x0F,0xA7,0x2F,0x74,0x00,0xC6,0x46,0xF2,
+0x07,0xAA,0x3D,0x16,0x80,0x4F,0xC7,0x61,
+0x27,0xC4,0xF3,0x47,0xBC,0x7F,0x8D,0x01,
+0x2D,0x78,0xC0,0xB3,0xD1,0x90,0xA5,0x5E,
+0x07,0x29,0xFA,0xDE,0x96,0xB2,0x04,0x4B,
+0x07,0xE7,0x2D,0x9D,0x75,0x2C,0xE4,0xFD,
+0x27,0x3A,0x25,0x23,0x5E,0x04,0x15,0x41,
+0x2F,0xDD,0x6E,0x18,0x19,0x07,0xDF,0xBE,
+0x2E,0x89,0xED,0x6C,0x94,0x8D,0x03,0xC1,
+0x0F,0x08,0x39,0x3F,0xDA,0xFD,0xA3,0xB7,
+0x27,0x44,0xF1,0x91,0x46,0x1C,0x91,0x1D,
+0x2D,0xD8,0x65,0x10,0xA6,0x26,0xA2,0x08,
+0x0F,0x17,0x9B,0x78,0xD0,0x2F,0x35,0x89,
+0x2F,0x24,0xD7,0xE6,0xF0,0xA9,0xDD,0xB3,
+0x27,0x62,0x34,0xC1,0x44,0xB2,0x73,0x9C,
+0x2F,0x37,0x91,0xCA,0x7A,0x94,0x4E,0xF8,
+0x2F,0x5D,0x62,0x64,0x34,0xB5,0x51,0x30,
+0x2F,0xCA,0xC3,0x49,0x58,0x6A,0x0F,0xA2,
+0x27,0x5C,0x5B,0x0D,0xA3,0x2B,0xE6,0xC8,
+0x2E,0xCC,0x6E,0x40,0xEF,0x3A,0xA3,0xA5,
+0x07,0x19,0x99,0x7A,0xF7,0x70,0xDB,0x9E,
+0x2F,0x46,0x2E,0xC5,0x6A,0xB7,0xF7,0x85,
+0x27,0x13,0x1D,0xC2,0x6F,0x2B,0x10,0xEA,
+0x27,0x0D,0x27,0x55,0x0C,0x43,0xAF,0x6C,
+0x27,0x15,0x25,0x60,0x43,0xC6,0x8F,0xC0,
+0x27,0xC1,0xB8,0x7F,0xEC,0xBD,0x92,0x8E,
+0x27,0x74,0x9C,0x83,0x41,0x89,0xBC,0xA5,
+0x2F,0x12,0xE0,0xE2,0x27,0x27,0x52,0x5F,
+0x2F,0xA5,0xA6,0x65,0x94,0x5E,0xD1,0x8C,
+0x27,0x15,0x6D,0x3C,0x24,0x6B,0xF8,0xE5,
+0x27,0x20,0x94,0xF4,0x90,0xE9,0xB0,0x1E,
+0x2F,0x58,0x50,0x29,0xCF,0x1A,0xE3,0x13,
+0x27,0xFB,0xF2,0x5C,0x4F,0x85,0xBF,0x07,
+0x2F,0xDA,0x64,0x53,0x4A,0x4A,0xC9,0xFA,
+0x27,0x2D,0x96,0x4F,0x94,0x73,0x55,0x84,
+0x27,0x86,0x60,0x27,0x2E,0x40,0xC8,0x34,
+0x2F,0xAE,0x06,0x27,0xB4,0x2C,0xFE,0xCB,
+0x27,0xE8,0x02,0x6E,0xF9,0x0C,0xF1,0xC6,
+0x27,0x33,0x39,0xCF,0xA1,0x35,0x2B,0x1E,
+0x27,0x1E,0xBB,0x1B,0x6E,0xDA,0x6B,0xA2,
+0x2F,0x56,0xD9,0x29,0xBC,0x3A,0x20,0x23,
+0x27,0x1F,0x7F,0xD6,0x29,0xF2,0x9A,0x85,
+0x2F,0xD1,0x88,0xF2,0x8C,0x6D,0x3F,0x19,
+0x2F,0xDB,0x65,0x4C,0x88,0x9C,0x9C,0xD0,
+0x27,0x6E,0xE9,0x5F,0xF4,0x6C,0x5A,0xB1,
+0x27,0xB3,0x08,0xF5,0x33,0x00,0x81,0xD4,
+0x2F,0x65,0xFE,0x70,0x67,0x36,0xFA,0x15,
+0x27,0x56,0x75,0x33,0x80,0xD0,0x3F,0x94,
+0x27,0x02,0xB4,0x8C,0xAD,0xB2,0xF9,0x18,
+0x27,0x4A,0x23,0x33,0x72,0xE5,0xD5,0x08,
+0x27,0xBC,0x7A,0xA5,0xB2,0x72,0xEE,0x34,
+0x27,0x52,0x90,0x50,0x97,0x80,0xD4,0x53,
+0x2F,0x38,0x15,0xDA,0x32,0x59,0x53,0xA6,
+0x07,0x28,0x84,0x18,0xB5,0x61,0xD6,0x93,
+0x2F,0xB1,0xB2,0xC4,0x7A,0x93,0x52,0x86,
+0x27,0x6C,0xF2,0x91,0x37,0xEC,0x24,0x38,
+0x27,0x5E,0x32,0xE4,0x47,0x98,0x3F,0x10,
+0x2F,0xCB,0x01,0xFA,0x77,0x9D,0x5C,0xA3,
+0x27,0x44,0x9A,0x61,0x99,0x6F,0x40,0xB7,
+0x21,0xC3,0xF9,0x54,0x68,0xD5,0x0F,0x8B,
+0x0F,0xC5,0x05,0xE9,0x0F,0x12,0xAB,0x42,
+0x2F,0x28,0x11,0x49,0x98,0x5C,0xA1,0x27,
+0x27,0xFE,0x3B,0xAC,0x5A,0xC5,0x26,0x9D,
+0x2F,0x2C,0x24,0xB4,0x5B,0x6B,0x9A,0x31,
+0x2B,0xAE,0x70,0x4D,0x7F,0x1E,0xC2,0xE9,
+0x07,0x85,0xD5,0x8A,0xD1,0xFA,0x08,0xDD,
+0x2F,0xA1,0x36,0x02,0x19,0xAC,0x3F,0xBE,
+0x27,0x31,0xD1,0x73,0x38,0x9C,0x98,0xBE,
+0x27,0x8A,0xEE,0x27,0x43,0x94,0x05,0xAB,
+0x2F,0xD2,0x4A,0x65,0x93,0x6B,0x61,0x75,
+0x27,0x0C,0x3A,0x3D,0xAA,0x5D,0x42,0x87,
+0x2F,0x7B,0x4C,0x20,0xB1,0x86,0xA3,0x09,
+0x27,0xE0,0xE3,0x93,0x8F,0xCF,0xF7,0x79,
+0x2F,0xD3,0xBC,0x50,0xFA,0x5A,0xC2,0xDF,
+0x2F,0x12,0xB4,0x07,0xC2,0x75,0x6D,0xC1,
+0x25,0x82,0x24,0xA5,0x33,0xE5,0x0B,0x0D,
+0x07,0x70,0xD8,0xEA,0x44,0x22,0xCD,0x4D,
+0x07,0xE8,0x81,0x71,0x80,0x15,0x43,0x05,
+0x07,0x4E,0xF2,0xE8,0xEB,0x2C,0x40,0x0E,
+0x2F,0x88,0x7C,0xDB,0xA3,0x69,0x21,0x56,
+0x21,0xEE,0x4B,0xF0,0x89,0xEE,0x7D,0xF1,
+0x0F,0x18,0x77,0x69,0xD4,0x6B,0x39,0x09,
+0x27,0x1B,0xD6,0x00,0xFC,0x61,0xAC,0x70,
+0x25,0x8E,0x6F,0xBC,0xA5,0x2A,0xBD,0x8D,
+0x0F,0x95,0xDB,0x72,0x32,0xC9,0xAA,0xDB,
+0x27,0x7B,0x93,0xE3,0x4E,0xCA,0x67,0xB9,
+0x25,0x58,0x11,0xA0,0x46,0x01,0x4D,0x76,
+0x07,0x81,0x22,0x6E,0x8D,0x41,0x85,0xAA,
+0x27,0x4D,0x67,0x2D,0xD3,0x02,0x39,0xA0,
+0x29,0x92,0xC7,0xB0,0xEA,0x7C,0x15,0x96,
+0x07,0x79,0x83,0xA2,0xCF,0xEC,0x19,0x82,
+0x2F,0xAE,0x2E,0xA7,0x5E,0x83,0xDB,0xE1,
+0x2F,0x38,0x60,0x71,0x44,0xD3,0xCD,0x92,
+0x2E,0x69,0x38,0x55,0x27,0xEA,0xDA,0xF7,
+0x0F,0x85,0x9B,0x3D,0x49,0x85,0x22,0xBB,
+0x2F,0x28,0x0A,0x13,0x14,0xEE,0x6E,0x42,
+0x29,0xC7,0x5A,0x03,0xD9,0xFB,0x36,0x91,
+0x0F,0xB9,0x0A,0x74,0xC2,0x02,0xC4,0xE8,
+0x2F,0xCB,0xD3,0x54,0xDA,0xB8,0x4C,0x23,
+0x27,0xFA,0x53,0x1E,0x9C,0xF9,0xE5,0x1F,
+0x2F,0x55,0x91,0xD3,0x0B,0xFE,0x90,0xAD,
+0x2F,0xEF,0x6F,0x01,0xD8,0x94,0xD0,0xCD,
+0x2C,0xCC,0x4F,0xED,0xDA,0xD3,0x88,0x5A,
+0x0F,0xC0,0x32,0xAA,0xF2,0xAF,0xBC,0x44,
+0x27,0x00,0x9D,0x6C,0x7B,0x49,0x95,0x5B,
+0x2D,0x5C,0xDE,0xBF,0x9D,0x76,0x55,0xAF,
+0x07,0xF0,0xCD,0x54,0xFD,0x3F,0xED,0x82,
+0x07,0xC4,0xFB,0x5F,0x50,0x93,0x40,0x87,
+0x0F,0x2B,0x3C,0x31,0xAC,0x4F,0x02,0x7B,
+0x07,0xC5,0xEF,0xFC,0x82,0xD1,0x47,0x1B,
+0x0F,0xF2,0x31,0xDF,0x4F,0x2D,0x60,0x65,
+0x27,0x73,0xA9,0x6E,0xE7,0x74,0x02,0xB6,
+0x2F,0x76,0x0A,0xBD,0xE4,0x7C,0xBD,0xFE,
+0x2F,0x9C,0xA5,0x23,0xD1,0x9E,0x93,0xF8,
+0x2F,0x0C,0x9B,0xAD,0x4B,0x77,0x1F,0x08,
+0x27,0x5A,0xE3,0x88,0xFF,0x55,0xF1,0xF1,
+0x27,0x35,0xCD,0x12,0x92,0x8D,0x9F,0x35,
+0x2F,0x14,0x91,0xEF,0x40,0x90,0x85,0x3F,
+0x2F,0x0F,0x49,0x60,0xA7,0xDB,0xC6,0xA1,
+0x2C,0x4E,0xA5,0x00,0x18,0x2B,0xAC,0xAD,
+0x07,0x7B,0xC5,0xF4,0x53,0x86,0x52,0xC5,
+0x2F,0xBE,0x70,0x49,0x2C,0x3B,0xF1,0x81,
+0x2F,0x79,0xFF,0xBF,0x60,0x17,0x97,0x09,
+0x27,0xAF,0xC8,0x62,0x42,0x48,0x25,0x40,
+0x27,0x12,0x2D,0xE8,0x80,0x8F,0x0C,0x33,
+0x2F,0x7E,0x42,0x81,0xEE,0x9E,0x69,0xBF,
+0x2F,0x12,0x71,0x03,0x82,0x70,0x33,0x25,
+0x26,0xD9,0x02,0xEC,0x14,0x09,0xC9,0xE8,
+0x07,0xE6,0x43,0x1C,0x5D,0x71,0x9D,0x0A,
+0x27,0x8D,0xD1,0x5B,0xEA,0xEE,0xED,0x02,
+0x27,0xBB,0xF7,0xEE,0xD7,0xBD,0xDA,0x1D,
+0x27,0x0E,0xC7,0x07,0x88,0xF0,0x2F,0xEE,
+0x2F,0x22,0xD2,0x04,0xEC,0x55,0x78,0x8A,
+0x27,0xBC,0x69,0x2B,0x64,0x32,0x0A,0xC9,
+0x2F,0xCF,0xB8,0xC6,0xD9,0x59,0x57,0xB1,
+0x2F,0x75,0xD9,0x2C,0x07,0xD6,0xB2,0xC4,
+0x2F,0x20,0x31,0x21,0xF6,0x06,0x96,0x94,
+0x27,0xE6,0x75,0x7E,0xAC,0x4A,0x6E,0xAB,
+0x27,0xFB,0x08,0xC6,0xBD,0x75,0x4D,0xEA,
+0x2F,0xB4,0x6E,0x81,0xB3,0xAB,0x02,0x42,
+0x23,0xF8,0x15,0x26,0x32,0x75,0xDF,0x72,
+0x0F,0x49,0x8F,0x7C,0x93,0x4B,0x37,0xDC,
+0x2C,0xD1,0xA8,0x52,0x86,0x68,0x5D,0xAB,
+0x07,0x07,0x4E,0xDD,0x24,0x83,0xB8,0xD1,
+0x07,0x6F,0x3E,0x82,0x9C,0xA9,0xDD,0x4F,
+0x27,0xD0,0xFC,0xC2,0xE0,0x52,0x7A,0xD8,
+0x2F,0x1A,0x11,0x94,0x9D,0xA9,0xC7,0x8A,
+0x2F,0x7D,0xE0,0xE9,0x52,0xB6,0x04,0x70,
+0x27,0xFD,0x65,0x95,0xDB,0x55,0x5E,0x24,
+0x2F,0x1F,0x6F,0x42,0x4A,0x41,0x3F,0x3A,
+0x2F,0xC0,0xE5,0xB2,0xD9,0xE1,0xA4,0xCE,
+0x2A,0x69,0xC5,0xC8,0x75,0x08,0xFA,0x2A,
+0x07,0x5D,0xA8,0x53,0xCE,0x9A,0xAF,0xD0,
+0x24,0x52,0x6F,0x31,0x98,0xF1,0x95,0x4E,
+0x07,0x46,0xFB,0x55,0x73,0x89,0x87,0x87,
+0x27,0x15,0x13,0x2E,0xA8,0x61,0xE8,0x2B,
+0x21,0x4D,0x0D,0xD4,0xE2,0xC3,0x05,0x13,
+0x0F,0xC5,0xCE,0x3E,0x77,0xA4,0x1C,0xCA,
+0x24,0x4C,0xA7,0x4B,0xDD,0xE0,0x2A,0xCD,
+0x07,0x4A,0x99,0xAB,0x1D,0xBD,0xFE,0x00,
+0x24,0x74,0xDB,0xC4,0x61,0x0F,0xC7,0xE8,
+0x07,0x8F,0x84,0x91,0xB2,0x40,0x47,0xD2,
+0x0F,0xE9,0x1E,0x6C,0x75,0xC6,0x84,0x3F,
+0x27,0x43,0x23,0x1B,0x9E,0x90,0x00,0x17,
+0x2F,0x0B,0x1B,0x03,0xB5,0x5C,0xAF,0xAF,
+0x2F,0x37,0xE9,0x0A,0xF9,0xCE,0x7F,0x3D,
+0x2F,0x67,0x60,0x16,0xCC,0xDE,0x27,0x0C,
+0x27,0x26,0x74,0x99,0x4A,0x49,0x4C,0x5D,
+0x21,0x70,0x68,0x23,0x2D,0xDC,0xEC,0xE9,
+0x07,0x2C,0x33,0xF8,0xE1,0xAE,0x94,0xE7,
+0x2F,0xAF,0x04,0xFD,0x68,0xE4,0xE7,0xD2,
+0x21,0x9A,0x2F,0xAD,0xD5,0x03,0x70,0xE8,
+0x07,0x1A,0x20,0x7D,0x42,0x45,0x8C,0xBC,
+0x2F,0x23,0x81,0x40,0x34,0xA8,0x52,0xF2,
+0x27,0xB1,0xDA,0x8E,0xC4,0x05,0x45,0xFE,
+0x26,0x2E,0x84,0xED,0x80,0x60,0x07,0x37,
+0x07,0x76,0x4C,0x0B,0x99,0xAF,0x9F,0x9E,
+0x2F,0x30,0xFE,0xA7,0xFD,0x08,0x3C,0xFD,
+0x2F,0x03,0x99,0x0A,0xA1,0x66,0x0B,0x6F,
+0x22,0xFF,0xA3,0x68,0xC9,0x3B,0x21,0x59,
+0x07,0xDB,0x4D,0xBB,0x94,0xC6,0x22,0x01,
+0x2F,0xC1,0xC5,0x08,0x89,0x97,0x95,0x6F,
+0x29,0x72,0xD5,0xE4,0x74,0xBE,0x97,0xA9,
+0x07,0x5A,0x76,0xCC,0xC7,0x7C,0xFA,0x9C,
+0x2C,0x5B,0x70,0xAC,0x8B,0xA4,0x19,0xC2,
+0x0F,0x2B,0xD9,0x42,0x3D,0x38,0xD3,0xBB,
+0x27,0x91,0xA8,0x3E,0xCB,0x17,0xF8,0x3B,
+0x27,0xD3,0xD1,0xDE,0x9F,0x5D,0x3D,0xEF,
+0x27,0x70,0x79,0x2C,0xD5,0x6E,0xDC,0x9D,
+0x2F,0x87,0xFE,0x37,0xE0,0xB4,0xF0,0x5A,
+0x0F,0x29,0xE7,0x55,0x6C,0xF7,0x0B,0x15,
+0x27,0x3E,0x53,0x34,0x6F,0x60,0xE2,0xCF,
+0x2F,0xFA,0x40,0xF5,0xAD,0x94,0x6C,0x13,
+0x27,0x91,0x51,0xC3,0x8F,0xBB,0xD4,0xB3,
+0x2F,0xB0,0x3D,0x05,0xDB,0x73,0x0A,0xD0,
+0x27,0xA0,0x26,0x2E,0x76,0xE8,0x7A,0x61,
+0x25,0x36,0x26,0x5D,0x2E,0x31,0x5C,0xA6,
+0x0F,0xC8,0x4F,0xDE,0x8B,0xA4,0x80,0x94,
+0x27,0x20,0xE8,0x39,0xCF,0x9A,0x3C,0xA5,
+0x27,0xAD,0x02,0xE8,0x6D,0xA9,0x60,0xA6,
+0x2F,0x13,0xBD,0x67,0xFC,0x49,0x49,0xB8,
+0x27,0x09,0xB8,0xC8,0x4B,0xC8,0xD5,0x23,
+0x2F,0x3B,0x5A,0xD3,0xA3,0xFA,0x5C,0x6D,
+0x27,0x93,0x21,0x35,0xE4,0xF6,0x17,0xF6,
+0x27,0x05,0x6C,0x8E,0xF3,0x2D,0x4C,0xB1,
+0x27,0x99,0xAA,0x1C,0x37,0x7B,0x89,0x7D,
+0x27,0xAD,0xDF,0x1D,0x1C,0x14,0x7E,0x87,
+0x2F,0x78,0xF8,0xD3,0xD3,0xC4,0xFF,0x3F,
+0x27,0x3C,0x81,0x4D,0xC9,0x44,0xFA,0xA6,
+0x27,0xCE,0xEF,0xF2,0xC7,0xAC,0x88,0x32,
+0x27,0xA6,0xEE,0x2C,0xCB,0xED,0x7D,0x55,
+0x25,0x53,0x71,0x36,0x01,0xD5,0x6A,0x50,
+0x07,0xC8,0xDB,0x66,0x99,0xCB,0x5D,0xC7,
+0x27,0xD0,0x96,0x05,0xF9,0xE9,0x03,0x14,
+0x27,0x71,0x9A,0x45,0xC4,0x73,0x86,0xF0,
+0x2F,0x2C,0x3E,0x64,0x06,0xB2,0xC8,0x05,
+0x2F,0x23,0x2C,0x27,0x6B,0xB7,0x50,0x84,
+0x2F,0xFB,0x78,0xFF,0xBA,0x9C,0x7C,0x37,
+0x2F,0xCD,0x76,0xCC,0x85,0x20,0x03,0xD1,
+0x2A,0xB0,0xE4,0x25,0x5E,0xF8,0xC8,0x3A,
+0x07,0xBB,0xCB,0xA9,0x2F,0xD0,0x4D,0x97,
+0x2F,0xF1,0x74,0x5C,0x95,0xC4,0xA2,0xB4,
+0x29,0x25,0xF6,0xF9,0x4E,0x13,0xE7,0x04,
+0x07,0x89,0xE0,0x1B,0x7C,0x4F,0x61,0x4C,
+0x24,0x4D,0x72,0x58,0x0C,0x92,0xC1,0x98,
+0x0F,0x1A,0x5F,0x17,0xB7,0xE8,0x09,0xCA,
+0x0F,0x30,0xB4,0xA5,0x83,0xB8,0xC2,0x58,
+0x27,0xE8,0x2D,0xB9,0x68,0xE8,0x63,0x7D,
+0x2F,0x4C,0xBF,0x16,0x8A,0x16,0x11,0xE4,
+0x2F,0x2C,0x12,0x93,0x6E,0x15,0x35,0x2F,
+0x23,0xA2,0x66,0x85,0x6B,0x6A,0xA1,0x9B,
+0x07,0x27,0xDA,0xA3,0xCF,0x4F,0xED,0x63,
+0x2F,0x1F,0xDF,0x09,0xD3,0x9C,0x80,0x91,
+0x21,0xF0,0x11,0x2D,0x7C,0xB6,0x70,0x82,
+0x07,0xC6,0x90,0x29,0x9D,0x15,0x8E,0x27,
+0x2F,0x87,0x17,0xF2,0xFE,0x4B,0x05,0xA9,
+0x2F,0x28,0xB1,0x41,0xEE,0x5A,0xD3,0x86,
+0x27,0x40,0xC9,0x1F,0x9C,0xD7,0x5E,0x69,
+0x27,0xA3,0x53,0x5C,0xCC,0x1D,0x4C,0xC5,
+0x2F,0xE7,0x50,0x50,0x76,0x13,0x8C,0xDA,
+0x2F,0xB3,0x3F,0xC3,0x4A,0x5B,0x43,0xEA,
+0x27,0x1A,0xF4,0x10,0x39,0x23,0xCF,0x9D,
+0x27,0x85,0x42,0x33,0x16,0x69,0x44,0xBF,
+0x2F,0x1E,0xDC,0x91,0x8B,0xB8,0xD4,0x73,
+0x2F,0x2A,0x31,0x52,0x88,0xA3,0xC0,0xF7,
+0x27,0x10,0x3C,0x9B,0x7E,0x03,0x32,0x5D,
+0x2F,0xD9,0x46,0x0A,0xE9,0x51,0x0C,0x45,
+0x2F,0xCE,0x3D,0x52,0xAE,0xCD,0x03,0x6B,
+0x27,0x23,0x87,0x86,0x03,0x26,0x93,0xFC,
+0x2F,0x59,0xD1,0xAB,0x3D,0xE3,0xEC,0x80,
+0x27,0x37,0x0E,0x6E,0x15,0x05,0x91,0x48,
+0x2F,0xAF,0x08,0x0A,0x3C,0xA1,0x35,0xE8,
+0x29,0x86,0xC6,0xEC,0x86,0x7B,0x1F,0xE7,
+0x0F,0x70,0x02,0x7E,0x1E,0xB8,0x5B,0x20,
+0x27,0xA7,0x5A,0x79,0x47,0x21,0xCB,0x32,
+0x2F,0xC8,0xD5,0x3F,0x61,0x85,0xF5,0x74,
+0x27,0xEF,0x83,0x95,0xBE,0x7F,0x48,0xC9,
+0x27,0x4E,0x7D,0xC5,0x12,0x3D,0xA8,0x4C,
+0x2F,0x57,0x6C,0x35,0xD7,0xF1,0xAE,0x07,
+0x27,0x27,0xDE,0xB4,0xBF,0xDB,0xE7,0xD4,
+0x27,0xE5,0x55,0x41,0x2B,0x07,0x61,0xA1,
+0x27,0x6F,0x9A,0x6E,0x1F,0x0A,0x58,0x32,
+0x27,0xFB,0xD7,0xDB,0xC6,0x7F,0x72,0xB4,
+0x27,0xFA,0x62,0x63,0x1A,0x75,0x12,0xEB,
+0x2F,0x47,0x1E,0xB0,0x09,0xFF,0x0C,0xBB,
+0x2F,0x21,0xD3,0x9C,0xC4,0x11,0xF3,0x35,
+0x27,0x89,0x79,0xE7,0x45,0x49,0x2E,0xA4,
+0x2F,0x0E,0xA2,0x00,0xE6,0x66,0x35,0xCD,
+0x27,0xFC,0xD1,0x6B,0x8E,0x06,0xD2,0xC1,
+0x2F,0x38,0x41,0x6D,0x1E,0xE1,0x05,0x51,
+0x27,0x6B,0xC2,0xD1,0x55,0xE0,0x6A,0xB3,
+0x27,0x81,0xD5,0xFF,0x2A,0x0B,0xEF,0x95,
+0x2F,0xDC,0x30,0xF0,0x0D,0xA1,0x5F,0xFB,
+0x2F,0xCB,0x39,0x1F,0x0A,0x1D,0x1D,0xD3,
+0x27,0x13,0x19,0xF4,0xA1,0xD9,0x25,0xD5,
+0x27,0x56,0xA5,0x89,0x30,0xBC,0xAE,0xA3,
+0x2F,0x2A,0x66,0xE3,0x6F,0x5A,0x0A,0xEE,
+0x27,0x4A,0xD9,0x4C,0x3C,0xDE,0xDE,0x50,
+0x27,0x96,0x75,0xE9,0xD2,0x45,0x10,0x1D,
+0x27,0xD6,0x3C,0x7C,0x83,0xA4,0xED,0x6F,
+0x2F,0xE9,0x3F,0x9A,0x36,0xDB,0x91,0xEC,
+0x2F,0x1C,0x6D,0x2F,0x93,0xA6,0x32,0xE3,
+0x2F,0xCF,0xAA,0xF0,0x9A,0xA9,0x39,0x1F,
+0x2F,0x8D,0x87,0xC1,0x47,0x95,0x3A,0xC9,
+0x27,0x68,0x81,0xF9,0xAA,0x1A,0x4C,0x19,
+0x2F,0xEB,0x62,0x69,0xC9,0xE4,0x6B,0x2F,
+0x27,0xA4,0x84,0xE4,0xB7,0xA5,0x93,0x91,
+0x2F,0xC3,0xB2,0x1A,0x74,0xFA,0x73,0x80,
+0x27,0x3A,0x17,0xB0,0x37,0x92,0x79,0xA4,
+0x27,0x8A,0xE6,0x86,0xBD,0x87,0xB0,0x2E,
+0x27,0xB7,0x49,0x5A,0xEC,0xB0,0xBC,0x2F,
+0x27,0xE4,0x4A,0x12,0xC7,0x60,0x0B,0x24,
+0x27,0xC6,0x56,0x0F,0xE9,0x94,0xCE,0xF6,
+0x27,0x01,0x99,0x1F,0xE2,0x2E,0x53,0x6A,
+0x2F,0x74,0x74,0x8F,0x3A,0x5D,0x57,0x0F,
+0x27,0x7D,0xFC,0xC5,0x84,0xCB,0x8E,0x7F,
+0x27,0xD5,0x56,0xDD,0x6E,0x2F,0xFF,0x19,
+0x23,0x6B,0x9D,0x36,0xCB,0xCF,0xDD,0x6D,
+0x0F,0x71,0x28,0x74,0x5B,0xFE,0x24,0x02,
+0x27,0xC7,0xA8,0xDC,0x31,0xDF,0x17,0x98,
+0x2F,0xBD,0xA6,0x23,0x6E,0x13,0x87,0x1C,
+0x27,0x53,0x77,0x69,0x14,0xA6,0xDC,0x04,
+0x23,0x5B,0xA6,0x12,0xDB,0x5F,0x14,0x17,
+0x0F,0xA3,0x3C,0xAE,0xB6,0x42,0xD5,0x39,
+0x2F,0x0F,0x74,0x08,0x2C,0x01,0x26,0xA2,
+0x2F,0xAB,0x35,0xCF,0xAC,0x9F,0xC5,0xFF,
+0x2F,0x66,0x9C,0x79,0x0E,0xC7,0x3B,0xE5,
+0x27,0x38,0x95,0xB9,0x7F,0x56,0xBD,0x6B,
+0x2F,0xAE,0x6B,0xC3,0x8B,0x64,0x25,0x6E,
+0x27,0xE5,0x23,0x15,0xD2,0x63,0xDB,0xF6,
+0x2F,0xAC,0x47,0x47,0x88,0xBC,0x9B,0xD0,
+0x27,0xA7,0x26,0x12,0x3A,0xCE,0x73,0x2E,
+0x24,0xFC,0x21,0x32,0x5D,0x0D,0x29,0xC6,
+0x07,0x5C,0x5C,0x22,0xD9,0xA0,0x3D,0xE9,
+0x0F,0xB1,0xD8,0x27,0xDD,0xF6,0xD6,0x8B,
+0x24,0xA3,0x06,0x62,0x51,0x2E,0x11,0x6D,
+0x07,0x9C,0xDD,0xB4,0xA0,0x1B,0x1B,0x0F,
+0x27,0x16,0x21,0x8B,0x35,0x24,0x94,0x47,
+0x2D,0x71,0x67,0x67,0x73,0xD2,0x75,0x28,
+0x0F,0x52,0x09,0x49,0xA7,0x99,0x63,0x8A,
+0x2F,0x02,0x6B,0x71,0x34,0x3F,0xCC,0x4C,
+0x27,0xC4,0xE5,0x45,0xD5,0xB9,0x55,0x37,
+0x22,0x81,0x4A,0x6A,0x9B,0xC5,0xD4,0x82,
+0x07,0x23,0x7F,0x35,0xC2,0x7D,0x66,0x4E,
+0x27,0x55,0x3F,0x07,0xC2,0x0C,0x55,0x28,
+0x29,0xCE,0x06,0x49,0xA8,0x46,0xE8,0xE5,
+0x07,0xE7,0x5D,0x37,0x5B,0xB9,0x8F,0xB5,
+0x2F,0x4D,0xF6,0x72,0xAD,0x9C,0xEA,0x40,
+0x2F,0xC2,0x73,0x91,0x56,0xB9,0xC3,0x36,
+0x2E,0x64,0x38,0xC4,0x28,0x46,0x94,0x19,
+0x0F,0x66,0x4D,0xF1,0xDB,0x81,0x35,0x7D,
+0x2F,0x7C,0xD5,0x9E,0x81,0xFC,0xF9,0xDD,
+0x2F,0x79,0x64,0x36,0x77,0x26,0x53,0x46,
+0x27,0x5D,0x90,0x44,0xFB,0x4B,0x8C,0xCE,
+0x27,0x65,0xB7,0x3B,0x42,0x29,0x0A,0x6C,
+0x2F,0x9B,0x1F,0x9E,0x50,0x5A,0xF1,0xF4,
+0x27,0xE8,0xC5,0x15,0x7F,0x83,0x8E,0x72,
+0x27,0x88,0x5D,0x21,0x3F,0xDD,0x10,0x10,
+0x27,0x3C,0xE1,0x81,0x87,0xDD,0x8C,0x8F,
+0x0F,0x11,0x8E,0xC2,0xD7,0x3F,0x68,0x92,
+0x07,0x71,0x46,0x44,0xE3,0xEC,0xF2,0xF1,
+0x07,0x7E,0xD1,0x5B,0x33,0xA7,0x6B,0x32,
+0x07,0x20,0xF5,0x42,0x2F,0xCE,0x06,0xE3,
+0x2F,0x76,0x8D,0x4B,0xE6,0x12,0x51,0xDE,
+0x2F,0x3A,0xB6,0x94,0x00,0x43,0x91,0xF0,
+0x2F,0x0B,0x16,0xA9,0x65,0xC8,0x3F,0x25,
+0x23,0x2B,0xCB,0x4A,0x80,0xC1,0xDC,0x1D,
+0x07,0x02,0xC9,0x4F,0x26,0x29,0x78,0xF4,
+0x07,0x91,0x2A,0x85,0xDB,0xE8,0x49,0xE1,
+0x27,0xED,0xD3,0xFE,0x27,0xF6,0x27,0x2B,
+0x2F,0xC1,0x4D,0x57,0xBA,0xA3,0x11,0x25,
+0x2F,0x1E,0xD7,0x8E,0x61,0x7B,0xDF,0x69,
+0x2F,0x33,0x51,0xB6,0x78,0x14,0x1B,0x6D,
+0x0F,0xC4,0xEE,0x07,0x3B,0x9B,0x54,0xC2,
+0x0F,0x97,0xCB,0x02,0x95,0x5C,0x16,0xBA,
+0x2C,0x62,0x9B,0xB5,0xEF,0xA7,0xCF,0x38,
+0x07,0x68,0xFC,0x1F,0x68,0x82,0x38,0x38,
+0x0F,0x21,0x78,0xF9,0x56,0xEA,0xE3,0x09,
+0x0F,0x81,0xD9,0xF5,0x1D,0x53,0x30,0x2F,
+0x0F,0xAA,0x8B,0x80,0x17,0x2F,0xE1,0x27,
+0x0F,0xB9,0xB2,0x52,0x5F,0x34,0xE0,0xFD,
+0x24,0xA5,0x03,0xEA,0x41,0x48,0x57,0x46,
+0x0F,0x86,0x8F,0xEF,0x88,0xEA,0xE7,0x8F,
+0x27,0xF9,0x5E,0x02,0xB4,0x7B,0x4F,0x9F,
+0x21,0x3A,0xE3,0xEE,0x24,0x62,0x3C,0x48,
+0x07,0x2A,0x54,0x17,0xAF,0x5D,0x5B,0xF2,
+0x27,0xB8,0x26,0x05,0x0B,0xC2,0x52,0xAA,
+0x21,0xC4,0xCF,0x0A,0x27,0x89,0xD4,0x0D,
+0x0F,0xF8,0xCD,0x4C,0xF2,0x95,0xE4,0x6E,
+0x2F,0xAC,0x17,0x9B,0x63,0xBC,0x00,0x62,
+0x21,0xFB,0xF3,0xBE,0xA3,0x85,0x76,0xD0,
+0x07,0x0B,0xD1,0x5D,0x63,0xAD,0x6C,0xDF,
+0x07,0xBE,0x90,0x56,0x49,0xA0,0xFC,0xEB,
+0x2F,0x99,0xD7,0xFC,0xD1,0xA4,0x91,0xD5,
+0x25,0x1F,0x4A,0x9E,0x93,0x0F,0xD8,0xFC,
+0x0F,0xB7,0xE9,0xBA,0x71,0x10,0x76,0xC0,
+0x2F,0x23,0x24,0x79,0xDB,0x29,0x79,0x2E,
+0x2F,0xA4,0xE0,0xB4,0x65,0x16,0x5E,0x31,
+0x2F,0x4D,0xA2,0x9B,0x18,0xE5,0xA9,0x6D,
+0x2F,0xA8,0x10,0x12,0xB9,0xF1,0xED,0xB9,
+0x27,0x93,0x34,0x5B,0xE8,0x32,0x81,0xFC,
+0x27,0x78,0xE3,0x29,0xB7,0xA8,0xBE,0xD4,
+0x27,0x6D,0x5E,0x8F,0x41,0x3E,0xC3,0x9E,
+0x27,0x55,0xB6,0x5D,0xC2,0xE3,0xB3,0xB7,
+0x27,0x7F,0xA6,0x92,0xB4,0x25,0xBF,0x03,
+0x21,0xC2,0xE0,0x5C,0x05,0x18,0xDC,0x19,
+0x0F,0x4A,0x25,0x88,0xE3,0x31,0x86,0xA3,
+0x27,0x28,0x23,0x4D,0xAE,0x70,0x0E,0xBC,
+0x27,0xE7,0xB6,0x01,0xD1,0x48,0xEA,0xF9,
+0x2F,0x30,0xE2,0x43,0xA3,0xB4,0x8F,0x9C,
+0x27,0x29,0xC7,0x19,0x4D,0xC8,0x90,0x82,
+0x0F,0x1D,0x88,0xD4,0x07,0xAA,0x41,0x57,
+0x2C,0x60,0x4B,0x88,0xC7,0x6A,0x79,0xBB,
+0x07,0x23,0xC4,0xBC,0xE1,0x85,0xDD,0x31,
+0x24,0xF9,0x3B,0xD1,0x0C,0xE1,0x05,0x97,
+0x07,0x05,0xA7,0xD5,0x7C,0x92,0x9E,0x58,
+0x2C,0xC6,0x61,0x95,0xD3,0x80,0xBE,0xAD,
+0x0F,0x37,0x95,0xC3,0x12,0xCE,0x15,0xC2,
+0x2F,0x6F,0x64,0xD7,0xCE,0xF4,0xD8,0x0A,
+0x2F,0x0C,0x74,0x57,0xCA,0x36,0xE1,0x8D,
+0x2F,0x59,0x83,0x55,0xD5,0x46,0x58,0x52,
+0x23,0xCE,0xA6,0xE9,0x54,0x55,0x52,0x5D,
+0x0F,0x98,0xFB,0xA3,0x72,0xF3,0x48,0xC2,
+0x27,0x1E,0x98,0x81,0xE9,0xBA,0x2D,0xB9,
+0x27,0x25,0xB2,0x47,0x91,0x05,0x6B,0x84,
+0x2F,0x9D,0x3D,0x77,0x39,0xF0,0xFF,0x88,
+0x2F,0xE8,0x7A,0x61,0xD3,0x92,0xC6,0xCB,
+0x2F,0x50,0xF7,0xE9,0x76,0xF0,0x6E,0xE3,
+0x25,0x04,0x18,0x0F,0x6E,0xB8,0x18,0xED,
+0x0F,0xA3,0xDC,0xAB,0xBD,0x38,0x13,0x12,
+0x27,0xB5,0x55,0x46,0xC7,0xDA,0x3C,0x5D,
+0x21,0xDA,0xD9,0x11,0x25,0x7F,0x88,0x54,
+0x07,0x15,0x6E,0x37,0xEF,0xA7,0x2E,0x20,
+0x2C,0x36,0x99,0x76,0x6C,0x47,0x2E,0xBE,
+0x0F,0x6E,0xF1,0x47,0x01,0xC9,0xC9,0xC8,
+0x2C,0x9C,0x06,0x63,0x02,0xA2,0x51,0xAB,
+0x0F,0x1C,0x3D,0x60,0x17,0x34,0xF6,0x1B,
+0x27,0x96,0x95,0xD7,0x6C,0xF7,0xF9,0xEB,
+0x27,0x02,0x6F,0x69,0x88,0xAD,0xB2,0xFE,
+0x2E,0x9F,0x9B,0xE8,0x5D,0xE4,0x61,0x1D,
+0x07,0x00,0xEC,0x5A,0xB4,0x6A,0x1E,0xB5,
+0x27,0x08,0x86,0x5A,0xB4,0x11,0xEB,0x79,
+0x27,0x86,0x63,0x39,0x50,0xAD,0xA6,0xC3,
+0x2F,0xD8,0xFF,0xAC,0x2C,0x3C,0x56,0xC4,
+0x2F,0x28,0xC1,0x15,0x24,0x49,0xB8,0x1C,
+0x2F,0xF5,0x53,0xCE,0x4E,0xE4,0x93,0xB4,
+0x2F,0x62,0x37,0x53,0x8C,0xDF,0xDE,0x80,
+0x27,0xA9,0xB3,0x77,0x8C,0x28,0x1F,0x08,
+0x2F,0x9B,0x3A,0xF2,0xD0,0x30,0x25,0xA8,
+0x2F,0x17,0x83,0x98,0xB3,0x1A,0x59,0xA8,
+0x2F,0x8B,0x2E,0x80,0xD9,0x30,0xEE,0xA6,
+0x27,0x86,0xA8,0x2E,0xDB,0x2B,0x34,0x57,
+0x27,0x56,0xC7,0xED,0xB7,0x84,0x9E,0x39,
+0x2F,0x0F,0x91,0x19,0xDA,0x8E,0x08,0xB1,
+0x27,0xBD,0x1C,0x3B,0x89,0x15,0x67,0x78,
+0x27,0x3E,0x8B,0x08,0xF3,0x8E,0x59,0xE9,
+0x27,0xC5,0x06,0xD3,0x73,0x90,0xCB,0x70,
+0x2F,0xB7,0xC7,0x50,0x6E,0x09,0x72,0x19,
+0x27,0x37,0x6A,0x15,0x4B,0x2A,0x4C,0x38,
+0x26,0xB3,0xE7,0x2A,0x30,0x37,0x40,0xD8,
+0x0F,0x91,0x56,0x15,0x0B,0xE6,0xB8,0x00,
+0x07,0xF1,0xEA,0x73,0x72,0x2B,0xCD,0xBA,
+0x27,0x08,0x8A,0xD8,0x1A,0xE9,0x7A,0xC6,
+0x27,0x4C,0x66,0x74,0x0C,0xCC,0x35,0x7A,
+0x27,0x34,0x02,0x14,0xE9,0x32,0x7C,0x83,
+0x2F,0x9C,0x7C,0xF4,0x3D,0xD0,0xA5,0x85,
+0x2F,0x28,0x79,0x86,0xB1,0xC1,0xCB,0xE8,
+0x27,0x81,0xCB,0x37,0xE1,0xBC,0x79,0xF6,
+0x27,0x7F,0x20,0xB6,0xB2,0x7D,0x03,0xC1,
+0x2F,0x5B,0xC9,0x77,0x56,0xE2,0xBA,0xFD,
+0x2F,0x44,0x5E,0x7B,0xC8,0x3B,0xBC,0xC7,
+0x2F,0x91,0xCF,0x66,0xAF,0x4E,0x0C,0xE7,
+0x27,0x3C,0x33,0xC3,0xA9,0x4C,0x36,0xAA,
+0x2F,0x4A,0x61,0x95,0x04,0x6A,0x03,0x7E,
+0x2F,0xB1,0xEE,0x65,0xDB,0x8A,0xCC,0x81,
+0x27,0x5B,0xE0,0x77,0x99,0x58,0x5D,0x54,
+0x27,0xB9,0x7F,0x9B,0xFD,0x81,0x32,0x0D,
+0x2F,0x1B,0x37,0x28,0x1C,0x30,0xEE,0x22,
+0x2F,0x64,0xDF,0xE8,0x33,0x93,0x67,0xA7,
+0x21,0xDF,0xBD,0x62,0x83,0xC4,0xD8,0x98,
+0x07,0x8F,0x0F,0x0A,0xAE,0x95,0x50,0x71,
+0x2F,0x00,0xC3,0x8E,0x29,0x2B,0x38,0xE7,
+0x2F,0x99,0xE4,0xF4,0x43,0x13,0x39,0x85,
+0x27,0x7D,0xC3,0x03,0x64,0x00,0x3B,0xAF,
+0x2F,0x65,0x41,0x08,0xDF,0xA4,0xE3,0x0A,
+0x2F,0xD9,0x10,0xC3,0x30,0x86,0xFD,0x99,
+0x21,0x5A,0x8F,0x51,0x75,0x64,0xC7,0x0B,
+0x0F,0x50,0x63,0xB4,0x85,0x51,0xAB,0xCA,
+0x2F,0x4A,0x05,0x42,0xA5,0x4D,0x37,0xC4,
+0x2F,0xD1,0x40,0x20,0xA7,0xD4,0x6F,0xFE,
+0x2F,0x14,0x57,0x3E,0x2D,0xB2,0x46,0xED,
+0x27,0x66,0x88,0xA4,0xD5,0x74,0x19,0x15,
+0x2F,0xD6,0x3F,0x33,0xEB,0xFC,0xD7,0x5E,
+0x27,0x28,0xA2,0x55,0xD3,0x8F,0x37,0x15,
+0x27,0xDE,0x57,0xCC,0xAD,0xE1,0x13,0x50,
+0x2F,0xE6,0x78,0x38,0x6C,0x5B,0xED,0x11,
+0x2F,0xD9,0x24,0x19,0x3C,0x2C,0xA7,0xA3,
+0x2F,0x09,0x78,0x4A,0xC7,0x12,0x8F,0x74,
+0x27,0xA0,0xDD,0xFB,0x62,0x09,0x1E,0x44,
+0x2F,0x7A,0x48,0x98,0x88,0xB0,0x76,0xB4,
+0x2F,0x87,0x8F,0xA5,0x8B,0x7E,0xC2,0x86,
+0x27,0xE7,0x87,0x06,0x2C,0xE7,0x5B,0x7B,
+0x26,0xE1,0xE8,0x48,0xB3,0xAE,0x5E,0xEE,
+0x07,0xC1,0x4B,0xAF,0x2B,0x75,0x4D,0x3B,
+0x27,0x95,0x48,0x70,0xE9,0x98,0x68,0xA0,
+0x2F,0x1C,0x7A,0x36,0xCB,0x42,0xDA,0xA5,
+0x2F,0x34,0x2A,0x81,0x1E,0xF8,0xF8,0x34,
+0x27,0xC0,0x00,0x64,0x36,0x51,0x5C,0xBB,
+0x27,0xC7,0xFD,0xE3,0xB2,0xF1,0x0B,0x30,
+0x27,0xC4,0xDC,0xC7,0x2B,0x16,0x8B,0x7A,
+0x27,0xE4,0x00,0xB3,0xD7,0xF3,0x2C,0x66,
+0x2F,0x67,0x5A,0x2F,0xB1,0xB9,0x4D,0x7F,
+0x2F,0xE1,0x63,0x7E,0xB2,0x0D,0xB3,0x71,
+0x2F,0x9D,0x69,0x02,0x8C,0x35,0xC9,0x33,
+0x2F,0x6B,0xDE,0xD5,0x9B,0xE3,0x77,0x53,
+0x27,0x79,0x14,0x84,0x6E,0x47,0x1F,0xA7,
+0x2F,0x34,0x2B,0xED,0xA6,0x96,0x94,0x30,
+0x2F,0x1D,0x73,0x7D,0x6D,0x20,0x01,0xFD,
+0x2F,0x10,0x54,0x8C,0x5C,0x29,0xCB,0x95,
+0x23,0x57,0x90,0x45,0xE8,0xDA,0x61,0x3B,
+0x0F,0x3A,0x3F,0x4E,0xFE,0xD8,0x6D,0x4A,
+0x2C,0x8E,0xD9,0x99,0x63,0x6F,0xAE,0x2A,
+0x07,0xAF,0x64,0x5E,0x5E,0xD1,0x2B,0x8F,
+0x27,0x36,0x9F,0x74,0x1F,0x4D,0x92,0xE5,
+0x2F,0xF6,0x03,0x83,0x49,0x45,0xB8,0xE1,
+0x2A,0x33,0x8D,0x79,0xE5,0x4C,0x57,0xB8,
+0x07,0x21,0x18,0xCE,0x7C,0x43,0xE9,0xA7,
+0x2F,0x67,0xD2,0x76,0x7D,0xA1,0x62,0x6F,
+0x27,0x24,0xF2,0x63,0x2E,0x10,0x17,0x4A,
+0x27,0x07,0xA3,0x98,0x17,0x12,0xBA,0xA9,
+0x2F,0xD9,0x20,0xC6,0xB6,0xE2,0x8F,0x7F,
+0x07,0x78,0xD8,0xDB,0x8D,0x00,0x7D,0xB9,
+0x24,0xB9,0x06,0xE1,0x65,0xD5,0x84,0x7F,
+0x07,0x91,0xF3,0xB0,0xBD,0x97,0xF2,0x11,
+0x27,0x86,0xB1,0xDA,0x39,0xD1,0x49,0xEB,
+0x27,0x6A,0x84,0xBA,0xA8,0xB3,0x8C,0xDB,
+0x2E,0xC5,0x00,0xEF,0xE6,0x22,0x64,0xBD,
+0x0F,0x87,0xA3,0xE6,0x13,0x2A,0xB8,0x14,
+0x27,0x1C,0xCF,0xBF,0xB6,0x4E,0xAB,0x5D,
+0x2F,0x7A,0x4C,0x42,0xA4,0x6A,0xF5,0x13,
+0x27,0xC0,0x13,0x0F,0xDC,0xB0,0x51,0x6D,
+0x27,0x09,0xF9,0x9E,0x51,0x83,0xD7,0x67,
+0x27,0xE8,0xB9,0x50,0xC1,0x6A,0xE9,0x22,
+0x27,0xA0,0xAE,0xD2,0xCC,0xF1,0x56,0x68,
+0x2F,0x2B,0xAF,0x8D,0x83,0x9E,0xEE,0x50,
+0x23,0x78,0xDA,0x1C,0x2B,0x6C,0xE2,0x68,
+0x07,0x1A,0xA3,0xDE,0xB7,0x6E,0xE7,0xA2,
+0x27,0xAC,0x79,0x08,0x55,0xE5,0xEC,0x39,
+0x2D,0x60,0xE7,0xC8,0xE1,0x18,0xA0,0xDA,
+0x07,0x34,0xCA,0x2C,0x16,0x14,0x4A,0x74,
+0x2F,0xB7,0xBA,0xDD,0xC7,0x2C,0x43,0x48,
+0x27,0x28,0x9B,0xDE,0xEF,0xA4,0x8D,0x94,
+0x27,0x80,0x0D,0x14,0x5C,0xA2,0xCC,0x70,
+0x27,0xA2,0x07,0xDD,0x03,0x97,0xE0,0x63,
+0x2F,0x2C,0x38,0xFB,0x20,0x21,0x64,0x69,
+0x2F,0x37,0xA4,0xAA,0xBA,0xF9,0x8C,0x78,
+0x2F,0x35,0x63,0xDE,0xD1,0xD6,0x84,0x71,
+0x27,0xEE,0xE2,0x23,0x4C,0x20,0xDB,0x53,
+0x2F,0xB3,0x6A,0xE4,0xC7,0x71,0xFB,0x53,
+0x2F,0x16,0x5E,0x11,0xB9,0xF7,0xE8,0x0B,
+0x27,0x98,0x17,0xC5,0xD3,0x8F,0xC3,0x39,
+0x27,0xF5,0x06,0x39,0xB0,0x50,0x6A,0xDB,
+0x27,0xBE,0xF8,0x42,0x93,0x51,0x19,0x6F,
+0x27,0x00,0xCF,0x74,0x96,0x21,0x91,0xDD,
+0x2F,0x82,0x97,0x2A,0xBB,0xA8,0x0D,0xA6,
+0x27,0x39,0xD5,0x4E,0xC3,0x97,0xF1,0xAB,
+0x2F,0x75,0x6C,0x20,0xDE,0x7C,0xB8,0x97,
+0x2F,0x1F,0xD6,0x2D,0xFC,0x70,0xB3,0x08,
+0x26,0x23,0x43,0x60,0xF7,0xF5,0x91,0x7A,
+0x0F,0x12,0xBE,0x3D,0x51,0x14,0x53,0x0C,
+0x27,0x4A,0xDC,0x9D,0x6B,0x63,0x1A,0x5B,
+0x27,0x62,0x05,0x68,0x14,0x9B,0xE3,0x13,
+0x27,0xFF,0xB6,0x79,0xDF,0x55,0x05,0xAA,
+0x2F,0xCC,0x94,0x33,0x7B,0xCA,0x0E,0x49,
+0x24,0x85,0xBA,0xD5,0xD6,0x5F,0x0C,0x20,
+0x0F,0x44,0x4F,0x52,0x6B,0x8F,0x73,0xD6,
+0x2F,0x75,0x64,0x75,0x52,0x17,0x4C,0xCC,
+0x27,0x12,0xB1,0x3A,0xEB,0x81,0x3C,0x46,
+0x27,0x52,0x35,0x4E,0x52,0xFA,0x72,0xD0,
+0x27,0x84,0xF0,0xD7,0xAA,0x81,0xB3,0xFC,
+0x27,0x1F,0xB5,0x86,0x25,0xA4,0x9B,0xA7,
+0x2F,0xFC,0xF2,0x7A,0x1B,0x89,0x13,0x4A,
+0x27,0xA5,0xE0,0x49,0xC7,0x6D,0xCC,0xA8,
+0x2F,0x78,0x20,0x19,0xA6,0x25,0xE4,0x90,
+0x27,0xBC,0xCA,0x71,0xCE,0xE1,0x76,0xD9,
+0x27,0xC1,0x3B,0xD8,0xB8,0x0E,0xA7,0xA1,
+0x2F,0x95,0xC1,0x05,0xBA,0x19,0x30,0x3F,
+0x2F,0xF6,0x82,0x8D,0x35,0xAD,0xD0,0xE6,
+0x07,0xC7,0x23,0x87,0x9C,0x04,0xBA,0xCD,
+0x27,0x67,0x8E,0xFB,0x52,0x3D,0x4C,0xF6,
+0x2D,0x15,0x62,0xFA,0xFD,0x11,0x06,0x01,
+0x0F,0x85,0x29,0x3A,0x04,0x22,0x12,0x22,
+0x24,0x34,0x91,0xA7,0xE9,0x7F,0xBA,0x2E,
+0x0F,0x1D,0x72,0x5A,0x51,0xF3,0xF1,0x5F,
+0x07,0xB0,0xA3,0x13,0x64,0x73,0x58,0x8C,
+0x2F,0xEA,0xFB,0xA1,0x23,0x47,0xCE,0x64,
+0x27,0xF8,0xCD,0xC8,0xFE,0xB2,0x03,0xFC,
+0x26,0xDA,0x67,0xCF,0xE5,0x06,0xBF,0xBA,
+0x0F,0xEB,0xE8,0x61,0x08,0x2E,0xC6,0x7B,
+0x07,0x81,0x4E,0xD3,0x80,0xEC,0x32,0x0A,
+0x27,0x20,0x31,0x87,0x71,0xF3,0xC0,0x1C,
+0x2F,0xD3,0x85,0x67,0x86,0xE7,0x32,0x8B,
+0x26,0xEA,0xB4,0x19,0x1B,0xAE,0x32,0xCB,
+0x07,0xB5,0x08,0x3C,0xF3,0xEA,0xB1,0xE1,
+0x2F,0x4B,0x8B,0x3F,0x5A,0x7A,0xDA,0x3B,
+0x2F,0x43,0x31,0xBF,0xC1,0x5B,0x97,0x9A,
+0x2F,0xD6,0xBF,0xF3,0xCD,0x47,0x88,0x59,
+0x27,0x48,0xD7,0x6E,0x8B,0x12,0xE8,0xB8,
+0x2F,0x8C,0xE4,0xE9,0x43,0xB1,0x86,0x87,
+0x2F,0x0E,0x63,0xBB,0x6B,0x28,0xEB,0x0C,
+0x2F,0x95,0x57,0x77,0x8D,0x96,0x2E,0x8A,
+0x2F,0x85,0x9A,0xED,0x67,0xCC,0x09,0xA5,
+0x2F,0xE8,0xC9,0xB6,0x79,0x60,0xD8,0x16,
+0x2F,0xC0,0x25,0x41,0xB3,0x2C,0x1C,0xBC,
+0x27,0xB6,0xA5,0xF4,0xDE,0xBC,0x92,0xB5,
+0x27,0x1E,0x9D,0x79,0x88,0xC1,0xA7,0xF5,
+0x27,0xD6,0x22,0x60,0xBC,0xBE,0x6E,0x44,
+0x21,0x1A,0xDD,0xDD,0x55,0xA1,0x95,0xCC,
+0x07,0x55,0x16,0xCE,0xCA,0x37,0xBC,0x04,
+0x24,0xC3,0x77,0xB3,0x67,0xC5,0x3E,0x5A,
+0x0F,0x38,0x81,0x6F,0xD0,0xE1,0x09,0x95,
+0x27,0x28,0x10,0x62,0xC0,0x5D,0x65,0x7B,
+0x21,0x91,0xCE,0x38,0x74,0x9C,0xBA,0xEF,
+0x07,0x36,0x9A,0x7C,0xE3,0x78,0xB7,0x51,
+0x2F,0x69,0x4B,0x74,0x9A,0x00,0x2F,0x6C,
+0x21,0x73,0xEB,0x72,0xA1,0xA9,0x32,0x3C,
+0x0F,0x83,0x6C,0x5D,0xBE,0x9D,0xF2,0x2D,
+0x07,0x2C,0xA1,0xB7,0x6B,0xFD,0x49,0x85,
+0x0F,0x8A,0x0A,0xBB,0xF8,0x79,0xDD,0x3C,
+0x27,0xA8,0x7D,0xFE,0xE5,0xFF,0x17,0x9D,
+0x27,0x72,0x30,0x69,0xEE,0x38,0x22,0xD0,
+0x2F,0x31,0xB0,0x36,0x7A,0x46,0x03,0x4D,
+0x2F,0x6E,0xDF,0x01,0xE3,0xA7,0xEE,0x75,
+0x27,0x22,0x2C,0x84,0xD7,0xF3,0x5E,0x99,
+0x29,0x36,0x8B,0x22,0xB7,0x54,0x7E,0xC5,
+0x0F,0xCF,0xE4,0x67,0xBC,0x82,0x1C,0x06,
+0x2F,0x9D,0x94,0x61,0x6E,0x36,0xBF,0xB1,
+0x2D,0x65,0xC2,0xEF,0xE8,0x7B,0x93,0xB8,
+0x07,0x15,0x5B,0x4E,0x6A,0xE3,0x91,0x48,
+0x24,0xC0,0x18,0x87,0x01,0x29,0x35,0x4D,
+0x07,0x2E,0x36,0x94,0x68,0x6A,0x9B,0x65,
+0x27,0x25,0x78,0xB5,0x99,0xF3,0x04,0x63,
+0x2F,0x0A,0x46,0x1D,0x61,0x63,0x2B,0xEC,
+0x27,0xD4,0x3A,0xBD,0x97,0xC9,0xDC,0xC2,
+0x27,0x1E,0x33,0xA0,0x0B,0x03,0x1F,0x96,
+0x27,0x94,0xD5,0x45,0x43,0x3E,0x33,0xCA,
+0x29,0x54,0xA6,0xA8,0xBD,0x1A,0x81,0x03,
+0x07,0x13,0x39,0xE5,0x9F,0x7B,0x58,0x6F,
+0x2F,0x47,0x08,0xFD,0x40,0xA0,0x6A,0xA9,
+0x2F,0x79,0xD0,0x99,0x07,0x4D,0xF5,0x58,
+0x2A,0x5B,0x94,0xBC,0x68,0x9F,0xAD,0x4B,
+0x07,0xBD,0xE3,0xF4,0xF0,0x32,0x2A,0xA3,
+0x24,0xB5,0xB6,0x34,0x81,0x09,0x69,0x84,
+0x0F,0xCF,0x2D,0xF0,0x71,0xBA,0xBE,0x93,
+0x2F,0x80,0xEC,0x9C,0xCF,0xAF,0x3A,0x1D,
+0x27,0x0B,0x0B,0x75,0x82,0x27,0xF7,0x98,
+0x27,0x4A,0xB2,0xAF,0x43,0x60,0xEE,0x0E,
+0x2F,0x13,0xFC,0xF0,0xD0,0xD6,0x20,0xF0,
+0x2F,0x1B,0xED,0x7A,0xFF,0x9D,0x57,0x07,
+0x29,0xE2,0x14,0x4E,0x63,0x79,0xD8,0xE8,
+0x0F,0x6B,0x95,0x4D,0xB3,0xB3,0x2A,0xB2,
+0x2F,0x65,0xCA,0xE9,0xBF,0xC5,0xE1,0xAE,
+0x29,0x9A,0x4B,0xFA,0x03,0xE8,0xA4,0x56,
+0x07,0x4D,0xDF,0x12,0xD4,0x7C,0x12,0xB4,
+0x2F,0x1B,0x42,0x92,0xC1,0x5E,0x9D,0xC9,
+0x27,0x32,0x4E,0xBA,0xC7,0xBF,0xC6,0xE0,
+0x2F,0xE9,0x64,0x85,0x93,0xEB,0x9C,0x22,
+0x2B,0x20,0xAD,0x1A,0xA1,0x66,0xDE,0x0A,
+0x07,0xBD,0x5A,0xE1,0x32,0xEE,0xC0,0x3F,
+0x2F,0x34,0x99,0x8B,0xD6,0x81,0x73,0xDA,
+0x27,0x3F,0xBD,0x47,0xFC,0xDA,0xBC,0x36,
+0x26,0x56,0xEF,0x4B,0x0A,0x46,0x61,0xD5,
+0x0F,0x4C,0x7E,0x29,0x50,0x70,0xBE,0x15,
+0x2F,0x0F,0x8E,0x5D,0xA0,0x08,0xED,0x8E,
+0x2D,0x94,0xB7,0xE9,0x2A,0x1C,0x55,0x27,
+0x0F,0xD6,0x14,0x0A,0xF6,0x64,0xC4,0x27,
+0x27,0xBE,0xAA,0x1C,0xA9,0x36,0x66,0x9A,
+0x27,0xC1,0x49,0x03,0x67,0xB9,0x83,0xE0,
+0x2F,0x90,0xD4,0x9F,0x65,0x92,0x76,0xCB,
+0x2F,0x20,0x08,0x94,0x71,0x9B,0x0E,0xA7,
+0x2F,0xB4,0xB7,0x81,0xFF,0x96,0x5B,0x45,
+0x2F,0x77,0xD4,0xCF,0xC7,0x54,0x4E,0x6C,
+0x2F,0xB6,0xE9,0xA3,0x60,0x8B,0x2B,0x42,
+0x2F,0x1A,0x11,0xFA,0xFB,0x9F,0xC9,0xCC,
+0x2C,0xD4,0x33,0xFE,0xFF,0xCF,0x28,0x14,
+0x07,0x03,0xDE,0xD0,0x9A,0xD3,0xFE,0x2E,
+0x27,0xBD,0x3E,0x64,0x02,0x7B,0xA9,0x15,
+0x2F,0xE3,0x1A,0x3F,0x3B,0xC4,0x7E,0x57,
+0x27,0x25,0xAC,0xD5,0xEC,0x98,0xEC,0x7D,
+0x27,0xFC,0xB9,0x50,0x66,0x70,0x33,0xF8,
+0x07,0x02,0x6A,0xA7,0x04,0x0B,0x55,0xE3,
+0x07,0x9A,0xB9,0x15,0xE7,0x30,0x74,0x78,
+0x2F,0xDD,0x98,0x57,0x5F,0x0F,0xF5,0xFB,
+0x27,0x4E,0x85,0x22,0xED,0x29,0x3F,0x94,
+0x2F,0xB3,0xE8,0xC9,0x5E,0x4C,0x4E,0x78,
+0x2F,0x27,0xB7,0x13,0x35,0x9E,0x6F,0xC8,
+0x0F,0x15,0x36,0x73,0x12,0x1C,0x62,0xFD,
+0x27,0xFD,0x39,0xF3,0xE0,0xFD,0xCB,0x20,
+0x2F,0xC6,0x2F,0xA1,0xE5,0x4A,0x36,0x16,
+0x2F,0x2B,0x8A,0xE7,0xCC,0xFA,0xCC,0xB4,
+0x27,0x58,0x72,0x45,0xE1,0x07,0x1F,0x82,
+0x2F,0x1D,0x4B,0xCC,0x81,0xED,0xB1,0x6C,
+0x2F,0x88,0x59,0x42,0xB2,0x25,0x58,0x9A,
+0x2F,0x6C,0x0A,0xC4,0x00,0x0D,0xDE,0x83,
+0x2B,0x9D,0x3B,0xE0,0x8E,0x37,0x71,0xCB,
+0x0F,0x01,0xBB,0x9D,0x6A,0x4D,0xBA,0x68,
+0x27,0x21,0x49,0xB6,0xB3,0x86,0xCF,0xD2,
+0x27,0x4D,0x7B,0x51,0xA7,0x6A,0x5D,0xD5,
+0x2F,0x61,0xB1,0x07,0xE7,0xD7,0x8E,0x29,
+0x27,0xD6,0x00,0xFF,0xBA,0x45,0x58,0xFC,
+0x2F,0xE3,0x34,0xEB,0x17,0xFB,0x7A,0x42,
+0x2D,0x1F,0x38,0x09,0xC0,0x37,0x05,0x7E,
+0x07,0x73,0xAC,0xB3,0x33,0xAF,0xF3,0x0E,
+0x24,0x25,0x7F,0x4F,0xDC,0xBE,0xCA,0x76,
+0x07,0xDC,0xA5,0x28,0x73,0xBA,0x35,0xEC,
+0x27,0x11,0x32,0xBE,0xDA,0xBB,0xDB,0x63,
+0x21,0x4A,0x13,0x92,0x2B,0xD3,0x23,0x4E,
+0x0F,0x22,0x95,0x6C,0xDE,0xB6,0x42,0x72,
+0x27,0x77,0x5D,0x4B,0xF9,0xAA,0x68,0xCF,
+0x27,0xD6,0x06,0x84,0x98,0xEE,0xC9,0xA2,
+0x27,0x6D,0xA3,0xC0,0x1F,0x00,0xCB,0xB3,
+0x2F,0x8D,0x02,0xD3,0xA1,0xA0,0x2E,0x74,
+0x27,0x9B,0x51,0x74,0xC7,0x7D,0x0B,0x30,
+0x2F,0x95,0xFB,0x41,0x43,0x98,0xBD,0xD7,
+0x27,0x77,0xE7,0x3C,0xF1,0x2F,0x25,0x21,
+0x2F,0x0A,0x13,0xD2,0xAD,0x38,0xE1,0xAD,
+0x27,0x6D,0xC8,0x7B,0xA4,0xFD,0x27,0xC6,
+0x2F,0xAE,0xE6,0x4A,0x0E,0x1D,0x73,0xB2,
+0x2F,0xD6,0xBE,0x68,0x42,0x82,0x97,0x73,
+0x27,0xFF,0x9B,0xD6,0x14,0xC3,0xE4,0xF0,
+0x24,0xC6,0x3C,0xF7,0x5E,0x57,0xB6,0x87,
+0x07,0x5B,0xDC,0x42,0x35,0x25,0x10,0x27,
+0x27,0xEF,0x4E,0x93,0xA2,0x03,0x73,0x26,
+0x27,0xC6,0x51,0xB2,0x6C,0x4A,0x65,0x84,
+0x27,0x0A,0xB0,0xB3,0x6E,0xA0,0x04,0xF0,
+0x2F,0xCD,0x15,0x68,0x4D,0xA8,0x38,0xA9,
+0x27,0x5D,0xB1,0xB2,0x61,0x29,0x9C,0xFE,
+0x2F,0x11,0x9D,0xA8,0x3F,0xDD,0xCE,0x68,
+0x2E,0x0B,0xE0,0x4E,0x7A,0x8E,0x6D,0x73,
+0x07,0x64,0x10,0x66,0x4E,0x30,0x43,0x34,
+0x2C,0x5B,0x4E,0xAC,0x43,0x44,0xBF,0x4D,
+0x07,0x4F,0xD2,0x40,0x5A,0x1C,0x5F,0xDA,
+0x2F,0x8E,0x10,0xE9,0x45,0xD2,0xA5,0xDF,
+0x25,0x1A,0x4E,0x84,0xF4,0x91,0xB6,0xB8,
+0x07,0x3A,0xE6,0x8B,0xBC,0xC5,0x08,0x73,
+0x2F,0xCA,0xC8,0xFD,0x07,0x39,0xBF,0x19,
+0x27,0x08,0xEA,0xE0,0x2C,0x0F,0x5D,0x0E,
+0x2F,0x7E,0x4A,0x5B,0x61,0xB9,0x16,0x8B,
+0x2F,0xC6,0x75,0x6D,0xE1,0xEC,0x21,0x59,
+0x07,0xF1,0x85,0xE5,0xB0,0x53,0xBA,0xA5,
+0x27,0x2F,0x60,0x72,0x26,0x03,0x85,0xE3,
+0x2F,0x64,0xC6,0xC7,0x41,0xB1,0xEB,0xCF,
+0x2F,0xE1,0xF4,0x75,0x0B,0x43,0x90,0x8D,
+0x27,0xDB,0x73,0x15,0xE3,0x1F,0xFF,0x66,
+0x27,0x6D,0x0D,0x48,0x50,0x67,0x40,0x15,
+0x2F,0xC5,0x96,0x2E,0x4F,0x17,0x0F,0x80,
+0x26,0xB6,0x94,0x3E,0xA6,0x02,0x77,0x79,
+0x0F,0x9E,0x06,0xBC,0xB3,0xD3,0x69,0x77,
+0x2F,0xA9,0x96,0x04,0xA5,0x3C,0xCD,0x33,
+0x2F,0xE9,0x2E,0xA1,0x84,0xB1,0x7E,0x21,
+0x27,0x3B,0xE9,0x9D,0xAD,0x5A,0xCE,0xA6,
+0x2F,0x9F,0x18,0x15,0xF3,0xC7,0x48,0xDA,
+0x0F,0x22,0x63,0x1F,0xDF,0x66,0x50,0x05,
+0x2F,0x06,0xB1,0xDD,0x27,0x3A,0x95,0x92,
+0x2F,0xAD,0x99,0xA5,0x51,0x96,0x27,0x4F,
+0x2F,0x11,0xE1,0x67,0xA2,0x21,0xD0,0x55,
+0x2F,0xA2,0xD3,0x8F,0xFB,0x1E,0xBF,0x7D,
+0x27,0xC4,0xC9,0x33,0xB6,0xF5,0x14,0x6B,
+0x27,0xEB,0x26,0x92,0x03,0x40,0x3F,0x66,
+0x2F,0x45,0x0E,0x96,0xC2,0xB2,0xFE,0x41,
+0x2F,0x05,0xD9,0xBD,0x85,0x7B,0x7F,0x40,
+0x2F,0x83,0x44,0x2A,0xFE,0x49,0x94,0x10,
+0x27,0xBC,0xC6,0x88,0xD3,0x6D,0xAC,0x39,
+0x2F,0x60,0x23,0xA4,0x8A,0x2C,0x21,0xCD,
+0x2F,0x4E,0xDF,0xFB,0xD0,0x4B,0xC8,0x8B,
+0x27,0x65,0x9F,0x8E,0x25,0xBB,0x6A,0x42,
+0x2F,0xF4,0xE6,0x03,0x0E,0x77,0x1B,0x5F,
+0x27,0x5A,0x5D,0xDD,0x56,0xEB,0xE4,0xC6,
+0x2F,0x44,0x3C,0x69,0x6E,0x07,0x09,0x2C,
+0x07,0xD2,0x8E,0x9D,0xBF,0x5B,0xB2,0x5C,
+0x2F,0x96,0xF4,0x18,0xC5,0xCC,0xCA,0x64,
+0x2F,0xE9,0x84,0x2C,0x9C,0x41,0xB8,0xD8,
+0x27,0x10,0xA3,0x16,0xD0,0x60,0xBD,0xAA,
+0x2F,0x7B,0x4E,0xA5,0x73,0x8D,0x75,0x33,
+0x2F,0x66,0x68,0xCF,0xFF,0x1B,0x2F,0x8A,
+0x27,0x23,0x67,0xEE,0x56,0xD1,0x25,0x27,
+0x2F,0x5D,0xBF,0xDF,0x3D,0xD6,0x76,0x35,
+0x2F,0x8C,0x4C,0xC1,0x36,0xEA,0xC4,0x79,
+0x2F,0x20,0x30,0x57,0x81,0x58,0x56,0xDA,
+0x27,0x20,0x8C,0x3B,0x55,0x03,0x5E,0xAB,
+0x2F,0x68,0xA0,0x57,0x29,0x34,0x98,0xCA,
+0x2F,0xD5,0x53,0xB6,0x36,0xA5,0x54,0x08,
+0x2F,0x32,0x48,0xB0,0x95,0x29,0x16,0xE4,
+0x27,0x59,0x98,0x37,0x87,0x65,0xCC,0x66,
+0x27,0x6E,0x3A,0x2F,0x7A,0x4D,0x99,0xB6,
+0x27,0x1D,0x69,0x3B,0x6D,0xFE,0xD8,0x38,
+0x2F,0xB3,0x7F,0xD9,0x95,0x9D,0x87,0xF1,
+0x2D,0x7A,0x93,0x1A,0x44,0xEA,0xA3,0x38,
+0x0F,0x4E,0xDA,0x0E,0xFB,0xC4,0x46,0x52,
+0x27,0x55,0x75,0x78,0x86,0x9B,0x5A,0x67,
+0x2F,0x61,0x4B,0x3E,0xE5,0xC2,0xCC,0x08,
+0x27,0x87,0x07,0xB0,0x49,0xC5,0x0A,0x48,
+0x27,0xFE,0x72,0x4E,0xA6,0xB4,0x21,0x50,
+0x2F,0x7C,0x97,0x56,0x51,0x2A,0xA8,0xED,
+0x25,0x56,0xB4,0xEF,0x78,0xDF,0x89,0x3C,
+0x07,0xFA,0xCC,0x03,0x88,0xAB,0xDD,0x10,
+0x27,0xB6,0xD1,0x58,0xC4,0xD3,0x25,0x21,
+0x2F,0x2A,0x7E,0x99,0xEA,0x7C,0x13,0x5A,
+0x27,0xD9,0xAB,0x37,0x08,0x11,0xDE,0x37,
+0x2F,0x7B,0x0B,0x68,0xC5,0x56,0x72,0xC6,
+0x27,0xCA,0x9E,0x49,0x80,0xC7,0x48,0xB2,
+0x27,0xEE,0x3D,0x0F,0x49,0xB9,0x2D,0xBA,
+0x27,0x29,0x97,0x69,0xB4,0xAB,0x03,0xF2,
+0x2F,0x87,0x96,0x42,0xD2,0xE6,0xB3,0x04,
+0x2F,0xF4,0xE4,0xB4,0x22,0xD9,0xA4,0x88,
+0x2F,0x2E,0x23,0x23,0xAF,0x58,0xD0,0x3E,
+0x2F,0x21,0x20,0xE0,0x21,0x9A,0x77,0x2B,
+0x2F,0x7B,0x13,0x00,0x83,0x29,0x82,0x9B,
+0x27,0x47,0x45,0x91,0x98,0x48,0xC3,0x34,
+0x2F,0xA0,0x13,0x04,0x3E,0xAD,0x3E,0xA3,
+0x2F,0xCC,0xD7,0x12,0xB2,0xA8,0xC8,0x14,
+0x2F,0x67,0x2C,0x8C,0x9E,0xDF,0xCD,0x61,
+0x27,0x33,0x6D,0xFC,0x46,0xAC,0xA7,0xD1,
+0x2F,0x64,0x73,0xCC,0x7C,0x5E,0x76,0x64,
+0x2F,0xD5,0x81,0x43,0x78,0xB5,0xC1,0x5D,
+0x2F,0x03,0xC1,0xFF,0x58,0x6E,0x66,0x2A,
+0x27,0x64,0x9F,0x0D,0x74,0xD5,0x7A,0xCE,
+0x2F,0x45,0x68,0xE3,0xA1,0x40,0x6F,0x83,
+0x27,0x5C,0x16,0xFE,0x24,0x43,0x59,0xA5,
+0x2F,0x86,0x23,0x13,0xE9,0xF2,0xD0,0x73,
+0x27,0x95,0xA5,0x2E,0x8F,0x37,0x35,0x09,
+0x2F,0x78,0xB1,0xD9,0x32,0x54,0x4D,0x6D,
+0x27,0x62,0x2D,0x28,0x12,0xB3,0x3C,0x24,
+0x2F,0x2C,0xA5,0x43,0xAB,0x37,0xFF,0x2A,
+0x27,0x8D,0x15,0x99,0x12,0x4C,0xC3,0x6F,
+0x27,0xF1,0x4D,0x31,0x7F,0xC5,0x81,0xF8,
+0x2F,0x15,0xB8,0x31,0xCA,0xF6,0x50,0x7B,
+0x2F,0xB2,0xD4,0xCB,0xB5,0xD9,0x22,0xE3,
+0x24,0xE4,0xBB,0x69,0x75,0x97,0xF8,0x87,
+0x07,0x31,0xC4,0xF1,0xAD,0xDC,0xD6,0xF7,
+0x27,0xD3,0x60,0xF3,0x00,0x13,0x44,0xD4,
+0x2F,0xAC,0xB0,0x3C,0x18,0x4B,0x39,0x95,
+0x2F,0xF4,0x97,0x4F,0x48,0x7C,0xAF,0x30,
+0x2F,0xA6,0x3F,0x38,0x57,0xBF,0x09,0xD7,
+0x27,0xC5,0x4A,0x25,0x53,0x05,0x6D,0xB8,
+0x2F,0x33,0x07,0xDE,0x5D,0xFB,0xF4,0x71,
+0x2F,0xFC,0x38,0x2D,0x5B,0x85,0x17,0x2B,
+0x27,0xD4,0xC8,0xB6,0x98,0x8F,0x22,0x82,
+0x27,0x51,0x8A,0xCC,0xF1,0xA1,0xE1,0x5F,
+0x2F,0x6E,0xFE,0xCE,0x4C,0x49,0x7A,0x6A,
+0x2E,0x58,0x6E,0x2F,0x0A,0x08,0xB3,0x53,
+0x0F,0x9E,0x21,0xAB,0x87,0xDF,0x94,0x51,
+0x07,0x52,0x54,0x60,0xC2,0x7B,0x11,0xB1,
+0x2C,0xA9,0x58,0x5E,0xF5,0x95,0x3D,0x67,
+0x07,0xDE,0xE4,0x4B,0xC4,0x13,0x2A,0x73,
+0x0F,0x49,0xFA,0x57,0x78,0xB6,0x7E,0x7E,
+0x2F,0x5D,0x71,0x54,0xA1,0x29,0x70,0x7F,
+0x27,0xCA,0x08,0x67,0xD9,0xD1,0x0F,0x42,
+0x2F,0x84,0x94,0xC0,0xA7,0xCA,0xE2,0xF5,
+0x2F,0x2E,0x12,0x84,0x07,0xE7,0xCD,0x4C,
+0x24,0xAB,0x05,0x1E,0x6A,0xA3,0xFD,0xA1,
+0x0F,0x53,0x9D,0xA9,0x39,0xBC,0x8C,0x04,
+0x27,0x99,0xD5,0x3C,0x71,0xCC,0xA9,0xC0,
+0x21,0xE4,0x41,0x7D,0xDB,0xAE,0x91,0x32,
+0x07,0x86,0x23,0xB0,0xDB,0x27,0xC3,0xFC,
+0x2F,0x34,0x70,0xD3,0xE3,0xB1,0x80,0x54,
+0x21,0xBF,0x0A,0xE0,0xD2,0x43,0x90,0x43,
+0x0F,0xD8,0xDB,0x8C,0x74,0x54,0xD4,0x9D,
+0x27,0xFA,0x89,0x5A,0x8C,0x77,0x3A,0x6F,
+0x2F,0x37,0xEF,0xAD,0x43,0xAB,0x91,0x9C,
+0x27,0xFD,0x8A,0xF1,0x4E,0x52,0x17,0x7C,
+0x2F,0xCE,0x72,0xE5,0xC5,0x9E,0x1E,0x9D,
+0x07,0xA4,0xBC,0x04,0xA6,0xDF,0xEB,0x83,
+0x2F,0x2E,0x87,0x7D,0x1F,0xE5,0x59,0x01,
+0x27,0xD2,0x58,0x62,0x7A,0x9B,0x07,0xC3,
+0x2F,0x5E,0x14,0xEA,0x1B,0x1F,0x98,0xD2,
+0x27,0x6A,0x9D,0xD1,0xCF,0xC8,0x8D,0xF3,
+0x27,0xA5,0x96,0xEB,0x18,0x76,0xC5,0xE9,
+0x2F,0x22,0xB3,0x95,0x59,0xA4,0x38,0xCE,
+0x27,0x91,0xAE,0x73,0xD6,0x43,0x93,0xCE,
+0x27,0xE4,0xA5,0xDB,0xAC,0x8D,0x85,0x60,
+0x27,0x08,0x23,0x57,0x0E,0xC6,0x09,0xA5,
+0x27,0xDA,0x73,0xC0,0x81,0x65,0xBB,0xCD,
+0x2F,0x04,0x81,0x81,0x4C,0xBA,0x63,0xEA,
+0x27,0x6B,0xB9,0xEF,0x65,0x4E,0x54,0x98,
+0x2F,0x2F,0xD0,0x97,0xE8,0x4C,0x3D,0xE3,
+0x27,0xFA,0xD8,0xA2,0x8E,0x3D,0xE4,0x84,
+0x27,0x59,0xDC,0x53,0x92,0x96,0xAB,0xD0,
+0x27,0xCB,0x46,0x67,0xAC,0x85,0x08,0xD3,
+0x2F,0x6B,0x38,0x6F,0x42,0x4D,0x8B,0x19,
+0x2F,0x3E,0x50,0x48,0x0D,0x63,0xD8,0x72,
+0x2F,0x67,0x31,0x42,0x64,0xEE,0xB6,0x72,
+0x27,0xC2,0x1B,0x9C,0x43,0xC9,0xC4,0x0D,
+0x2C,0xC4,0x75,0xC2,0x09,0xA0,0x90,0xD1,
+0x07,0x2C,0x94,0xCD,0x80,0xF0,0x6C,0xCF,
+0x27,0xEC,0xDF,0xCA,0x03,0xDD,0xC6,0x8A,
+0x27,0xBC,0xBA,0xD1,0x49,0xE9,0x13,0xC8,
+0x2F,0x38,0x4A,0x10,0x96,0xFA,0x43,0x31,
+0x27,0x40,0x1E,0xE9,0xA2,0xFB,0x36,0x23,
+0x27,0xE2,0x5F,0x1B,0xB6,0xC2,0xCD,0xF1,
+0x27,0x90,0xD7,0x01,0x8F,0x00,0x17,0xE4,
+0x2F,0x10,0x49,0xF2,0x02,0xEC,0xC6,0x10,
+0x27,0x56,0xB7,0xBE,0xA7,0xC3,0xB4,0x1D,
+0x2C,0x96,0xFA,0x25,0xC9,0xD1,0xEA,0x14,
+0x07,0x9A,0x89,0xA1,0x99,0x28,0xA2,0x1C,
+0x05,0xAB,0xF5,0x09,0x42,0xBE,0xFF,0x77,
+0x27,0x9B,0xFA,0xC3,0xA2,0x81,0x6F,0xEC,
+0x2D,0x69,0x00,0xA4,0xD1,0x6E,0xFD,0x2E,
+0x05,0x52,0xF8,0xBB,0x50,0x33,0xB7,0x3E
+};
+
+#define SIT2_PATCH_PER_LINE	8
+#define SIT2_PATCH_2_SIZE (sizeof(sit2_patch_2))
+#define SIT2_PATCH_3_SIZE (sizeof(sit2_patch_3))
+
+#endif /* SIT2_PRIV_H */
diff -urN a/drivers/media/pci/cx23885/cimax2.c b/drivers/media/pci/cx23885/cimax2.c
--- a/drivers/media/pci/cx23885/cimax2.c	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/pci/cx23885/cimax2.c	2013-03-31 22:03:29.000000000 +0800
@@ -415,7 +415,7 @@
 	return state->status;
 }
 
-int netup_ci_init(struct cx23885_tsport *port)
+int netup_ci_init(struct cx23885_tsport *port, bool isDVBSky)
 {
 	struct netup_ci_state *state;
 	u8 cimax_init[34] = {
@@ -464,6 +464,11 @@
 		goto err;
 	}
 
+	if(isDVBSky) {
+		cimax_init[32] = 0x22;
+		cimax_init[33] = 0x00;
+	}
+
 	port->port_priv = state;
 
 	switch (port->nr) {
@@ -537,3 +542,19 @@
 	dvb_ca_en50221_release(&state->ca);
 	kfree(state);
 }
+
+/* CI irq handler for DVBSky board*/
+int dvbsky_ci_slot_status(struct cx23885_dev *dev)
+{
+	struct cx23885_tsport *port = NULL;
+	struct netup_ci_state *state = NULL;
+
+	ci_dbg_print("%s:\n", __func__);
+
+	port = &dev->ts1;
+	state = port->port_priv;
+	schedule_work(&state->work);
+	ci_dbg_print("%s: Wakeup CI0\n", __func__);
+
+	return 1;
+}
diff -urN a/drivers/media/pci/cx23885/cimax2.h b/drivers/media/pci/cx23885/cimax2.h
--- a/drivers/media/pci/cx23885/cimax2.h	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/pci/cx23885/cimax2.h	2013-01-30 12:34:37.000000000 +0800
@@ -41,7 +41,9 @@
 extern int netup_ci_slot_status(struct cx23885_dev *dev, u32 pci_status);
 extern int netup_poll_ci_slot_status(struct dvb_ca_en50221 *en50221,
 						int slot, int open);
-extern int netup_ci_init(struct cx23885_tsport *port);
+extern int netup_ci_init(struct cx23885_tsport *port, bool isDVBSky);
 extern void netup_ci_exit(struct cx23885_tsport *port);
 
+extern int dvbsky_ci_slot_status(struct cx23885_dev *dev);
+
 #endif
diff -urN a/drivers/media/pci/cx23885/cx23885-cards.c b/drivers/media/pci/cx23885/cx23885-cards.c
--- a/drivers/media/pci/cx23885/cx23885-cards.c	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/pci/cx23885/cx23885-cards.c	2013-05-06 21:28:13.000000000 +0800
@@ -569,6 +569,39 @@
 		.name		= "TeVii S471",
 		.portb		= CX23885_MPEG_DVB,
 	},
+	[CX23885_BOARD_BST_PS8512] = {
+		.name		= "Bestunar PS8512",
+		.portb		= CX23885_MPEG_DVB,
+	},
+	[CX23885_BOARD_DVBSKY_S950] = {
+		.name		= "DVBSKY S950",
+		.portb		= CX23885_MPEG_DVB,
+	},
+	[CX23885_BOARD_DVBSKY_S952] = {
+		.name		= "DVBSKY S952",
+		.portb		= CX23885_MPEG_DVB,
+		.portc		= CX23885_MPEG_DVB,
+	},
+	[CX23885_BOARD_DVBSKY_S950_CI] = {
+		.ci_type	= 3,
+		.name		= "DVBSKY S950CI DVB-S2 CI",
+		.portb		= CX23885_MPEG_DVB,
+	},
+	[CX23885_BOARD_DVBSKY_C2800E_CI] = {
+		.ci_type	= 3,
+		.name		= "DVBSKY C2800E DVB-C CI",
+		.portb		= CX23885_MPEG_DVB,
+	},
+	[CX23885_BOARD_DVBSKY_T9580] = {
+		.name		= "DVBSKY T9580",
+		.portb		= CX23885_MPEG_DVB,
+		.portc		= CX23885_MPEG_DVB,
+	},
+	[CX23885_BOARD_DVBSKY_T980_CI] = {
+		.ci_type	= 3,
+		.name		= "DVBSKY T980CI DVB-T2/C CI",
+		.portb		= CX23885_MPEG_DVB,
+	},		
 	[CX23885_BOARD_PROF_8000] = {
 		.name		= "Prof Revolution DVB-S2 8000",
 		.portb		= CX23885_MPEG_DVB,
@@ -605,7 +638,7 @@
 				  CX25840_NONE1_CH3,
 			.amux   = CX25840_AUDIO6,
 		} },
-	}
+	}	
 };
 const unsigned int cx23885_bcount = ARRAY_SIZE(cx23885_boards);
 
@@ -818,6 +851,34 @@
 		.subdevice = 0x9022,
 		.card      = CX23885_BOARD_TEVII_S471,
 	}, {
+		.subvendor = 0x14f1,
+		.subdevice = 0x8512,
+		.card      = CX23885_BOARD_BST_PS8512,
+	}, {
+		.subvendor = 0x4254,
+		.subdevice = 0x0950,
+		.card      = CX23885_BOARD_DVBSKY_S950,		
+	}, {
+		.subvendor = 0x4254,
+		.subdevice = 0x0952,
+		.card      = CX23885_BOARD_DVBSKY_S952,
+	}, {
+		.subvendor = 0x4254,
+		.subdevice = 0x950C,
+		.card      = CX23885_BOARD_DVBSKY_S950_CI,
+	}, {
+		.subvendor = 0x4254,
+		.subdevice = 0x2800,
+		.card      = CX23885_BOARD_DVBSKY_C2800E_CI,
+	}, {
+		.subvendor = 0x4254,
+		.subdevice = 0x9580,
+		.card      = CX23885_BOARD_DVBSKY_T9580,
+	}, {
+		.subvendor = 0x4254,
+		.subdevice = 0x980C,
+		.card      = CX23885_BOARD_DVBSKY_T980_CI,
+	}, {
 		.subvendor = 0x8000,
 		.subdevice = 0x3034,
 		.card      = CX23885_BOARD_PROF_8000,
@@ -1224,7 +1285,7 @@
 		cx_set(GP0_IO, 0x00040004);
 		break;
 	case CX23885_BOARD_TBS_6920:
-	case CX23885_BOARD_PROF_8000:
+	case CX23885_BOARD_PROF_8000:	
 		cx_write(MC417_CTL, 0x00000036);
 		cx_write(MC417_OEN, 0x00001000);
 		cx_set(MC417_RWD, 0x00000002);
@@ -1394,9 +1455,85 @@
 		cx_set(GP0_IO, 0x00040004);
 		mdelay(60);
 		break;
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_BST_PS8512:			
+		cx23885_gpio_enable(dev, GPIO_2, 1);
+		cx23885_gpio_clear(dev, GPIO_2);
+		msleep(100);		
+		cx23885_gpio_set(dev, GPIO_2);
+		break;
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_T9580:
+		cx_write(MC417_CTL, 0x00000037);/* enable GPIO3-18 pins */
+		
+		cx23885_gpio_enable(dev, GPIO_2, 1);
+		cx23885_gpio_enable(dev, GPIO_11, 1);
+		
+		cx23885_gpio_clear(dev, GPIO_2);
+		cx23885_gpio_clear(dev, GPIO_11);
+		msleep(100);		
+		cx23885_gpio_set(dev, GPIO_2);
+		cx23885_gpio_set(dev, GPIO_11);	
+		break;
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T980_CI:
+		/* GPIO-0 INTA from CiMax, input
+		   GPIO-1 reset CiMax, output, high active
+		   GPIO-2 reset demod, output, low active
+		   GPIO-3 to GPIO-10 data/addr for CAM
+		   GPIO-11 ~CS0 to CiMax1
+		   GPIO-12 ~CS1 to CiMax2
+		   GPIO-13 ADL0 load LSB addr
+		   GPIO-14 ADL1 load MSB addr
+		   GPIO-15 ~RDY from CiMax
+		   GPIO-17 ~RD to CiMax
+		   GPIO-18 ~WR to CiMax
+		 */
+		cx_set(GP0_IO, 0x00060002); /* GPIO 1/2 as output */
+		cx_clear(GP0_IO, 0x00010004); /*GPIO 0 as input*/
+		mdelay(100);/* reset delay */
+		cx_set(GP0_IO, 0x00060004); /* GPIO as out, reset high */
+		cx_clear(GP0_IO, 0x00010002);
+		cx_write(MC417_CTL, 0x00000037);/* enable GPIO3-18 pins */
+		/* GPIO-15 IN as ~ACK, rest as OUT */
+		cx_write(MC417_OEN, 0x00001000);
+		/* ~RD, ~WR high; ADL0, ADL1 low; ~CS0, ~CS1 high */
+		cx_write(MC417_RWD, 0x0000c300);
+		/* enable irq */
+		cx_write(GPIO_ISM, 0x00000000);/* INTERRUPTS active low*/
+		break;
 	}
 }
 
+static int cx23885_ir_patch(struct i2c_adapter *i2c, u8 reg, u8 mask)
+{
+	struct i2c_msg msgs[2];
+	u8 tx_buf[2], rx_buf[1];
+	/* Write register address */
+	tx_buf[0] = reg;
+	msgs[0].addr = 0x4c;
+	msgs[0].flags = 0;
+	msgs[0].len = 1;
+	msgs[0].buf = (char *) tx_buf;
+	/* Read data from register */
+	msgs[1].addr = 0x4c;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = 1;
+	msgs[1].buf = (char *) rx_buf;	
+	
+	i2c_transfer(i2c, msgs, 2);
+
+	tx_buf[0] = reg;
+	tx_buf[1] = rx_buf[0] | mask;
+	msgs[0].addr = 0x4c;
+	msgs[0].flags = 0;
+	msgs[0].len = 2;
+	msgs[0].buf = (char *) tx_buf;
+	
+	return i2c_transfer(i2c, msgs, 1);
+}
+
 int cx23885_ir_init(struct cx23885_dev *dev)
 {
 	static struct v4l2_subdev_io_pin_config ir_rxtx_pin_cfg[] = {
@@ -1482,6 +1619,24 @@
 		v4l2_subdev_call(dev->sd_cx25840, core, s_io_pin_config,
 				 ir_rx_pin_cfg_count, ir_rx_pin_cfg);
 		break;
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T9580:
+	case CX23885_BOARD_DVBSKY_T980_CI:
+		dev->sd_ir = cx23885_find_hw(dev, CX23885_HW_AV_CORE);
+		if (dev->sd_ir == NULL) {
+			ret = -ENODEV;
+			break;
+		}
+		v4l2_subdev_call(dev->sd_cx25840, core, s_io_pin_config,
+				 ir_rx_pin_cfg_count, ir_rx_pin_cfg);
+				 
+		cx23885_ir_patch(&(dev->i2c_bus[2].i2c_adap),0x1f,0x80);
+		cx23885_ir_patch(&(dev->i2c_bus[2].i2c_adap),0x23,0x80);
+		break;
 	case CX23885_BOARD_HAUPPAUGE_HVR1250:
 		if (!enable_885_ir)
 			break;
@@ -1511,9 +1666,16 @@
 		cx23888_ir_remove(dev);
 		dev->sd_ir = NULL;
 		break;
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T9580:
+	case CX23885_BOARD_DVBSKY_T980_CI:		
 	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
 	case CX23885_BOARD_TEVII_S470:
-	case CX23885_BOARD_HAUPPAUGE_HVR1250:
+	case CX23885_BOARD_HAUPPAUGE_HVR1250:	
 	case CX23885_BOARD_MYGICA_X8507:
 		cx23885_irq_remove(dev, PCI_MSK_AV_CORE);
 		/* sd_ir is a duplicate pointer to the AV Core, just clear it */
@@ -1556,6 +1718,13 @@
 		if (dev->sd_ir)
 			cx23885_irq_add_enable(dev, PCI_MSK_IR);
 		break;
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T9580:
+	case CX23885_BOARD_DVBSKY_T980_CI:		
 	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
 	case CX23885_BOARD_TEVII_S470:
 	case CX23885_BOARD_HAUPPAUGE_HVR1250:
@@ -1657,6 +1826,11 @@
 		ts1->ts_clk_en_val = 0x1; /* Enable TS_CLK */
 		ts1->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
 		break;
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T980_CI:
 	case CX23885_BOARD_TEVII_S470:
 	case CX23885_BOARD_TEVII_S471:
 	case CX23885_BOARD_DVBWORLD_2005:
@@ -1694,6 +1868,22 @@
 		ts1->ts_clk_en_val = 0x1; /* Enable TS_CLK */
 		ts1->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
 		break;
+	case CX23885_BOARD_DVBSKY_S952:
+		ts1->gen_ctrl_val  = 0x5; /* Parallel */
+		ts1->ts_clk_en_val = 0x1; /* Enable TS_CLK */
+		ts1->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
+		ts2->gen_ctrl_val  = 0xe; /* Serial bus + punctured clock */
+		ts2->ts_clk_en_val = 0x1; /* Enable TS_CLK */
+		ts2->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
+		break;
+	case CX23885_BOARD_DVBSKY_T9580:
+		ts1->gen_ctrl_val  = 0x5; /* Parallel */
+		ts1->ts_clk_en_val = 0x1; /* Enable TS_CLK */
+		ts1->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
+		ts2->gen_ctrl_val  = 0x8; /* Serial bus */
+		ts2->ts_clk_en_val = 0x1; /* Enable TS_CLK */
+		ts2->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
+		break;		
 	case CX23885_BOARD_HAUPPAUGE_HVR1250:
 	case CX23885_BOARD_HAUPPAUGE_HVR1500:
 	case CX23885_BOARD_HAUPPAUGE_HVR1500Q:
@@ -1749,6 +1939,13 @@
 	case CX23885_BOARD_MPX885:
 	case CX23885_BOARD_MYGICA_X8507:
 	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T9580:
+	case CX23885_BOARD_DVBSKY_T980_CI:
 	case CX23885_BOARD_AVERMEDIA_HC81R:
 		dev->sd_cx25840 = v4l2_i2c_new_subdev(&dev->v4l2_dev,
 				&dev->i2c_bus[2].i2c_adap,
diff -urN a/drivers/media/pci/cx23885/cx23885-core.c b/drivers/media/pci/cx23885/cx23885-core.c
--- a/drivers/media/pci/cx23885/cx23885-core.c	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/pci/cx23885/cx23885-core.c	2013-05-06 21:29:48.000000000 +0800
@@ -1909,6 +1909,10 @@
 			(pci_status & PCI_MSK_GPIO0))
 		handled += altera_ci_irq(dev);
 
+	if (cx23885_boards[dev->board].ci_type == 3 &&
+			(pci_status & PCI_MSK_GPIO0))
+		handled += dvbsky_ci_slot_status(dev);
+		
 	if (ts1_status) {
 		if (cx23885_boards[dev->board].portb == CX23885_MPEG_DVB)
 			handled += cx23885_irq_ts(ts1, ts1_status);
@@ -2144,6 +2148,9 @@
 		cx23885_irq_add_enable(dev, PCI_MSK_GPIO1 | PCI_MSK_GPIO0);
 		break;
 	case CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T980_CI:
 		cx23885_irq_add_enable(dev, PCI_MSK_GPIO0);
 		break;
 	}
diff -urN a/drivers/media/pci/cx23885/cx23885-dvb.c b/drivers/media/pci/cx23885/cx23885-dvb.c
--- a/drivers/media/pci/cx23885/cx23885-dvb.c	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/pci/cx23885/cx23885-dvb.c	2013-05-06 21:39:06.000000000 +0800
@@ -51,6 +51,9 @@
 #include "stv6110.h"
 #include "lnbh24.h"
 #include "cx24116.h"
+#include "m88ds3103.h"
+#include "m88dc2800.h"
+#include "sit2.h"
 #include "cimax2.h"
 #include "lgs8gxx.h"
 #include "netup-eeprom.h"
@@ -64,8 +67,8 @@
 #include "stv0367.h"
 #include "drxk.h"
 #include "mt2063.h"
-#include "stv090x.h"
-#include "stb6100.h"
+#include "stv090x.h"
+#include "stb6100.h"
 #include "stb6100_cfg.h"
 #include "tda10071.h"
 #include "a8293.h"
@@ -500,42 +503,142 @@
 	.if_khz = 5380,
 };
 
-static struct stv090x_config prof_8000_stv090x_config = {
-	.device                 = STV0903,
-	.demod_mode             = STV090x_SINGLE,
-	.clk_mode               = STV090x_CLK_EXT,
-	.xtal                   = 27000000,
-	.address                = 0x6A,
-	.ts1_mode               = STV090x_TSMODE_PARALLEL_PUNCTURED,
-	.repeater_level         = STV090x_RPTLEVEL_64,
-	.adc1_range             = STV090x_ADC_2Vpp,
-	.diseqc_envelope_mode   = false,
-
-	.tuner_get_frequency    = stb6100_get_frequency,
-	.tuner_set_frequency    = stb6100_set_frequency,
-	.tuner_set_bandwidth    = stb6100_set_bandwidth,
-	.tuner_get_bandwidth    = stb6100_get_bandwidth,
-};
 
-static struct stb6100_config prof_8000_stb6100_config = {
-	.tuner_address = 0x60,
-	.refclock = 27000000,
-};
-
-static int p8000_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+/* bst control */
+int bst_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
 {
 	struct cx23885_tsport *port = fe->dvb->priv;
 	struct cx23885_dev *dev = port->dev;
+	
+	cx23885_gpio_enable(dev, GPIO_1, 1);
+	cx23885_gpio_enable(dev, GPIO_0, 1);
+
+	switch (voltage) {
+	case SEC_VOLTAGE_13:
+		cx23885_gpio_set(dev, GPIO_1);
+		cx23885_gpio_clear(dev, GPIO_0);
+		break;
+	case SEC_VOLTAGE_18:
+		cx23885_gpio_set(dev, GPIO_1);
+		cx23885_gpio_set(dev, GPIO_0);
+		break;
+	case SEC_VOLTAGE_OFF:
+		cx23885_gpio_clear(dev, GPIO_1);
+		cx23885_gpio_clear(dev, GPIO_0);
+		break;
+	}
+	return 0;
+}
 
-	if (voltage == SEC_VOLTAGE_18)
-		cx_write(MC417_RWD, 0x00001e00);
-	else if (voltage == SEC_VOLTAGE_13)
-		cx_write(MC417_RWD, 0x00001a00);
-	else
-		cx_write(MC417_RWD, 0x00001800);
+int dvbsky_set_voltage_sec(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	struct cx23885_tsport *port = fe->dvb->priv;
+	struct cx23885_dev *dev = port->dev;
+	
+	cx23885_gpio_enable(dev, GPIO_12, 1);
+	cx23885_gpio_enable(dev, GPIO_13, 1);
+
+	switch (voltage) {
+	case SEC_VOLTAGE_13:
+		cx23885_gpio_set(dev, GPIO_13);
+		cx23885_gpio_clear(dev, GPIO_12);
+		break;
+	case SEC_VOLTAGE_18:
+		cx23885_gpio_set(dev, GPIO_13);
+		cx23885_gpio_set(dev, GPIO_12);
+		break;
+	case SEC_VOLTAGE_OFF:
+		cx23885_gpio_clear(dev, GPIO_13);
+		cx23885_gpio_clear(dev, GPIO_12);
+		break;
+	}
 	return 0;
 }
 
+/* bestunar single dvb-s2 */
+static struct m88ds3103_config bst_ds3103_config = {
+	.demod_address = 0x68,
+	.ci_mode = 0,
+	.pin_ctrl = 0x82,
+	.ts_mode = 0,
+	.set_voltage = bst_set_voltage,
+};
+/* DVBSKY dual dvb-s2 */
+static struct m88ds3103_config dvbsky_ds3103_config_pri = {
+	.demod_address = 0x68,
+	.ci_mode = 0,
+	.pin_ctrl = 0x82,
+	.ts_mode = 0,
+	.set_voltage = bst_set_voltage,	
+};
+static struct m88ds3103_config dvbsky_ds3103_config_sec = {
+	.demod_address = 0x68,
+	.ci_mode = 0,
+	.pin_ctrl = 0x82,
+	.ts_mode = 1,
+	.set_voltage = dvbsky_set_voltage_sec,	
+};
+
+static struct m88ds3103_config dvbsky_ds3103_ci_config = {
+	.demod_address = 0x68,
+	.ci_mode = 2,
+	.pin_ctrl = 0x82,
+	.ts_mode = 0,
+};
+
+static struct m88dc2800_config dvbsky_dc2800_config = {
+	.demod_address = 0x1c,
+	.ts_mode = 3,	
+};
+
+static struct sit2_config dvbsky_sit2_config_pci_p = {
+	.ts_bus_mode = 2,
+	.ts_clock_mode = 0,
+	.start_ctrl = NULL,
+};
+
+static struct sit2_config dvbsky_sit2_config_pci_s = {
+	.ts_bus_mode = 1,
+	.ts_clock_mode = 0,
+	.start_ctrl = NULL,
+};
+
+static struct stv090x_config prof_8000_stv090x_config = {
+        .device                 = STV0903,
+        .demod_mode             = STV090x_SINGLE,
+        .clk_mode               = STV090x_CLK_EXT,
+        .xtal                   = 27000000,
+        .address                = 0x6A,
+        .ts1_mode               = STV090x_TSMODE_PARALLEL_PUNCTURED,
+        .repeater_level         = STV090x_RPTLEVEL_64,
+        .adc1_range             = STV090x_ADC_2Vpp,
+        .diseqc_envelope_mode   = false,
+
+        .tuner_get_frequency    = stb6100_get_frequency,
+        .tuner_set_frequency    = stb6100_set_frequency,
+        .tuner_set_bandwidth    = stb6100_set_bandwidth,
+        .tuner_get_bandwidth    = stb6100_get_bandwidth,
+};
+
+static struct stb6100_config prof_8000_stb6100_config = {
+	.tuner_address = 0x60,
+	.refclock = 27000000,
+};
+
+static int p8000_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	struct cx23885_tsport *port = fe->dvb->priv;
+	struct cx23885_dev *dev = port->dev;
+
+	if (voltage == SEC_VOLTAGE_18)
+		cx_write(MC417_RWD, 0x00001e00);
+	else if (voltage == SEC_VOLTAGE_13)
+		cx_write(MC417_RWD, 0x00001a00);
+	else
+		cx_write(MC417_RWD, 0x00001800);
+	return 0;
+}
+
 static int cx23885_dvb_set_frontend(struct dvb_frontend *fe)
 {
 	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
@@ -1250,23 +1353,90 @@
 					&tevii_ds3000_config,
 					&i2c_bus->i2c_adap);
 		break;
-	case CX23885_BOARD_PROF_8000:
-		i2c_bus = &dev->i2c_bus[0];
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+		i2c_bus = &dev->i2c_bus[1];	
+		fe0->dvb.frontend = dvb_attach(m88ds3103_attach,
+					&bst_ds3103_config,
+					&i2c_bus->i2c_adap);
+		break;	
+			
+	case CX23885_BOARD_DVBSKY_S952:
+		switch (port->nr) {
+		/* port B */
+		case 1:
+			i2c_bus = &dev->i2c_bus[1];
+			fe0->dvb.frontend = dvb_attach(m88ds3103_attach,
+						&dvbsky_ds3103_config_pri,
+						&i2c_bus->i2c_adap);
+			break;
+		/* port C */
+		case 2:
+			i2c_bus = &dev->i2c_bus[0];
+			fe0->dvb.frontend = dvb_attach(m88ds3103_attach,
+						&dvbsky_ds3103_config_sec,
+						&i2c_bus->i2c_adap);	
+			break;
+		}
+		break;
 
-		fe0->dvb.frontend = dvb_attach(stv090x_attach,
-						&prof_8000_stv090x_config,
-						&i2c_bus->i2c_adap,
-						STV090x_DEMODULATOR_0);
-		if (fe0->dvb.frontend != NULL) {
-			if (!dvb_attach(stb6100_attach,
-					fe0->dvb.frontend,
-					&prof_8000_stb6100_config,
-					&i2c_bus->i2c_adap))
-				goto frontend_detach;
+	case CX23885_BOARD_DVBSKY_S950_CI:
+		i2c_bus = &dev->i2c_bus[1];	
+		fe0->dvb.frontend = dvb_attach(m88ds3103_attach,
+					&dvbsky_ds3103_ci_config,
+					&i2c_bus->i2c_adap);
+		break;
+				
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+		i2c_bus = &dev->i2c_bus[1];	
+		fe0->dvb.frontend = dvb_attach(m88dc2800_attach,
+					&dvbsky_dc2800_config,
+					&i2c_bus->i2c_adap);
+		break;
 
-			fe0->dvb.frontend->ops.set_voltage = p8000_set_voltage;
+	case CX23885_BOARD_DVBSKY_T9580:
+		switch (port->nr) {
+		/* port B */
+		case 1:
+			i2c_bus = &dev->i2c_bus[1];
+			fe0->dvb.frontend = dvb_attach(m88ds3103_attach,
+						&dvbsky_ds3103_config_pri,
+						&i2c_bus->i2c_adap);
+			break;
+		/* port C */
+		case 2:
+			i2c_bus = &dev->i2c_bus[0];
+			fe0->dvb.frontend = dvb_attach(sit2_attach,
+						&dvbsky_sit2_config_pci_s,
+						&i2c_bus->i2c_adap);	
+			break;
 		}
 		break;
+				
+	case CX23885_BOARD_DVBSKY_T980_CI:
+		i2c_bus = &dev->i2c_bus[1];	
+		fe0->dvb.frontend = dvb_attach(sit2_attach,
+					&dvbsky_sit2_config_pci_p,
+					&i2c_bus->i2c_adap);
+		break;
+				
+	case CX23885_BOARD_PROF_8000:
+		i2c_bus = &dev->i2c_bus[0];
+
+		fe0->dvb.frontend = dvb_attach(stv090x_attach,
+						&prof_8000_stv090x_config,
+						&i2c_bus->i2c_adap,
+						STV090x_DEMODULATOR_0);
+		if (fe0->dvb.frontend != NULL) {
+			if (!dvb_attach(stb6100_attach,
+					fe0->dvb.frontend,
+					&prof_8000_stb6100_config,
+					&i2c_bus->i2c_adap))
+				goto frontend_detach;
+
+			fe0->dvb.frontend->ops.set_voltage = p8000_set_voltage;
+		}
+		break;
 	case CX23885_BOARD_HAUPPAUGE_HVR4400:
 		i2c_bus = &dev->i2c_bus[0];
 		fe0->dvb.frontend = dvb_attach(tda10071_attach,
@@ -1325,7 +1495,7 @@
 		printk(KERN_INFO "NetUP Dual DVB-S2 CI card port%d MAC=%pM\n",
 			port->nr, port->frontends.adapter.proposed_mac);
 
-		netup_ci_init(port);
+		netup_ci_init(port, false);
 		break;
 		}
 	case CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF: {
@@ -1352,6 +1522,42 @@
 		memcpy(port->frontends.adapter.proposed_mac, eeprom + 0xa0, 6);
 		break;
 		}
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_T9580:{
+		u8 eeprom[256]; /* 24C02 i2c eeprom */
+
+		if(port->nr > 2)
+			break;
+
+		dev->i2c_bus[0].i2c_client.addr = 0xa0 >> 1;
+		tveeprom_read(&dev->i2c_bus[0].i2c_client, eeprom, sizeof(eeprom));
+		printk(KERN_INFO "DVBSKY PCIe MAC= %pM\n", eeprom + 0xc0+(port->nr-1)*8);
+		memcpy(port->frontends.adapter.proposed_mac, eeprom + 0xc0 + 
+			(port->nr-1)*8, 6);
+		break;
+		}
+	case CX23885_BOARD_DVBSKY_S950_CI: {
+		u8 eeprom[256]; /* 24C02 i2c eeprom */
+
+		if(port->nr > 2)
+			break;
+
+		dev->i2c_bus[0].i2c_client.addr = 0xa0 >> 1;
+		tveeprom_read(&dev->i2c_bus[0].i2c_client, eeprom, sizeof(eeprom));
+		printk(KERN_INFO "DVBSKY PCIe MAC= %pM\n", eeprom + 0xc0+(port->nr-1)*8);
+		memcpy(port->frontends.adapter.proposed_mac, eeprom + 0xc0 + 
+			(port->nr-1)*8, 6);
+			
+		netup_ci_init(port, true);
+		break;
+		}
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T980_CI: {
+		netup_ci_init(port, true);
+		break;
+		}		
 	}
 
 	return ret;
@@ -1434,6 +1640,9 @@
 
 	switch (port->dev->board) {
 	case CX23885_BOARD_NETUP_DUAL_DVBS2_CI:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T980_CI:
 		netup_ci_exit(port);
 		break;
 	case CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:
diff -urN a/drivers/media/pci/cx23885/cx23885.h b/drivers/media/pci/cx23885/cx23885.h
--- a/drivers/media/pci/cx23885/cx23885.h	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/pci/cx23885/cx23885.h	2013-05-06 21:42:12.000000000 +0800
@@ -94,6 +94,15 @@
 #define CX23885_BOARD_HAUPPAUGE_HVR4400        38
 #define CX23885_BOARD_AVERMEDIA_HC81R          39
 
+#define CX23885_BOARD_BASE_INDEX	       40
+#define CX23885_BOARD_BST_PS8512	       (CX23885_BOARD_BASE_INDEX)
+#define CX23885_BOARD_DVBSKY_S952	       (CX23885_BOARD_BASE_INDEX+1)
+#define CX23885_BOARD_DVBSKY_S950	       (CX23885_BOARD_BASE_INDEX+2)
+#define CX23885_BOARD_DVBSKY_S950_CI	       (CX23885_BOARD_BASE_INDEX+3)
+#define CX23885_BOARD_DVBSKY_C2800E_CI	       (CX23885_BOARD_BASE_INDEX+4)
+#define CX23885_BOARD_DVBSKY_T9580	       (CX23885_BOARD_BASE_INDEX+5)
+#define CX23885_BOARD_DVBSKY_T980_CI	       (CX23885_BOARD_BASE_INDEX+6)
+
 #define GPIO_0 0x00000001
 #define GPIO_1 0x00000002
 #define GPIO_2 0x00000004
@@ -231,7 +240,7 @@
 	 */
 	u32			clk_freq;
 	struct cx23885_input    input[MAX_CX23885_INPUT];
-	int			ci_type; /* for NetUP */
+	int			ci_type; /* 1 and 2 for NetUP, 3 for DVBSky. */
 	/* Force bottom field first during DMA (888 workaround) */
 	u32                     force_bff;
 };
diff -urN a/drivers/media/pci/cx23885/cx23885-input.c b/drivers/media/pci/cx23885/cx23885-input.c
--- a/drivers/media/pci/cx23885/cx23885-input.c	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/pci/cx23885/cx23885-input.c	2013-05-06 21:41:19.000000000 +0800
@@ -89,6 +89,13 @@
 	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
 	case CX23885_BOARD_TEVII_S470:
 	case CX23885_BOARD_HAUPPAUGE_HVR1250:
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T9580:
+	case CX23885_BOARD_DVBSKY_T980_CI:
 	case CX23885_BOARD_MYGICA_X8507:
 		/*
 		 * The only boards we handle right now.  However other boards
@@ -141,6 +148,13 @@
 	case CX23885_BOARD_HAUPPAUGE_HVR1850:
 	case CX23885_BOARD_HAUPPAUGE_HVR1290:
 	case CX23885_BOARD_HAUPPAUGE_HVR1250:
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T9580:
+	case CX23885_BOARD_DVBSKY_T980_CI:
 	case CX23885_BOARD_MYGICA_X8507:
 		/*
 		 * The IR controller on this board only returns pulse widths.
@@ -291,6 +305,19 @@
 		/* A guess at the remote */
 		rc_map = RC_MAP_TEVII_NEC;
 		break;
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T9580:
+	case CX23885_BOARD_DVBSKY_T980_CI:
+		/* Integrated CX2388[58] IR controller */
+		driver_type = RC_DRIVER_IR_RAW;
+		allowed_protos = RC_BIT_ALL;
+		/* A guess at the remote */
+		rc_map = RC_MAP_DVBSKY;
+		break;
 	case CX23885_BOARD_MYGICA_X8507:
 		/* Integrated CX23885 IR controller */
 		driver_type = RC_DRIVER_IR_RAW;
diff -urN a/drivers/media/pci/cx23885/Kconfig b/drivers/media/pci/cx23885/Kconfig
--- a/drivers/media/pci/cx23885/Kconfig	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/pci/cx23885/Kconfig	2013-05-06 21:42:37.000000000 +0800
@@ -23,6 +23,9 @@
 	select DVB_STB6100 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV6110 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_CX24116 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_M88DS3103 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_M88DC2800 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_SIT2 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV0900 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_DS3000 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_TS2020 if MEDIA_SUBDRV_AUTOSELECT
diff -urN a/drivers/media/pci/cx88/cx88-cards.c b/drivers/media/pci/cx88/cx88-cards.c
--- a/drivers/media/pci/cx88/cx88-cards.c	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/pci/cx88/cx88-cards.c	2013-05-03 17:06:55.000000000 +0800
@@ -2309,6 +2309,18 @@
 		} },
 		.mpeg           = CX88_MPEG_DVB,
 	},
+	[CX88_BOARD_BST_PS8312] = {
+		.name           = "Bestunar PS8312 DVB-S/S2",
+		.tuner_type     = UNSET,
+		.radio_type     = UNSET,
+		.tuner_addr     = ADDR_UNSET,
+		.radio_addr     = ADDR_UNSET,
+		.input          = { {
+			.type   = CX88_VMUX_DVB,
+			.vmux   = 0,
+		} },
+		.mpeg           = CX88_MPEG_DVB,
+	},
 };
 
 /* ------------------------------------------------------------------ */
@@ -2813,6 +2825,10 @@
 		.subvendor = 0x1822,
 		.subdevice = 0x0023,
 		.card      = CX88_BOARD_TWINHAN_VP1027_DVBS,
+	}, {
+		.subvendor = 0x14f1,
+		.subdevice = 0x8312,
+		.card      = CX88_BOARD_BST_PS8312,
 	},
 };
 
@@ -3547,6 +3563,12 @@
 		cx_write(MO_SRST_IO, 1);
 		msleep(100);
 		break;
+	case  CX88_BOARD_BST_PS8312:
+		cx_write(MO_GP1_IO, 0x808000);
+		msleep(100);
+		cx_write(MO_GP1_IO, 0x808080);
+		msleep(100);
+		break;
 	} /*end switch() */
 
 
diff -urN a/drivers/media/pci/cx88/cx88-dvb.c b/drivers/media/pci/cx88/cx88-dvb.c
--- a/drivers/media/pci/cx88/cx88-dvb.c	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/pci/cx88/cx88-dvb.c	2013-05-03 17:09:09.000000000 +0800
@@ -54,6 +54,7 @@
 #include "stv0288.h"
 #include "stb6000.h"
 #include "cx24116.h"
+#include "m88ds3103.h"
 #include "stv0900.h"
 #include "stb6100.h"
 #include "stb6100_proc.h"
@@ -459,6 +460,56 @@
 		return core->prev_set_voltage(fe, voltage);
 	return 0;
 }
+/*CX88_BOARD_BST_PS8312*/
+static int bst_dvbs_set_voltage(struct dvb_frontend *fe,
+				      fe_sec_voltage_t voltage)
+{
+	struct cx8802_dev *dev= fe->dvb->priv;
+	struct cx88_core *core = dev->core;
+
+	cx_write(MO_GP1_IO, 0x111111);
+	switch (voltage) {
+		case SEC_VOLTAGE_13:
+			cx_write(MO_GP1_IO, 0x020200);
+			break;
+		case SEC_VOLTAGE_18:
+			cx_write(MO_GP1_IO, 0x020202);
+			break;
+		case SEC_VOLTAGE_OFF:
+			cx_write(MO_GP1_IO, 0x111100);
+			break;
+	}
+
+	if (core->prev_set_voltage)
+		return core->prev_set_voltage(fe, voltage);
+	return 0;
+}
+
+static int bst_dvbs_set_voltage_v2(struct dvb_frontend *fe,
+				      fe_sec_voltage_t voltage)
+{
+	struct cx8802_dev *dev= fe->dvb->priv;
+	struct cx88_core *core = dev->core;
+
+	cx_write(MO_GP1_IO, 0x111101);
+	switch (voltage) {
+		case SEC_VOLTAGE_13:
+			cx_write(MO_GP1_IO, 0x020200);
+			break;
+		case SEC_VOLTAGE_18:
+
+			cx_write(MO_GP1_IO, 0x020202);
+			break;
+		case SEC_VOLTAGE_OFF:
+
+			cx_write(MO_GP1_IO, 0x111110);
+			break;
+	}
+
+	if (core->prev_set_voltage)
+		return core->prev_set_voltage(fe, voltage);
+	return 0;
+}
 
 static int vp1027_set_voltage(struct dvb_frontend *fe,
 				    fe_sec_voltage_t voltage)
@@ -706,6 +757,11 @@
 	.clk_out_div = 1,
 };
 
+static struct m88ds3103_config dvbsky_ds3103_config = {
+	.demod_address = 0x68,
+	.set_ts_params = ds3000_set_ts_param,
+};
+
 static const struct stv0900_config prof_7301_stv0900_config = {
 	.demod_address = 0x6a,
 /*	demod_mode = 0,*/
@@ -1477,6 +1533,35 @@
 				&tevii_ts2020_config, &core->i2c_adap);
 			fe0->dvb.frontend->ops.set_voltage =
 							tevii_dvbs_set_voltage;
+                }		
+                break;
+	case CX88_BOARD_BST_PS8312:
+		fe0->dvb.frontend = dvb_attach(m88ds3103_attach,
+						&dvbsky_ds3103_config,
+						&core->i2c_adap);
+		if (fe0->dvb.frontend != NULL){
+			int ret;
+			u8 b0[] = { 0x60 };
+			u8 b1[2] = { 0 };
+			struct i2c_msg msg[] = {
+				{
+				.addr = 0x50,
+				.flags = 0,
+				.buf = b0,
+				.len = 1
+				}, {
+				.addr = 0x50,
+				.flags = I2C_M_RD,
+				.buf = b1,
+				.len = 2
+				}
+			};
+			ret = i2c_transfer(&core->i2c_adap, msg, 2);
+			printk("PS8312: config = %02x, %02x", b1[0],b1[1]);
+			if(b1[0] == 0xaa)
+				fe0->dvb.frontend->ops.set_voltage = bst_dvbs_set_voltage_v2;
+			else			
+				fe0->dvb.frontend->ops.set_voltage = bst_dvbs_set_voltage;
 		}
 		break;
 	case CX88_BOARD_OMICOM_SS4_PCI:
diff -urN a/drivers/media/pci/cx88/cx88.h b/drivers/media/pci/cx88/cx88.h
--- a/drivers/media/pci/cx88/cx88.h	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/pci/cx88/cx88.h	2013-05-03 17:05:57.000000000 +0800
@@ -238,6 +238,7 @@
 #define CX88_BOARD_WINFAST_DTV1800H_XC4000 88
 #define CX88_BOARD_WINFAST_TV2000_XP_GLOBAL_6F36 89
 #define CX88_BOARD_WINFAST_TV2000_XP_GLOBAL_6F43 90
+#define CX88_BOARD_BST_PS8312              91
 
 enum cx88_itype {
 	CX88_VMUX_COMPOSITE1 = 1,
diff -urN a/drivers/media/pci/cx88/cx88-input.c b/drivers/media/pci/cx88/cx88-input.c
--- a/drivers/media/pci/cx88/cx88-input.c	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/pci/cx88/cx88-input.c	2013-01-26 14:52:03.000000000 +0800
@@ -419,6 +419,10 @@
 		rc_type          = RC_BIT_NEC;
 		ir->sampling     = 0xff00; /* address */
 		break;
+	case CX88_BOARD_BST_PS8312:
+		ir_codes         = RC_MAP_DVBSKY;
+		ir->sampling     = 0xff00; /* address */
+		break;
 	}
 
 	if (!ir_codes) {
diff -urN a/drivers/media/pci/cx88/Kconfig b/drivers/media/pci/cx88/Kconfig
--- a/drivers/media/pci/cx88/Kconfig	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/pci/cx88/Kconfig	2013-05-03 17:10:41.000000000 +0800
@@ -57,6 +57,7 @@
 	select DVB_ISL6421 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_S5H1411 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_CX24116 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_M88DS3103 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV0299 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV0288 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STB6000 if MEDIA_SUBDRV_AUTOSELECT
diff -urN a/drivers/media/rc/keymaps/Makefile b/drivers/media/rc/keymaps/Makefile
--- a/drivers/media/rc/keymaps/Makefile	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/rc/keymaps/Makefile	2013-05-03 17:43:41.000000000 +0800
@@ -27,6 +27,7 @@
 			rc-dm1105-nec.o \
 			rc-dntv-live-dvb-t.o \
 			rc-dntv-live-dvbt-pro.o \
+			rc-dvbsky.o \
 			rc-em-terratec.o \
 			rc-encore-enltv2.o \
 			rc-encore-enltv.o \
diff -urN a/drivers/media/rc/keymaps/rc-dvbsky.c b/drivers/media/rc/keymaps/rc-dvbsky.c
--- a/drivers/media/rc/keymaps/rc-dvbsky.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/rc/keymaps/rc-dvbsky.c	2013-01-26 14:52:49.000000000 +0800
@@ -0,0 +1,78 @@
+/* rc-dvbsky.c - Keytable for Dvbsky Remote Controllers
+ *
+ * keymap imported from ir-keymaps.c
+ *
+ *
+ * Copyright (c) 2010-2012 by Nibble Max <nibble.max@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <media/rc-map.h>
+#include <linux/module.h>
+/*
+ * This table contains the complete RC5 code, instead of just the data part
+ */
+
+static struct rc_map_table rc5_dvbsky[] = {
+	{ 0x0000, KEY_0 },
+	{ 0x0001, KEY_1 },
+	{ 0x0002, KEY_2 },
+	{ 0x0003, KEY_3 },
+	{ 0x0004, KEY_4 },
+	{ 0x0005, KEY_5 },
+	{ 0x0006, KEY_6 },
+	{ 0x0007, KEY_7 },
+	{ 0x0008, KEY_8 },
+	{ 0x0009, KEY_9 },
+	{ 0x000a, KEY_MUTE },
+	{ 0x000d, KEY_OK },
+	{ 0x000b, KEY_STOP },
+	{ 0x000c, KEY_EXIT },
+	{ 0x000e, KEY_CAMERA }, /*Snap shot*/
+	{ 0x000f, KEY_SUBTITLE }, /*PIP*/
+	{ 0x0010, KEY_VOLUMEUP },
+	{ 0x0011, KEY_VOLUMEDOWN },
+	{ 0x0012, KEY_FAVORITES },
+	{ 0x0013, KEY_LIST }, /*Info*/
+	{ 0x0016, KEY_PAUSE },
+	{ 0x0017, KEY_PLAY },
+	{ 0x001f, KEY_RECORD },
+	{ 0x0020, KEY_CHANNELDOWN },
+	{ 0x0021, KEY_CHANNELUP },
+	{ 0x0025, KEY_POWER2 },
+	{ 0x0026, KEY_REWIND },
+	{ 0x0027, KEY_FASTFORWARD },
+	{ 0x0029, KEY_LAST },
+	{ 0x002b, KEY_MENU },
+	{ 0x002c, KEY_EPG },
+	{ 0x002d, KEY_ZOOM },
+};
+
+static struct rc_map_list rc5_dvbsky_map = {
+	.map = {
+		.scan    = rc5_dvbsky,
+		.size    = ARRAY_SIZE(rc5_dvbsky),
+		.rc_type = RC_TYPE_RC5,
+		.name    = RC_MAP_DVBSKY,
+	}
+};
+
+static int __init init_rc_map_rc5_dvbsky(void)
+{
+	return rc_map_register(&rc5_dvbsky_map);
+}
+
+static void __exit exit_rc_map_rc5_dvbsky(void)
+{
+	rc_map_unregister(&rc5_dvbsky_map);
+}
+
+module_init(init_rc_map_rc5_dvbsky)
+module_exit(exit_rc_map_rc5_dvbsky)
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Nibble Max <nibble.max@gmail.com>");
diff -urN a/drivers/media/usb/dvb-usb-v2/dvbsky.c b/drivers/media/usb/dvb-usb-v2/dvbsky.c
--- a/drivers/media/usb/dvb-usb-v2/dvbsky.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/usb/dvb-usb-v2/dvbsky.c	2013-05-06 21:44:50.000000000 +0800
@@ -0,0 +1,725 @@
+/*
+ * Driver for DVBSky USB2.0 receiver
+ *
+ * Copyright (C) 2013 Max nibble <nibble.max@gmail.com>
+ *
+ * CIMax code is copied and modified from:
+ * CIMax2(R) SP2 driver in conjunction with NetUp Dual DVB-S2 CI card
+ * Copyright (C) 2009 NetUP Inc.
+ * Copyright (C) 2009 Igor M. Liplianin <liplianin@netup.ru>
+ * Copyright (C) 2009 Abylay Ospan <aospan@netup.ru>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "dvb_ca_en50221.h"
+#include "dvb_usb.h"
+#include "sit2.h"
+#include "m88ds3103.h"
+
+static int dvbsky_debug;
+module_param(dvbsky_debug, int, 0644);
+MODULE_PARM_DESC(dvbsky_debug, "Activates dvbsky usb debugging (default:0)");
+
+#define DVBSKY_CI_CTL		0x04
+#define DVBSKY_CI_RD		1
+
+#define dprintk(args...) \
+	do { \
+		if (dvbsky_debug) \
+			printk(KERN_INFO "dvbsky_usb: " args); \
+	} while (0)
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+struct dvbsky_state {
+	struct mutex stream_mutex;
+	u8 has_ci;
+	u8 ci_attached;
+	struct dvb_ca_en50221 ci;
+	unsigned long next_status_checked_time;
+	u8 ci_i2c_addr;
+	u8 current_ci_flag;
+	int ci_status;
+};
+
+static int dvbsky_stream_ctrl(struct dvb_usb_device *d, u8 onoff)
+{
+	struct dvbsky_state *state = d_to_priv(d);
+	int ret;
+	u8 obuf_pre[3] = { 0x37, 0, 0 };
+	u8 obuf_post[3] = { 0x36, 3, 0 };
+	dprintk("%s() -off \n", __func__);
+	mutex_lock(&state->stream_mutex);
+	ret = dvb_usbv2_generic_write(d, obuf_pre, 3);
+	if (!ret && onoff) {
+		msleep(10);
+		ret = dvb_usbv2_generic_write(d, obuf_post, 3);
+		dprintk("%s() -on \n", __func__);
+	}
+	mutex_unlock(&state->stream_mutex);
+	return ret;
+}
+
+/* CI opertaions */
+static int dvbsky_ci_read_i2c(struct i2c_adapter *i2c_adap, u8 addr, u8 reg,
+						u8 *buf, int len)
+{
+	int ret;
+	struct i2c_msg msg[] = {
+		{
+			.addr	= addr,
+			.flags	= 0,
+			.buf	= &reg,
+			.len	= 1
+		}, {
+			.addr	= addr,
+			.flags	= I2C_M_RD,
+			.buf	= buf,
+			.len	= len
+		}
+	};
+	
+	ret = i2c_transfer(i2c_adap, msg, 2);
+	
+	if (ret != 2) {
+		dprintk("%s: error, Reg = 0x%02x, Status = %d\n", __func__, reg, ret);
+		return -1;
+	}
+	return 0;
+}
+
+static int dvbsky_ci_write_i2c(struct i2c_adapter *i2c_adap, u8 addr, u8 reg,
+						u8 *buf, int len)
+{
+	int ret;
+	u8 buffer[len + 1];
+
+	struct i2c_msg msg = {
+		.addr	= addr,
+		.flags	= 0,
+		.buf	= &buffer[0],
+		.len	= len + 1
+	};
+
+	buffer[0] = reg;
+	memcpy(&buffer[1], buf, len);
+
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+
+	if (ret != 1) {
+		dprintk("%s: error, Reg=[0x%02x], Status=%d\n", __func__, reg, ret);
+		return -1;
+	}
+	return 0;
+}
+
+static int dvbsky_ci_op_cam(struct dvb_ca_en50221 *ci, int slot,
+				u8 flag, u8 read, int addr, u8 data)
+{
+	struct dvb_usb_device *d = ci->data;
+	struct dvbsky_state *state = d_to_priv(d);	
+	u8 store;
+	int ret;
+	u8 command[4], respond[2], command_size, respond_size;
+
+	/*dprintk("%s()\n", __func__);*/
+	if (0 != slot)
+		return -EINVAL;
+
+	if (state->current_ci_flag != flag) {
+		ret = dvbsky_ci_read_i2c(&d->i2c_adap, state->ci_i2c_addr,
+				0, &store, 1);
+		if (ret != 0)
+			return ret;
+
+		store &= ~0x0c;
+		store |= flag;
+
+		ret = dvbsky_ci_write_i2c(&d->i2c_adap, state->ci_i2c_addr,
+				0, &store, 1);
+		if (ret != 0)
+			return ret;
+	}
+	state->current_ci_flag = flag;
+
+	command[1] = (u8)((addr >> 8) & 0xff); /*high part of address*/
+	command[2] = (u8)(addr & 0xff); /*low part of address*/
+	if (read) {
+		command[0] = 0x71;
+		command_size = 3;
+		respond_size = 2;
+	} else {
+		command[0] = 0x70;
+		command[3] = data;
+		command_size = 4;
+		respond_size = 1;
+	}
+	ret = dvb_usbv2_generic_rw(d, command, command_size, respond, respond_size);
+
+	return (read) ? respond[1] : 0;
+}
+
+static int dvbsky_ci_read_attribute_mem(struct dvb_ca_en50221 *ci,
+						int slot, int addr)
+{
+	return dvbsky_ci_op_cam(ci, slot, 0, DVBSKY_CI_RD, addr, 0);
+}
+
+static int dvbsky_ci_write_attribute_mem(struct dvb_ca_en50221 *ci,
+						int slot, int addr, u8 data)
+{
+	return dvbsky_ci_op_cam(ci, slot, 0, 0, addr, data);
+}
+
+static int dvbsky_ci_read_cam_ctl(struct dvb_ca_en50221 *ci, int slot, u8 addr)
+{
+	return dvbsky_ci_op_cam(ci, slot, DVBSKY_CI_CTL, DVBSKY_CI_RD, addr, 0);
+}
+
+static int dvbsky_ci_write_cam_ctl(struct dvb_ca_en50221 *ci, int slot,
+							u8 addr, u8 data)
+{
+	return dvbsky_ci_op_cam(ci, slot, DVBSKY_CI_CTL, 0, addr, data);
+}
+
+static int dvbsky_ci_slot_reset(struct dvb_ca_en50221 *ci, int slot)
+{
+	struct dvb_usb_device *d = ci->data;
+	struct dvbsky_state *state = d_to_priv(d);
+	u8 buf =  0x80;
+	int ret;
+	dprintk("%s() slot=%d\n", __func__, slot);
+
+	if (0 != slot)
+		return -EINVAL;
+
+	udelay(500);
+	ret = dvbsky_ci_write_i2c(&d->i2c_adap, state->ci_i2c_addr,
+							0, &buf, 1);
+
+	if (ret != 0)
+		return ret;
+
+	udelay(500);
+
+	buf = 0x00;
+	ret = dvbsky_ci_write_i2c(&d->i2c_adap, state->ci_i2c_addr,
+							0, &buf, 1);
+	msleep(1000);
+	dprintk("%s() slot=%d complete\n", __func__, slot);
+	return 0;
+
+}
+
+static int dvbsky_ci_slot_shutdown(struct dvb_ca_en50221 *ci, int slot)
+{
+	/* not implemented */
+	dprintk("%s()\n", __func__);
+	return 0;
+}
+
+static int dvbsky_ci_slot_ts_enable(struct dvb_ca_en50221 *ci, int slot)
+{
+	struct dvb_usb_device *d = ci->data;
+	struct dvbsky_state *state = d_to_priv(d);
+	u8 buf;
+	int ret;
+
+	dprintk("%s()\n", __func__);
+	if (0 != slot)
+		return -EINVAL;
+
+	dvbsky_ci_read_i2c(&d->i2c_adap, state->ci_i2c_addr,
+			0, &buf, 1);
+	buf |= 0x60;
+
+	ret = dvbsky_ci_write_i2c(&d->i2c_adap, state->ci_i2c_addr,
+							0, &buf, 1);
+	return ret;
+}
+
+static int dvbsky_ci_poll_slot_status(struct dvb_ca_en50221 *ci, int slot,
+	int open)
+{
+	struct dvb_usb_device *d = ci->data;
+	struct dvbsky_state *state = d_to_priv(d);
+	int ret = 0;
+	u8 buf = 0;
+	/*dprintk("%s()\n", __func__);*/
+
+	/* CAM module INSERT/REMOVE processing. slow operation because of i2c
+	 * transfers */
+	if (time_after(jiffies, state->next_status_checked_time)) {
+		ret = dvbsky_ci_read_i2c(&d->i2c_adap, state->ci_i2c_addr,
+				0, &buf, 1);
+
+		/*dprintk("%s() status=%x\n", __func__, buf);*/
+		
+		state->next_status_checked_time = jiffies
+			+ msecs_to_jiffies(1000);
+
+		if (ret != 0)
+			return 0;
+
+		if (buf & 1) {
+			state->ci_status = DVB_CA_EN50221_POLL_CAM_PRESENT |
+				DVB_CA_EN50221_POLL_CAM_READY;
+		}
+		else
+			state->ci_status = 0;
+	}
+	/*dprintk("%s() ret=%x\n", __func__, state->ci_status);*/
+	return state->ci_status;
+}
+
+static int dvbsky_ci_init(struct dvb_usb_device *d)
+{
+	struct dvbsky_state *state = d_to_priv(d);
+	int ret;
+	u8 cimax_init[34] = {
+		0x00, /* module A control*/
+		0x00, /* auto select mask high A */
+		0x00, /* auto select mask low A */
+		0x00, /* auto select pattern high A */
+		0x00, /* auto select pattern low A */
+		0x44, /* memory access time A */
+		0x00, /* invert input A */
+		0x00, /* RFU */
+		0x00, /* RFU */
+		0x00, /* module B control*/
+		0x00, /* auto select mask high B */
+		0x00, /* auto select mask low B */
+		0x00, /* auto select pattern high B */
+		0x00, /* auto select pattern low B */
+		0x44, /* memory access time B */
+		0x00, /* invert input B */
+		0x00, /* RFU */
+		0x00, /* RFU */
+		0x00, /* auto select mask high Ext */
+		0x00, /* auto select mask low Ext */
+		0x00, /* auto select pattern high Ext */
+		0x00, /* auto select pattern low Ext */
+		0x00, /* RFU */
+		0x02, /* destination - module A */
+		0x01, /* power on (use it like store place) */
+		0x00, /* RFU */
+		0x00, /* int status read only */
+		0x00, /* Max: Disable the interrupt in USB solution.*/
+		0x05, /* EXTINT=active-high, INT=push-pull */
+		0x00, /* USCG1 */
+		0x04, /* ack active low */
+		0x00, /* LOCK = 0 */
+		0x22, /* serial mode, rising in, rising out, MSB first*/
+		0x00  /* synchronization */
+	};	
+	dprintk("%s()\n", __func__);
+	state->current_ci_flag = 0xff;
+	state->ci_status = 0;
+	state->next_status_checked_time = jiffies + msecs_to_jiffies(1000);
+	state->ci_i2c_addr = 0x40;
+
+	state->ci.owner               = THIS_MODULE;
+	state->ci.read_attribute_mem  = dvbsky_ci_read_attribute_mem;
+	state->ci.write_attribute_mem = dvbsky_ci_write_attribute_mem;
+	state->ci.read_cam_control    = dvbsky_ci_read_cam_ctl;
+	state->ci.write_cam_control   = dvbsky_ci_write_cam_ctl;
+	state->ci.slot_reset          = dvbsky_ci_slot_reset;
+	state->ci.slot_shutdown       = dvbsky_ci_slot_shutdown;
+	state->ci.slot_ts_enable      = dvbsky_ci_slot_ts_enable;
+	state->ci.poll_slot_status    = dvbsky_ci_poll_slot_status;
+	state->ci.data                = d;
+
+	ret = dvbsky_ci_write_i2c(&d->i2c_adap, state->ci_i2c_addr,
+						0, &cimax_init[0], 34);
+	/* lock registers */
+	ret |= dvbsky_ci_write_i2c(&d->i2c_adap, state->ci_i2c_addr,
+						0x1f, &cimax_init[0x18], 1);
+	/* power on slots */
+	ret |= dvbsky_ci_write_i2c(&d->i2c_adap, state->ci_i2c_addr,
+						0x18, &cimax_init[0x18], 1);
+	if (0 != ret)
+		return ret;
+		
+	ret = dvb_ca_en50221_init(&d->adapter[0].dvb_adap, &state->ci, 0, 1);
+	if (ret)
+		return ret;
+	state->ci_attached = 1;
+	dprintk("%s() complete.\n", __func__);
+	return 0;
+}
+
+static void dvbsky_ci_release(struct dvb_usb_device *d)
+{
+	struct dvbsky_state *state = d_to_priv(d);
+
+	/* detach CI */
+	if (state->ci_attached)
+		dvb_ca_en50221_release(&state->ci);
+
+	return;
+}
+
+static int dvbsky_streaming_ctrl(struct dvb_frontend *fe, int onoff)
+{
+	struct dvb_usb_device *d = fe_to_d(fe);
+	/*dprintk("%s() %d\n", __func__, onoff);*/
+	return dvbsky_stream_ctrl(d, (onoff == 0) ? 0 : 1);
+}
+
+/* GPIO */
+static int dvbsky_gpio_ctrl(struct dvb_usb_device *d, u8 gport, u8 value)
+{
+	u8 obuf[64], ibuf[64];
+	obuf[0] = 0x0e;
+	obuf[1] = gport;
+	obuf[2] = value;
+	return dvb_usbv2_generic_rw(d, obuf, 3, ibuf, 1);
+}
+
+/* I2C */
+static int dvbsky_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
+	int num)
+{
+	struct dvb_usb_device *d = i2c_get_adapdata(adap);
+	int ret = 0;
+	u8 ibuf[64], obuf[64]; 
+
+	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
+		return -EAGAIN;
+
+	if (num > 2) {
+		printk(KERN_ERR "dvbsky_usb: too many i2c messages[%d] than 2.", num);
+		ret = -EOPNOTSUPP;
+		goto i2c_error;
+	}
+		
+	if(num == 1) {
+		if (msg[0].len > 60) {
+			printk(KERN_ERR "dvbsky_usb: too many i2c bytes[%d] than 60.", msg[0].len);
+			ret = -EOPNOTSUPP;
+			goto i2c_error;
+		}
+		if (msg[0].flags & I2C_M_RD) {
+			/* single read */
+			obuf[0] = 0x09;
+			obuf[1] = 0;
+			obuf[2] = msg[0].len;
+			obuf[3] = msg[0].addr;
+			ret = dvb_usbv2_generic_rw(d, obuf, 4, ibuf, msg[0].len + 1);
+			/*dprintk("%s(): read status = %d\n", __func__, ibuf[0]);*/
+			if (!ret)
+				memcpy(msg[0].buf, &ibuf[1], msg[0].len);
+		} else {
+			/* write */
+			obuf[0] = 0x08;
+			obuf[1] = msg[0].addr;
+			obuf[2] = msg[0].len;
+			memcpy(&obuf[3], msg[0].buf, msg[0].len);
+			ret = dvb_usbv2_generic_rw(d, obuf, msg[0].len + 3, ibuf, 1);
+			/*dprintk("%s(): write status = %d\n", __func__, ibuf[0]);*/
+		}
+	} else {
+		if ((msg[0].len > 60) || (msg[1].len > 60)) {
+			printk(KERN_ERR "dvbsky_usb: too many i2c bytes[w-%d][r-%d] than 60.", msg[0].len, msg[1].len);
+			ret = -EOPNOTSUPP;
+			goto i2c_error;
+		}
+		/* write then read */
+		obuf[0] = 0x09;
+		obuf[1] = msg[0].len;
+		obuf[2] = msg[1].len;
+		obuf[3] = msg[0].addr;
+		memcpy(&obuf[4], msg[0].buf, msg[0].len);
+		ret = dvb_usbv2_generic_rw(d, obuf, msg[0].len + 4, ibuf, msg[1].len + 1);
+		/*dprintk("%s(): write then read status = %d\n", __func__, ibuf[0]);*/
+		if (!ret)
+			memcpy(msg[1].buf, &ibuf[1], msg[1].len);
+	}
+i2c_error:
+	mutex_unlock(&d->i2c_mutex);
+	return (ret) ? ret : num;
+}
+
+static u32 dvbsky_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm dvbsky_i2c_algo = {
+	.master_xfer   = dvbsky_i2c_xfer,
+	.functionality = dvbsky_i2c_func,
+};
+
+#if IS_ENABLED(CONFIG_RC_CORE)
+static int dvbsky_rc_query(struct dvb_usb_device *d)
+{
+	u32 code = 0xffff;
+	u8 obuf[2], ibuf[2], toggle;
+	int ret;
+	obuf[0] = 0x10;
+	ret = dvb_usbv2_generic_rw(d, obuf, 1, ibuf, 2);
+	if(ret == 0)
+		code = (ibuf[0] << 8) | ibuf[1];
+
+	if (code != 0xffff) {
+		dprintk("rc code: %x", code);
+		toggle = (code & 0x800) ? 1 : 0;
+		code &= 0x3f;
+		rc_keydown(d->rc_dev, code, toggle);
+	}
+	return 0;
+}
+
+static int dvbsky_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)
+{
+	rc->allowed_protos = RC_BIT_RC5;
+	rc->query          = dvbsky_rc_query;
+	rc->interval       = 300;
+	return 0;
+}
+#else
+	#define dvbsky_get_rc_config NULL
+#endif
+
+static int dvbsky_sync_ctrl(struct dvb_frontend *fe)
+{
+	struct dvb_usb_device *d = fe_to_d(fe);
+	return dvbsky_stream_ctrl(d, 1);
+}
+
+static int dvbsky_usb_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	struct dvb_usb_device *d = fe_to_d(fe);
+	u8 value;
+
+	if (voltage == SEC_VOLTAGE_OFF)
+		value = 0;
+	else
+		value = 1;
+	return dvbsky_gpio_ctrl(d, 0x80, value);
+}
+
+static struct sit2_config dvbsky_usb_sit2_config = {
+	.ts_bus_mode = 2,
+	.ts_clock_mode = 1,
+	.start_ctrl = NULL,
+};
+
+static int dvbsky_t680c_attach(struct dvb_usb_adapter *adap)
+{
+	struct dvbsky_state *state = adap_to_priv(adap);
+	struct dvb_usb_device *d = adap_to_d(adap);
+	int ret = 0;
+	
+	dprintk("%s, build on %s %s()\n", __func__, __DATE__,__TIME__);
+	
+	dvbsky_gpio_ctrl(d, 0x83, 0);
+	msleep(50);
+	dvbsky_gpio_ctrl(d, 0x83, 1);
+	msleep(20);
+	
+	adap->fe[0] = dvb_attach(sit2_attach,
+				&dvbsky_usb_sit2_config,
+				&d->i2c_adap);
+	if (!adap->fe[0]) {
+		printk(KERN_ERR "dvbsky_t680c_attach fail.");
+		ret = -ENODEV;
+	}
+	
+	state->has_ci = 1;
+
+	return ret;
+}
+
+static int dvbsky_read_mac_addr(struct dvb_usb_adapter *adap, u8 mac[6])
+{
+	struct dvb_usb_device *d = adap_to_d(adap);
+	u8 obuf[] = { 0x1e, 0x00 };
+	u8 ibuf[6] = { 0 };
+	struct i2c_msg msg[] = {
+		{
+			.addr = 0x51,
+			.flags = 0,
+			.buf = obuf,
+			.len = 2,
+		}, {
+			.addr = 0x51,
+			.flags = I2C_M_RD,
+			.buf = ibuf,
+			.len = 6,
+
+		}
+	};
+	
+	if (i2c_transfer(&d->i2c_adap, msg, 2) == 2)
+		memcpy(mac, ibuf, 6);
+
+	printk(KERN_INFO "dvbsky_usb MAC address=%pM\n", mac);
+	
+	return 0;
+}
+
+static struct m88ds3103_config dvbsky_usb_ds3103_config = {
+	.demod_address = 0x68,
+	.ci_mode = 1,
+	.pin_ctrl = 0x83,
+	.ts_mode = 0,
+	.start_ctrl = dvbsky_sync_ctrl,
+	.set_voltage = dvbsky_usb_set_voltage,
+};
+
+static int dvbsky_s960_attach(struct dvb_usb_adapter *adap)
+{
+	struct dvbsky_state *state = adap_to_priv(adap);
+	struct dvb_usb_device *d = adap_to_d(adap);
+	int ret = 0;
+	
+	dprintk("%s()\n", __func__);
+
+	dvbsky_gpio_ctrl(d, 0x04, 1);
+		
+	dvbsky_gpio_ctrl(d, 0x83, 0);
+	msleep(50);
+	dvbsky_gpio_ctrl(d, 0x83, 1);
+	msleep(20);
+	
+	adap->fe[0] = dvb_attach(m88ds3103_attach,
+				&dvbsky_usb_ds3103_config,
+				&d->i2c_adap);
+	if (!adap->fe[0]) {
+		printk(KERN_ERR "dvbsky_s960_attach fail.");
+		ret = -ENODEV;
+	}
+	
+	state->has_ci = 0;
+
+	return ret;
+}
+
+static int dvbsky_identify_state(struct dvb_usb_device *d, const char **name)
+{
+	return WARM;
+}
+
+static int dvbsky_init(struct dvb_usb_device *d)
+{
+	struct dvbsky_state *state = d_to_priv(d);
+	int ret;
+
+	/* use default interface */
+	ret = usb_set_interface(d->udev, 0, 0);
+	if (ret)
+		return ret;
+
+	mutex_init(&state->stream_mutex);
+	
+	/* attach CI */
+	if (state->has_ci) {
+		dvbsky_gpio_ctrl(d, 0xc0, 1);
+		msleep(100);
+		dvbsky_gpio_ctrl(d, 0xc0, 0);
+		msleep(50);
+		state->ci_attached = 0;
+		ret = dvbsky_ci_init(d);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+static void dvbsky_exit(struct dvb_usb_device *d)
+{
+	return dvbsky_ci_release(d);
+}
+
+/* DVB USB Driver stuff */
+static struct dvb_usb_device_properties dvbsky_t680c_props = {
+	.driver_name = KBUILD_MODNAME,
+	.owner = THIS_MODULE,
+	.adapter_nr = adapter_nr,
+	.size_of_priv = sizeof(struct dvbsky_state),
+
+	.generic_bulk_ctrl_endpoint = 0x01,
+	.generic_bulk_ctrl_endpoint_response = 0x81,
+
+	.i2c_algo         = &dvbsky_i2c_algo,
+	.frontend_attach  = dvbsky_t680c_attach,
+	.init             = dvbsky_init,
+	.get_rc_config    = dvbsky_get_rc_config,
+	.streaming_ctrl   = dvbsky_streaming_ctrl,
+	.identify_state	  = dvbsky_identify_state,
+	.exit             = dvbsky_exit,
+
+	.num_adapters = 1,
+	.adapter = {
+		{
+			.stream = DVB_USB_STREAM_BULK(0x82, 8, 4096),
+		}
+	}
+};
+
+static struct dvb_usb_device_properties dvbsky_s960_props = {
+	.driver_name = KBUILD_MODNAME,
+	.owner = THIS_MODULE,
+	.adapter_nr = adapter_nr,
+	.size_of_priv = sizeof(struct dvbsky_state),
+
+	.generic_bulk_ctrl_endpoint = 0x01,
+	.generic_bulk_ctrl_endpoint_response = 0x81,
+
+	.i2c_algo         = &dvbsky_i2c_algo,
+	.frontend_attach  = dvbsky_s960_attach,
+	.init             = dvbsky_init,
+	.get_rc_config    = dvbsky_get_rc_config,
+	.streaming_ctrl   = dvbsky_streaming_ctrl,
+	.identify_state	  = dvbsky_identify_state,
+	.exit             = dvbsky_exit,
+	.read_mac_address = dvbsky_read_mac_addr,
+
+	.num_adapters = 1,
+	.adapter = {
+		{
+			.stream = DVB_USB_STREAM_BULK(0x82, 8, 4096),
+		}
+	}
+};
+
+static const struct usb_device_id dvbsky_id_table[] = {
+	{ DVB_USB_DEVICE(0x0572, 0x680c,
+		&dvbsky_t680c_props, "DVBSky T680C", RC_MAP_DVBSKY) },
+	{ DVB_USB_DEVICE(0x0572, 0x6831,
+		&dvbsky_s960_props, "DVBSky S960/S860", RC_MAP_DVBSKY) },
+	{ }
+};
+MODULE_DEVICE_TABLE(usb, dvbsky_id_table);
+
+static struct usb_driver dvbsky_usb_driver = {
+	.name = KBUILD_MODNAME,
+	.id_table = dvbsky_id_table,
+	.probe = dvb_usbv2_probe,
+	.disconnect = dvb_usbv2_disconnect,
+	.suspend = dvb_usbv2_suspend,
+	.resume = dvb_usbv2_resume,
+	.reset_resume = dvb_usbv2_reset_resume,
+	.no_dynamic_id = 1,
+	.soft_unbind = 1,
+};
+
+module_usb_driver(dvbsky_usb_driver);
+
+MODULE_AUTHOR("Max nibble <nibble.max@gmail.com>");
+MODULE_DESCRIPTION("Driver for DVBSky USB2.0");
+MODULE_LICENSE("GPL");
diff -urN a/drivers/media/usb/dvb-usb-v2/Kconfig b/drivers/media/usb/dvb-usb-v2/Kconfig
--- a/drivers/media/usb/dvb-usb-v2/Kconfig	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/usb/dvb-usb-v2/Kconfig	2013-05-06 21:57:39.000000000 +0800
@@ -149,3 +149,11 @@
 	help
 	  Say Y here to support the Realtek RTL28xxU DVB USB receiver.
 
+config DVB_USB_DVBSKY
+	tristate "DVBSky USB2.0 support"
+	depends on DVB_USB_V2
+	select DVB_SIT2 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_M88DS3103 if MEDIA_SUBDRV_AUTOSELECT
+	help
+	  Say Y here to support the USB receivers from DVBSky.
+
diff -urN a/drivers/media/usb/dvb-usb-v2/Makefile b/drivers/media/usb/dvb-usb-v2/Makefile
--- a/drivers/media/usb/dvb-usb-v2/Makefile	2013-04-29 08:36:01.000000000 +0800
+++ b/drivers/media/usb/dvb-usb-v2/Makefile	2013-02-17 12:03:00.000000000 +0800
@@ -43,6 +43,9 @@
 dvb-usb-rtl28xxu-objs := rtl28xxu.o
 obj-$(CONFIG_DVB_USB_RTL28XXU) += dvb-usb-rtl28xxu.o
 
+dvb-usb-dvbsky-objs := dvbsky.o
+obj-$(CONFIG_DVB_USB_DVBSKY) += dvb-usb-dvbsky.o
+
 ccflags-y += -I$(srctree)/drivers/media/dvb-core
 ccflags-y += -I$(srctree)/drivers/media/dvb-frontends
 ccflags-y += -I$(srctree)/drivers/media/tuners
diff -urN a/include/media/rc-map.h b/include/media/rc-map.h
--- a/include/media/rc-map.h	2013-04-29 08:36:01.000000000 +0800
+++ b/include/media/rc-map.h	2013-05-03 17:02:46.000000000 +0800
@@ -118,6 +118,7 @@
 #define RC_MAP_DM1105_NEC                "rc-dm1105-nec"
 #define RC_MAP_DNTV_LIVE_DVBT_PRO        "rc-dntv-live-dvbt-pro"
 #define RC_MAP_DNTV_LIVE_DVB_T           "rc-dntv-live-dvb-t"
+#define RC_MAP_DVBSKY                    "rc-dvbsky"
 #define RC_MAP_EMPTY                     "rc-empty"
 #define RC_MAP_EM_TERRATEC               "rc-em-terratec"
 #define RC_MAP_ENCORE_ENLTV2             "rc-encore-enltv2"
